import { DateTime } from 'luxon'

import { Properties } from '@posthog/plugin-scaffold'

import { ClickHouseRouter } from '~/utils/db/clickhouse'
import { logger } from '~/utils/logger'

import { TopicMessage } from '../../../../kafka/producer'
import {
    InternalPerson,
    PersonPropertyFilter,
    PersonUpdateFields,
    PropertiesLastOperation,
    PropertiesLastUpdatedAt,
    Team,
    TeamId,
} from '../../../../types'
import { CreatePersonResult } from '../../../../utils/db/db'
import { parseJSON } from '../../../../utils/json-parse'
import { escapeClickHouseString } from '../../../../utils/utils'
import { PersonUpdate } from '../person-update-batch'
import { InternalPersonWithDistinctId, PersonRepository } from './person-repository'
import { PersonRepositoryTransaction } from './person-repository-transaction'

/**
 * Read-only ClickHouse implementation of PersonRepository, primarily used by batch hogflows.
 *
 * This count/fetch persons by properties implementation mimics the behavior of the existing
 * HogQL-based person queries in Python, it should be functionally equivalent to the queries
 * generated by user_blast_radius.py, specifically `get_user_blast_radius`.
 *
 * Note: This only implements required read methods. Write operations are not supported and will
 * throw errors if called, and can be implemented in the future if needed.
 */
export class ClickHousePersonRepository implements PersonRepository {
    constructor(private clickHouseRouter: ClickHouseRouter) {}

    async countPersonsByProperties(teamPersons: {
        teamId: TeamId
        properties: PersonPropertyFilter[]
    }): Promise<number> {
        const { teamId, properties } = teamPersons

        // Matches the query generated by user_blast_radius.py via HogQLQueryExecutor

        if (properties.length === 0) {
            const query = `
                SELECT count(DISTINCT id) as count
                FROM person
                WHERE team_id = ${parseInt(String(teamId))}
                  AND (id, version) IN (
                      SELECT id, max(version) as max_ver
                      FROM person
                      WHERE team_id = ${parseInt(String(teamId))}
                      GROUP BY id
                      HAVING argMax(is_deleted, version) = 0
                  )
                SETTINGS optimize_aggregation_in_order = 1
            `
            const result = await this.query<{ count: string }>(query)
            return parseInt(result[0].count, 10)
        }

        const propertyFilters = this.buildPropertyFilters(properties)

        const query = `
            SELECT count(DISTINCT id) as count
            FROM person
            WHERE team_id = ${parseInt(String(teamId))}
              AND (id, version) IN (
                  SELECT id, max(version) as max_ver
                  FROM person
                  WHERE team_id = ${parseInt(String(teamId))}
                  GROUP BY id
                  HAVING argMax(is_deleted, version) = 0
                    AND ${propertyFilters}
              )
            SETTINGS optimize_aggregation_in_order = 1
        `

        const result = await this.query<{ count: string }>(query)
        return parseInt(result[0].count, 10)
    }

    async fetchPersonsByProperties(teamPersons: {
        teamId: TeamId
        properties: PersonPropertyFilter[]
        options?: { limit?: number; cursor?: string }
    }): Promise<InternalPersonWithDistinctId[]> {
        const { teamId, properties, options } = teamPersons
        const limit = options?.limit ?? 100
        const cursor = options?.cursor

        const propertyFilters = this.buildPropertyFilters(properties)
        const cursorFilter = cursor ? `AND id > '${escapeClickHouseString(cursor)}'` : ''

        const query = `
            SELECT
                p.id,
                p.team_id,
                p.is_identified,
                p.created_at,
                p.properties,
                p.max_ver as version,
                pd.distinct_id
            FROM (
                SELECT
                    id,
                    team_id,
                    argMax(is_identified, version) as is_identified,
                    argMax(properties, version) as properties,
                    argMin(created_at, version) as created_at,
                    max(version) as max_ver
                FROM person
                WHERE team_id = ${parseInt(String(teamId))}
                  ${cursorFilter}
                  AND (id, version) IN (
                      SELECT id, max(version) as max_ver
                      FROM person
                      WHERE team_id = ${parseInt(String(teamId))}
                      GROUP BY id
                      HAVING argMax(is_deleted, version) = 0
                        ${propertyFilters ? `AND ${propertyFilters}` : ''}
                  )
                GROUP BY id, team_id
                ORDER BY id
                LIMIT ${Math.min(Math.max(1, parseInt(String(limit))), 10000)}
            ) p
            INNER JOIN (
                SELECT
                    team_id,
                    person_id,
                    argMax(distinct_id, version) as distinct_id
                FROM person_distinct_id2
                WHERE team_id = ${parseInt(String(teamId))}
                GROUP BY team_id, person_id
                HAVING argMax(is_deleted, version) = 0
            ) pd ON p.team_id = pd.team_id AND p.id = pd.person_id
            SETTINGS optimize_aggregation_in_order = 1
        `

        logger.debug('ClickHousePersonRepository.fetchPersonsByProperties', {
            properties,
            query,
        })

        const results = await this.query<ClickHousePersonWithDistinctId>(query)
        return results.map((row) => ({
            ...this.convertToInternalPerson(row),
            distinct_id: row.distinct_id,
        }))
    }

    /**
     * Helper method to build property filter conditions for ClickHouse queries.
     * Matches the behavior of Python's property_to_expr for person properties.
     * Note: Does not support cohort properties - those require joins to cohort tables.
     */
    private buildPropertyFilters(properties: PersonPropertyFilter[]): string {
        if (properties.length === 0) {
            return ''
        }

        const filters = properties.map((filter) => {
            const { key, value, operator = 'exact' } = filter
            const escapedKey = escapeClickHouseString(key)

            // Helper to wrap expression in argMax for HAVING clause
            const argMaxProp = (expr: string) => `argMax(${expr}, version)`

            // Normalize values to strings to match Python's _normalize_property_value behavior
            const normalizeValue = (val: any): string | null => {
                if (val === null || val === undefined) {
                    return null
                }
                return String(val)
            }

            switch (operator) {
                case 'exact': {
                    if (Array.isArray(value)) {
                        const normalizedValues = value.map(normalizeValue).filter((v) => v !== null)

                        // Handle empty array case - property can't match empty set
                        if (normalizedValues.length === 0) {
                            return '1=0'
                        }

                        const values = normalizedValues.map((v) => `'${escapeClickHouseString(v!)}'`).join(', ')
                        return `toString(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) IN (${values})`
                    } else {
                        const normalizedValue = normalizeValue(value)
                        if (normalizedValue === null) {
                            return `${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)} = ''`
                        }
                        return `toString(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) = '${escapeClickHouseString(normalizedValue)}'`
                    }
                }

                case 'is_not': {
                    if (Array.isArray(value)) {
                        const normalizedValues = value.map(normalizeValue).filter((v) => v !== null)

                        // Handle empty array case - property is always not in empty set
                        if (normalizedValues.length === 0) {
                            return '1=1'
                        }

                        const values = normalizedValues.map((v) => `'${escapeClickHouseString(v!)}'`).join(', ')
                        return `toString(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) NOT IN (${values})`
                    } else {
                        const normalizedValue = normalizeValue(value)
                        if (normalizedValue === null) {
                            return `${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)} != ''`
                        }
                        return `toString(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) != '${escapeClickHouseString(normalizedValue)}'`
                    }
                }

                case 'icontains': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "icontains" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return `positionCaseInsensitive(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}, '${escapeClickHouseString(normalizedValue)}') > 0`
                }

                case 'not_icontains': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "not_icontains" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=1'
                    }
                    return `positionCaseInsensitive(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}, '${escapeClickHouseString(normalizedValue)}') = 0`
                }

                case 'regex': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "regex" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return `match(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}, '${escapeClickHouseString(normalizedValue)}')`
                }

                case 'not_regex': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "not_regex" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=1'
                    }
                    return `NOT match(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}, '${escapeClickHouseString(normalizedValue)}')`
                }

                case 'gt': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "gt" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return `toFloat64OrNull(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) > ${parseFloat(normalizedValue)}`
                }

                case 'lt': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "lt" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return `toFloat64OrNull(${argMaxProp(`JSONExtractString(properties, '${escapedKey}')`)}) < ${parseFloat(normalizedValue)}`
                }

                case 'is_set':
                    return `JSONHas(${argMaxProp('properties')}, '${escapedKey}')`

                case 'is_not_set':
                    return `NOT JSONHas(${argMaxProp('properties')}, '${escapedKey}')`

                case 'is_date_before': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "is_date_before" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return this.buildDateBeforeExprWithArgMax(escapedKey, normalizedValue)
                }

                case 'is_date_after': {
                    if (Array.isArray(value)) {
                        throw new Error('Operator "is_date_after" does not support list values')
                    }
                    const normalizedValue = normalizeValue(value)
                    if (normalizedValue === null) {
                        return '1=0'
                    }
                    return this.buildDateAfterExprWithArgMax(escapedKey, normalizedValue)
                }

                case 'is_cleaned_path_exact': {
                    throw new Error(
                        'Operator "is_cleaned_path_exact" is not supported for person properties; it is only valid for event/path properties'
                    )
                }
                default:
                    throw new Error(`Unsupported property filter operator: ${operator}`)
            }
        })

        return filters.join(' AND ')
    }

    /**
     * Convert ClickHouse person row to InternalPerson
     */
    private convertToInternalPerson(row: ClickHousePersonRow): InternalPerson {
        return {
            id: row.id,
            uuid: row.id,
            team_id: typeof row.team_id === 'string' ? parseInt(row.team_id) : row.team_id,
            properties: parseJSON(row.properties),
            properties_last_updated_at: {},
            properties_last_operation: {},
            is_user_id: null,
            is_identified: Boolean(row.is_identified),
            created_at: DateTime.fromSQL(row.created_at, { zone: 'UTC' }),
            version: typeof row.version === 'string' ? parseInt(row.version) : row.version || 0,
            last_seen_at: null,
        }
    }

    private async query<T>(query: string): Promise<T[]> {
        return await this.clickHouseRouter.query<T>(query)
    }

    private parseRelativeDate(value: string): string | null {
        const match = /^-?(?<number>[0-9]+)(?<interval>[a-z])$/.exec(value)
        if (!match?.groups?.number || !match?.groups?.interval) {
            return null
        }

        const number = parseInt(match.groups.number, 10)
        if (Number.isNaN(number) || number >= 10000) {
            return null
        }

        const interval = match.groups.interval
        const now = DateTime.utc()
        const relative =
            interval === 'h'
                ? now.minus({ hours: number })
                : interval === 'd'
                  ? now.minus({ days: number })
                  : interval === 'w'
                    ? now.minus({ weeks: number })
                    : interval === 'm'
                      ? now.minus({ months: number })
                      : interval === 'y'
                        ? now.minus({ years: number })
                        : null

        return relative ? relative.toFormat('yyyy-MM-dd HH:mm:ss') : null
    }

    private buildDatePropertyExprWithArgMax(escapedKey: string): string {
        const propertyExpr = `argMax(JSONExtractString(properties, '${escapedKey}'), version)`
        return `coalesce(parseDateTimeBestEffortOrNull(${propertyExpr}), parseDateTimeBestEffortOrNull(substring(${propertyExpr}, 1, 10)))`
    }

    private normalizeDateValue(value: string): string {
        return this.parseRelativeDate(value) ?? value
    }

    private buildDateBeforeExprWithArgMax(escapedKey: string, value: string): string {
        const parsedExpr = this.buildDatePropertyExprWithArgMax(escapedKey)
        const dateValue = escapeClickHouseString(this.normalizeDateValue(value))
        return `${parsedExpr} < parseDateTimeBestEffortOrNull('${dateValue}')`
    }

    private buildDateAfterExprWithArgMax(escapedKey: string, value: string): string {
        const parsedExpr = this.buildDatePropertyExprWithArgMax(escapedKey)
        const dateValue = this.normalizeDateValue(value)
        const escapedDateValue = escapeClickHouseString(dateValue)
        const isDateOnly = /^\d{4}-\d{2}-\d{2}$/.test(dateValue)
        const compareValue = isDateOnly
            ? `subtractSeconds(addDays(toDate('${escapedDateValue}'), 1), 1)`
            : `parseDateTimeBestEffortOrNull('${escapedDateValue}')`
        return `${parsedExpr} > ${compareValue}`
    }

    /**
     * --- NOT SUPPORTED OPERATIONS BELOW ---
     */

    fetchPerson(
        _teamId: Team['id'],
        _distinctId: string,
        _options?: { forUpdate?: boolean; useReadReplica?: boolean }
    ): Promise<InternalPerson | undefined> {
        return Promise.reject(new Error('fetchPerson operation not yet supported in ClickHousePersonRepository'))
    }

    fetchPersonsByDistinctIds(
        _teamPersons: { teamId: TeamId; distinctId: string }[],
        _useReadReplica?: boolean
    ): Promise<InternalPersonWithDistinctId[]> {
        return Promise.reject(
            new Error('fetchPersonsByDistinctIds operation not yet supported in ClickHousePersonRepository')
        )
    }

    createPerson(
        _createdAt: DateTime,
        _properties: Properties,
        _propertiesLastUpdatedAt: PropertiesLastUpdatedAt,
        _propertiesLastOperation: PropertiesLastOperation,
        _teamId: Team['id'],
        _isUserId: number | null,
        _isIdentified: boolean,
        _uuid: string,
        _primaryDistinctId: { distinctId: string; version?: number },
        _extraDistinctIds?: { distinctId: string; version?: number }[]
    ): Promise<CreatePersonResult> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    updatePerson(
        _person: InternalPerson,
        _update: PersonUpdateFields,
        _tag?: string
    ): Promise<[InternalPerson, TopicMessage[], boolean]> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    updatePersonAssertVersion(_personUpdate: PersonUpdate): Promise<[number | undefined, TopicMessage[]]> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    updatePersonsBatch(
        _personUpdates: PersonUpdate[]
    ): Promise<Map<string, { success: boolean; version?: number; kafkaMessage?: TopicMessage; error?: Error }>> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    deletePerson(_person: InternalPerson): Promise<TopicMessage[]> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    addDistinctId(_person: InternalPerson, _distinctId: string, _version: number): Promise<TopicMessage[]> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    addPersonlessDistinctId(_teamId: Team['id'], _distinctId: string): Promise<boolean> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    addPersonlessDistinctIdForMerge(_teamId: Team['id'], _distinctId: string): Promise<boolean> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    addPersonlessDistinctIdsBatch(_entries: { teamId: number; distinctId: string }[]): Promise<Map<string, boolean>> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    personPropertiesSize(_personId: string, _teamId: number): Promise<number> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    updateCohortsAndFeatureFlagsForMerge(
        _teamID: Team['id'],
        _sourcePersonID: InternalPerson['id'],
        _targetPersonID: InternalPerson['id']
    ): Promise<void> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }

    inTransaction<T>(_description: string, _transaction: (tx: PersonRepositoryTransaction) => Promise<T>): Promise<T> {
        return Promise.reject(new Error('Write operations not supported in ClickHousePersonRepository'))
    }
}

/**
 * ClickHouse person row with aggregated fields
 * Note: ClickHouse JSON format returns numeric columns as strings
 */
interface ClickHousePersonRow {
    id: string
    team_id: number | string
    is_identified: number
    properties: string
    created_at: string
    version: number | string
}

/**
 * ClickHouse person row joined with distinct_id
 */
interface ClickHousePersonWithDistinctId extends ClickHousePersonRow {
    distinct_id: string
}
