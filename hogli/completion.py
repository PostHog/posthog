"""Generate shell completion scripts for hogli."""

import click


def generate_bash_completion(cli_name: str = "hogli") -> str:
    """Generate bash completion script for hogli."""
    return f"""# bash completion for {cli_name}
# Generated by hogli completion system

_hogli_completion() {{
    local cur prev words cword
    COMPREPLY=()
    cur="${"{COMP_WORDS[COMP_CWORD]}"}"
    prev="${"{COMP_WORDS[COMP_CWORD-1]}"}"

    # Get all available commands from hogli --help
    local commands=$(python -m hogli --help 2>/dev/null | grep -E '^  [a-z]' | awk '{{print $1}}')

    if [[ ${{cur}} == -* ]] ; then
        COMPREPLY=($(compgen -W '--help' -- ${{cur}}))
        return 0
    fi

    COMPREPLY=($(compgen -W "${{commands}}" -- ${{cur}}))
    return 0
}}

complete -o bashdefault -o default -o nospace -F _hogli_completion {cli_name}
"""


def generate_zsh_completion(cli_name: str = "hogli") -> str:
    """Generate zsh completion script for hogli."""
    return f"""#compdef {cli_name}

# zsh completion for {cli_name}
# Generated by hogli completion system

_hogli() {{
  local -a commands

  commands=(
    'build:frontend:Build frontend packages and run TypeScript compilation'
    'build:grammar:Generate HogQL grammar definitions'
    'build:schema:Generate all schema definitions'
    'check:clickhouse:Poll ClickHouse HTTP port until service is ready'
    'check:dagster-graphql:Wait for Dagster UI to become available'
    'check:hosts:Verify DNS resolution for required service hostnames'
    'check:kafka-clickhouse:Wait for both Kafka and ClickHouse services to be ready'
    'check:postgres:Poll PostgreSQL connection until database is available'
    'check:temporal:Wait for Temporal service port with 180s timeout'
    'check:video-deps:Install and verify Playwright browsers and FFmpeg dependencies'
    'deploy:hobby:Interactive installer for single-instance PostHog deployment'
    'deploy:upgrade-hobby:Upgrade existing hobby deployment'
    'dev:demo-data:Generate demo data for local testing'
    'dev:reset:Full reset - stop services, migrate, load demo data, sync flags'
    'dev:setup:Initialize local development environment'
    'docker:services:down:Stop Docker infrastructure services'
    'docker:services:up:Start Docker infrastructure services'
    'format:Format both backend and frontend code'
    'format:css:Format CSS/SCSS files'
    'format:js:Format JavaScript/TypeScript files'
    'format:markdown:Format Markdown files'
    'format:python:Format Python files'
    'format:rust:Format Rust files'
    'format:yaml:Format JSON, YAML files'
    'lint:Run code quality checks'
    'lint:python:fix:Fix Python code quality issues'
    'meta:check:Validate manifest against bin scripts'
    'meta:concepts:Show services and infrastructure concepts'
    'migrations:run:Run all database migrations'
    'migrations:sync-flags:Sync feature flags from configuration'
    'start:Main entry point that launches all dev services'
    'start:backend:Run Django development server'
    'start:celery:Start Celery worker or beat scheduler'
    'start:frontend:Install dependencies and start frontend with Vite'
    'start:frontend-vite:Start Vite dev server for frontend'
    'start:rust-service:Build and run live Rust microservice'
    'start:worker:Launch all background workers'
    'test:js:Run JavaScript test suite'
    'test:python:Run Python test suite'
    'test:run:Interactive test runner with watch mode'
  )

  _describe 'hogli commands' commands
}}

_hogli
"""


def install_completion(shell: str = "bash") -> None:
    """Install shell completion for the specified shell."""
    if shell == "bash":
        completion_script = generate_bash_completion()
        # Bash completions typically go in /etc/bash_completion.d/ or ~/.bash_completion
        # For flox, we'll output to a location that can be sourced
        click.echo(completion_script)
    elif shell == "zsh":
        completion_script = generate_zsh_completion()
        # Zsh completions go in fpath directories
        click.echo(completion_script)
    else:
        raise ValueError(f"Unsupported shell: {shell}")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Generate shell completion for hogli")
    parser.add_argument("--shell", choices=["bash", "zsh"], default="bash", help="Shell to generate completion for")
    args = parser.parse_args()

    install_completion(args.shell)
