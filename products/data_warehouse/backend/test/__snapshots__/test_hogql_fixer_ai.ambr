# serializer version: 1
# name: test_get_schema_description
  '''
  This is the schema of tables currently used in the provided query:
  
  Table `events` with fields:
  - uuid (string)
  - event (string)
  - properties (json)
  - timestamp (datetime)
  - distinct_id (string)
  - elements_chain (string)
  - created_at (datetime)
  - $session_id (string)
  - $window_id (string)
  - pdi (lazy_table)
  - poe (virtual_table)
  - goe_0 (virtual_table)
  - goe_1 (virtual_table)
  - goe_2 (virtual_table)
  - goe_3 (virtual_table)
  - goe_4 (virtual_table)
  - person (lazy_table)
  - person_id (expression)
  - $group_0 (string)
  - group_0 (lazy_table)
  - $group_1 (string)
  - group_1 (lazy_table)
  - $group_2 (string)
  - group_2 (lazy_table)
  - $group_3 (string)
  - group_3 (lazy_table)
  - $group_4 (string)
  - group_4 (lazy_table)
  - session (lazy_table)
  - elements_chain_href (string)
  - elements_chain_texts (array)
  - elements_chain_ids (array)
  - elements_chain_elements (array)
  - event_person_id (string)
  - override (lazy_table)
  - event_issue_id (expression)
  - exception_issue_override (lazy_table)
  - issue_id (expression)
  '''
# ---
# name: test_get_system_prompt
  '''
  HogQL is PostHog's variant of SQL. HogQL is a transpiler that outputs Clickhouse SQL. We use Antlr4 to define the HogQL language.
  Below is the antlr parser and lexer definitions - when writing HogQL, ensure you follow the grammar rules.
  
  <hogql_parser>
  parser grammar HogQLParser;
  
  options {
      tokenVocab = HogQLLexer;
  }
  
  
  program: declaration* EOF;
  
  declaration: varDecl | statement ;
  
  expression: columnExpr;
  
  varDecl: LET identifier ( COLON EQ_SINGLE expression )? ;
  identifierList: identifier (COMMA identifier)* COMMA?;
  
  statement      : returnStmt
                 | throwStmt
                 | tryCatchStmt
                 | ifStmt
                 | whileStmt
                 | forInStmt
                 | forStmt
                 | funcStmt
                 | varAssignment
                 | block
                 | exprStmt
                 | emptyStmt
                 ;
  
  returnStmt     : RETURN expression? SEMICOLON?;
  throwStmt      : THROW expression? SEMICOLON?;
  catchBlock     : CATCH (LPAREN catchVar=identifier (COLON catchType=identifier)? RPAREN)? catchStmt=block;
  tryCatchStmt   : TRY tryStmt=block catchBlock* (FINALLY finallyStmt=block)?;
  ifStmt         : IF LPAREN expression RPAREN statement ( ELSE statement )? ;
  whileStmt      : WHILE LPAREN expression RPAREN statement SEMICOLON?;
  forStmt        : FOR LPAREN
                   (initializerVarDeclr=varDecl | initializerVarAssignment=varAssignment | initializerExpression=expression)? SEMICOLON
                   condition=expression? SEMICOLON
                   (incrementVarDeclr=varDecl | incrementVarAssignment=varAssignment | incrementExpression=expression)?
                   RPAREN statement SEMICOLON?;
  forInStmt      : FOR LPAREN LET identifier (COMMA identifier)? IN expression RPAREN statement SEMICOLON?;
  funcStmt       : (FN | FUN) identifier LPAREN identifierList? RPAREN block;
  varAssignment  : expression COLON EQ_SINGLE expression ;
  exprStmt       : expression SEMICOLON?;
  emptyStmt      : SEMICOLON ;
  block          : LBRACE declaration* RBRACE ;
  
  kvPair: expression ':' expression ;
  kvPairList: kvPair (COMMA kvPair)* COMMA?;
  
  
  // SELECT statement
  select: (selectSetStmt | selectStmt | hogqlxTagElement) EOF;
  
  selectStmtWithParens: selectStmt | LPAREN selectSetStmt RPAREN | placeholder;
  
  subsequentSelectSetClause: (EXCEPT | UNION ALL | UNION DISTINCT | INTERSECT | INTERSECT DISTINCT) selectStmtWithParens;
  selectSetStmt: selectStmtWithParens (subsequentSelectSetClause)*;
  
  selectStmt:
      with=withClause?
      SELECT DISTINCT? topClause?
      columns=columnExprList
      from=fromClause?
      arrayJoinClause?
      prewhereClause?
      where=whereClause?
      groupByClause? (WITH (CUBE | ROLLUP))? (WITH TOTALS)?
      havingClause?
      windowClause?
      orderByClause?
      limitByClause?
      (limitAndOffsetClause | offsetOnlyClause)?
      settingsClause?
      ;
  
  withClause: WITH withExprList;
  topClause: TOP DECIMAL_LITERAL (WITH TIES)?;
  fromClause: FROM joinExpr;
  arrayJoinClause: (LEFT | INNER)? ARRAY JOIN columnExprList;
  windowClause: WINDOW identifier AS LPAREN windowExpr RPAREN (COMMA identifier AS LPAREN windowExpr RPAREN)*;
  prewhereClause: PREWHERE columnExpr;
  whereClause: WHERE columnExpr;
  groupByClause: GROUP BY ((CUBE | ROLLUP) LPAREN columnExprList RPAREN | columnExprList);
  havingClause: HAVING columnExpr;
  orderByClause: ORDER BY orderExprList;
  projectionOrderByClause: ORDER BY columnExprList;
  limitByClause: LIMIT limitExpr BY columnExprList;
  limitAndOffsetClause
      : LIMIT columnExpr (COMMA columnExpr)? (WITH TIES)? // compact OFFSET-optional form
      | LIMIT columnExpr (WITH TIES)? OFFSET columnExpr // verbose OFFSET-included form with WITH TIES
      ;
  offsetOnlyClause: OFFSET columnExpr;
  settingsClause: SETTINGS settingExprList;
  
  joinExpr
      : joinExpr joinOp? JOIN joinExpr joinConstraintClause  # JoinExprOp
      | joinExpr joinOpCross joinExpr                                          # JoinExprCrossOp
      | tableExpr FINAL? sampleClause?                                         # JoinExprTable
      | LPAREN joinExpr RPAREN                                                 # JoinExprParens
      ;
  joinOp
      : ((ALL | ANY | ASOF)? INNER | INNER (ALL | ANY | ASOF)? | (ALL | ANY | ASOF))  # JoinOpInner
      | ( (SEMI | ALL | ANTI | ANY | ASOF)? (LEFT | RIGHT) OUTER?
        | (LEFT | RIGHT) OUTER? (SEMI | ALL | ANTI | ANY | ASOF)?
        )                                                                             # JoinOpLeftRight
      | ((ALL | ANY)? FULL OUTER? | FULL OUTER? (ALL | ANY)?)                         # JoinOpFull
      ;
  joinOpCross
      : CROSS JOIN
      | COMMA
      ;
  joinConstraintClause
      : ON columnExprList
      | USING LPAREN columnExprList RPAREN
      | USING columnExprList
      ;
  
  sampleClause: SAMPLE ratioExpr (OFFSET ratioExpr)?;
  limitExpr: columnExpr ((COMMA | OFFSET) columnExpr)?;
  orderExprList: orderExpr (COMMA orderExpr)*;
  orderExpr: columnExpr (ASCENDING | DESCENDING | DESC)? (NULLS (FIRST | LAST))? (COLLATE STRING_LITERAL)?;
  ratioExpr: placeholder | numberLiteral (SLASH numberLiteral)?;
  settingExprList: settingExpr (COMMA settingExpr)*;
  settingExpr: identifier EQ_SINGLE literal;
  
  windowExpr: winPartitionByClause? winOrderByClause? winFrameClause?;
  winPartitionByClause: PARTITION BY columnExprList;
  winOrderByClause: ORDER BY orderExprList;
  winFrameClause: (ROWS | RANGE) winFrameExtend;
  winFrameExtend
      : winFrameBound                             # frameStart
      | BETWEEN winFrameBound AND winFrameBound   # frameBetween
      ;
  winFrameBound: (CURRENT ROW | UNBOUNDED PRECEDING | UNBOUNDED FOLLOWING | numberLiteral PRECEDING | numberLiteral FOLLOWING);
  //rangeClause: RANGE LPAREN (MIN identifier MAX identifier | MAX identifier MIN identifier) RPAREN;
  
  // Columns
  expr: columnExpr EOF;
  columnTypeExpr
      : identifier                                                                             # ColumnTypeExprSimple   // UInt64
      | identifier LPAREN identifier columnTypeExpr (COMMA identifier columnTypeExpr)* COMMA? RPAREN  # ColumnTypeExprNested   // Nested
      | identifier LPAREN enumValue (COMMA enumValue)* COMMA? RPAREN                                  # ColumnTypeExprEnum     // Enum
      | identifier LPAREN columnTypeExpr (COMMA columnTypeExpr)* COMMA? RPAREN                        # ColumnTypeExprComplex  // Array, Tuple
      | identifier LPAREN columnExprList? RPAREN                                               # ColumnTypeExprParam    // FixedString(N)
      ;
  columnExprList: columnExpr (COMMA columnExpr)* COMMA?;
  columnExpr
      : CASE caseExpr=columnExpr? (WHEN whenExpr=columnExpr THEN thenExpr=columnExpr)+ (ELSE elseExpr=columnExpr)? END          # ColumnExprCase
      | CAST LPAREN columnExpr AS columnTypeExpr RPAREN                                     # ColumnExprCast
      | DATE STRING_LITERAL                                                                 # ColumnExprDate
  //    | EXTRACT LPAREN interval FROM columnExpr RPAREN                                      # ColumnExprExtract   // Interferes with a function call
      | INTERVAL STRING_LITERAL                                                             # ColumnExprIntervalString
      | INTERVAL columnExpr interval                                                        # ColumnExprInterval
      | SUBSTRING LPAREN columnExpr FROM columnExpr (FOR columnExpr)? RPAREN                # ColumnExprSubstring
      | TIMESTAMP STRING_LITERAL                                                            # ColumnExprTimestamp
      | TRIM LPAREN (BOTH | LEADING | TRAILING) string FROM columnExpr RPAREN               # ColumnExprTrim
      | identifier (LPAREN columnExprs=columnExprList? RPAREN) (LPAREN DISTINCT? columnArgList=columnExprList? RPAREN)? OVER LPAREN windowExpr RPAREN # ColumnExprWinFunction
      | identifier (LPAREN columnExprs=columnExprList? RPAREN) (LPAREN DISTINCT? columnArgList=columnExprList? RPAREN)? OVER identifier               # ColumnExprWinFunctionTarget
      | identifier (LPAREN columnExprs=columnExprList? RPAREN)? LPAREN DISTINCT? columnArgList=columnExprList? RPAREN                                 # ColumnExprFunction
      | columnExpr LPAREN selectSetStmt RPAREN                                              # ColumnExprCallSelect
      | columnExpr LPAREN columnExprList? RPAREN                                            # ColumnExprCall
      | hogqlxTagElement                                                                    # ColumnExprTagElement
      | templateString                                                                      # ColumnExprTemplateString
      | literal                                                                             # ColumnExprLiteral
  
      // FIXME(ilezhankin): this part looks very ugly, maybe there is another way to express it
      | columnExpr LBRACKET columnExpr RBRACKET                                             # ColumnExprArrayAccess
      | columnExpr DOT DECIMAL_LITERAL                                                      # ColumnExprTupleAccess
      | columnExpr DOT identifier                                                           # ColumnExprPropertyAccess
      | columnExpr NULL_PROPERTY LBRACKET columnExpr RBRACKET                               # ColumnExprNullArrayAccess
      | columnExpr NULL_PROPERTY DECIMAL_LITERAL                                            # ColumnExprNullTupleAccess
      | columnExpr NULL_PROPERTY identifier                                                 # ColumnExprNullPropertyAccess
      | DASH columnExpr                                                                     # ColumnExprNegate
      | left=columnExpr ( operator=ASTERISK                                                 // *
                   | operator=SLASH                                                         // /
                   | operator=PERCENT                                                       // %
                   ) right=columnExpr                                                       # ColumnExprPrecedence1
      | left=columnExpr ( operator=PLUS                                                     // +
                   | operator=DASH                                                          // -
                   | operator=CONCAT                                                        // ||
                   ) right=columnExpr                                                       # ColumnExprPrecedence2
      | left=columnExpr ( operator=EQ_DOUBLE                                                // =
                   | operator=EQ_SINGLE                                                     // ==
                   | operator=NOT_EQ                                                        // !=
                   | operator=LT_EQ                                                         // <=
                   | operator=LT                                                            // <
                   | operator=GT_EQ                                                         // >=
                   | operator=GT                                                            // >
                   | operator=NOT? IN COHORT?                                               // in, not in; in cohort; not in cohort
                   | operator=NOT? (LIKE | ILIKE)                                           // like, not like, ilike, not ilike
                   | operator=REGEX_SINGLE                                                  // ~
                   | operator=REGEX_DOUBLE                                                  // =~
                   | operator=NOT_REGEX                                                     // !~
                   | operator=IREGEX_SINGLE                                                 // ~*
                   | operator=IREGEX_DOUBLE                                                 // =~*
                   | operator=NOT_IREGEX                                                    // !~*
                   ) right=columnExpr                                                       # ColumnExprPrecedence3
      | columnExpr IS NOT? NULL_SQL                                                         # ColumnExprIsNull
      | columnExpr NULLISH columnExpr                                                       # ColumnExprNullish
      | NOT columnExpr                                                                      # ColumnExprNot
      | columnExpr AND columnExpr                                                           # ColumnExprAnd
      | columnExpr OR columnExpr                                                            # ColumnExprOr
      // TODO(ilezhankin): `BETWEEN a AND b AND c` is parsed in a wrong way: `BETWEEN (a AND b) AND c`
      | columnExpr NOT? BETWEEN columnExpr AND columnExpr                                   # ColumnExprBetween
      | <assoc=right> columnExpr QUERY columnExpr COLON columnExpr                          # ColumnExprTernaryOp
      | columnExpr (AS identifier | AS STRING_LITERAL)                                      # ColumnExprAlias
      | (tableIdentifier DOT)? ASTERISK                                                     # ColumnExprAsterisk  // single-column only
      | LPAREN selectSetStmt RPAREN                                                         # ColumnExprSubquery  // single-column only
      | LPAREN columnExpr RPAREN                                                            # ColumnExprParens    // single-column only
      | LPAREN columnExprList RPAREN                                                        # ColumnExprTuple
      | LBRACKET columnExprList? RBRACKET                                                   # ColumnExprArray
      | LBRACE (kvPairList)? RBRACE                                                         # ColumnExprDict
      | columnLambdaExpr                                                                    # ColumnExprLambda
      | columnIdentifier                                                                    # ColumnExprIdentifier
      ;
  
  columnLambdaExpr:
      ( LPAREN identifier (COMMA identifier)* COMMA? RPAREN
      |        identifier (COMMA identifier)* COMMA?
      | LPAREN RPAREN
      )
      ARROW (columnExpr | block)
      ;
  
  
  hogqlxChildElement: hogqlxTagElement | (LBRACE columnExpr RBRACE);
  hogqlxTagElement
      : LT identifier hogqlxTagAttribute* SLASH GT                                          # HogqlxTagElementClosed
      | LT identifier hogqlxTagAttribute* GT hogqlxChildElement* LT SLASH identifier GT     # HogqlxTagElementNested
      ;
  hogqlxTagAttribute
      :   identifier '=' string
      |   identifier '=' LBRACE columnExpr RBRACE
      |   identifier
      ;
  
  withExprList: withExpr (COMMA withExpr)* COMMA?;
  withExpr
      : identifier AS LPAREN selectSetStmt RPAREN    # WithExprSubquery
      // NOTE: asterisk and subquery goes before |columnExpr| so that we can mark them as multi-column expressions.
      | columnExpr AS identifier                       # WithExprColumn
      ;
  
  
  // This is slightly different in HogQL compared to ClickHouse SQL
  // HogQL allows unlimited ("*") nestedIdentifier-s "properties.b.a.a.w.a.s".
  // We parse and convert "databaseIdentifier.tableIdentifier.columnIdentifier.nestedIdentifier.*"
  // to just one ast.Field(chain=['a','b','columnIdentifier','on','and','on']).
  columnIdentifier: placeholder | ((tableIdentifier DOT)? nestedIdentifier);
  nestedIdentifier: identifier (DOT identifier)*;
  tableExpr
      : tableIdentifier                    # TableExprIdentifier
      | tableFunctionExpr                  # TableExprFunction
      | LPAREN selectSetStmt RPAREN      # TableExprSubquery
      | tableExpr (alias | AS identifier)  # TableExprAlias
      | hogqlxTagElement                   # TableExprTag
      | placeholder                        # TableExprPlaceholder
      ;
  tableFunctionExpr: identifier LPAREN tableArgList? RPAREN;
  tableIdentifier: (databaseIdentifier DOT)? nestedIdentifier;
  tableArgList: columnExpr (COMMA columnExpr)* COMMA?;
  
  // Databases
  
  databaseIdentifier: identifier;
  
  // Basics
  
  floatingLiteral
      : FLOATING_LITERAL
      | DOT (DECIMAL_LITERAL | OCTAL_LITERAL)
      | DECIMAL_LITERAL DOT (DECIMAL_LITERAL | OCTAL_LITERAL)?  // can't move this to the lexer or it will break nested tuple access: t.1.2
      ;
  numberLiteral: (PLUS | DASH)? (floatingLiteral | OCTAL_LITERAL | DECIMAL_LITERAL | HEXADECIMAL_LITERAL | INF | NAN_SQL);
  literal
      : numberLiteral
      | STRING_LITERAL
      | NULL_SQL
      ;
  interval: SECOND | MINUTE | HOUR | DAY | WEEK | MONTH | QUARTER | YEAR;
  keyword
      // except NULL_SQL, INF, NAN_SQL
      : ALL | AND | ANTI | ANY | ARRAY | AS | ASCENDING | ASOF | BETWEEN | BOTH | BY | CASE
      | CAST | COHORT | COLLATE | CROSS | CUBE | CURRENT | DATE | DESC | DESCENDING
      | DISTINCT | ELSE | END | EXTRACT | FINAL | FIRST
      | FOR | FOLLOWING | FROM | FULL | GROUP | HAVING | ID | IS
      | IF | ILIKE | IN | INNER | INTERVAL | JOIN | KEY
      | LAST | LEADING | LEFT | LIKE | LIMIT
      | NOT | NULLS | OFFSET | ON | OR | ORDER | OUTER | OVER | PARTITION
      | PRECEDING | PREWHERE | RANGE | RETURN | RIGHT | ROLLUP | ROW
      | ROWS | SAMPLE | SELECT | SEMI | SETTINGS | SUBSTRING
      | THEN | TIES | TIMESTAMP | TOTALS | TRAILING | TRIM | TRUNCATE | TO | TOP
      | UNBOUNDED | UNION | USING | WHEN | WHERE | WINDOW | WITH
      ;
  keywordForAlias
      : DATE | FIRST | ID | KEY
      ;
  alias: IDENTIFIER | keywordForAlias;  // |interval| can't be an alias, otherwise 'INTERVAL 1 SOMETHING' becomes ambiguous.
  identifier: IDENTIFIER | interval | keyword;
  enumValue: string EQ_SINGLE numberLiteral;
  placeholder: LBRACE columnExpr RBRACE;
  
  string: STRING_LITERAL | templateString;
  templateString : QUOTE_SINGLE_TEMPLATE stringContents* QUOTE_SINGLE ;
  stringContents : STRING_ESCAPE_TRIGGER columnExpr RBRACE | STRING_TEXT;
  
  // These are magic "full template strings", which are used to parse "full text field" templates without the surrounding SQL.
  // We will need to add F' to the start of the string to change the lexer's mode.
  fullTemplateString: QUOTE_SINGLE_TEMPLATE_FULL stringContentsFull* EOF ;
  stringContentsFull : FULL_STRING_ESCAPE_TRIGGER columnExpr RBRACE | FULL_STRING_TEXT;
  
  </hogql_parser>
  
  <hogql_lexer>
  lexer grammar HogQLLexer;
  
  // NOTE: don't forget to add new keywords to the parser rule "keyword"!
  
  // Keywords
  
  ALL: A L L;
  AND: A N D;
  ANTI: A N T I;
  ANY: A N Y;
  ARRAY: A R R A Y;
  AS: A S;
  ASCENDING: A S C | A S C E N D I N G;
  ASOF: A S O F;
  BETWEEN: B E T W E E N;
  BOTH: B O T H;
  BY: B Y;
  CASE: C A S E;
  CAST: C A S T;
  CATCH: C A T C H;
  COHORT: C O H O R T;
  COLLATE: C O L L A T E;
  CROSS: C R O S S;
  CUBE: C U B E;
  CURRENT: C U R R E N T;
  DATE: D A T E;
  DAY: D A Y;
  DESC: D E S C;
  DESCENDING: D E S C E N D I N G;
  DISTINCT: D I S T I N C T;
  ELSE: E L S E;
  END: E N D;
  EXCEPT: E X C E P T;
  EXTRACT: E X T R A C T;
  FINAL: F I N A L;
  FINALLY: F I N A L L Y;
  FIRST: F I R S T;
  FN: F N;
  FOLLOWING: F O L L O W I N G;
  FOR: F O R;
  FROM: F R O M;
  FULL: F U L L;
  FUN: F U N;
  GROUP: G R O U P;
  HAVING: H A V I N G;
  HOUR: H O U R;
  ID: I D;
  IF: I F;
  ILIKE: I L I K E;
  IN: I N;
  INF: I N F | I N F I N I T Y;
  INNER: I N N E R;
  INTERSECT: I N T E R S E C T;
  INTERVAL: I N T E R V A L;
  IS: I S;
  JOIN: J O I N;
  KEY: K E Y;
  LAST: L A S T;
  LEADING: L E A D I N G;
  LEFT: L E F T;
  LET: L E T;
  LIKE: L I K E;
  LIMIT: L I M I T;
  MINUTE: M I N U T E;
  MONTH: M O N T H;
  NAN_SQL: N A N; // conflicts with macro NAN
  NOT: N O T;
  NULL_SQL: N U L L; // conflicts with macro NULL
  NULLS: N U L L S;
  OFFSET: O F F S E T;
  ON: O N;
  OR: O R;
  ORDER: O R D E R;
  OUTER: O U T E R;
  OVER: O V E R;
  PARTITION: P A R T I T I O N;
  PRECEDING: P R E C E D I N G;
  PREWHERE: P R E W H E R E;
  QUARTER: Q U A R T E R;
  RANGE: R A N G E;
  RETURN: R E T U R N;
  RIGHT: R I G H T;
  ROLLUP: R O L L U P;
  ROW: R O W;
  ROWS: R O W S;
  SAMPLE: S A M P L E;
  SECOND: S E C O N D;
  SELECT: S E L E C T;
  SEMI: S E M I;
  SETTINGS: S E T T I N G S;
  SUBSTRING: S U B S T R I N G;
  THEN: T H E N;
  THROW: T H R O W;
  TIES: T I E S;
  TIMESTAMP: T I M E S T A M P;
  TO: T O;
  TOP: T O P;
  TOTALS: T O T A L S;
  TRAILING: T R A I L I N G;
  TRIM: T R I M;
  TRUNCATE: T R U N C A T E;
  TRY: T R Y;
  UNBOUNDED: U N B O U N D E D;
  UNION: U N I O N;
  USING: U S I N G;
  WEEK: W E E K;
  WHEN: W H E N;
  WHERE: W H E R E;
  WHILE: W H I L E;
  WINDOW: W I N D O W;
  WITH: W I T H;
  YEAR: Y E A R | Y Y Y Y;
  
  // Tokens
  
  // copied from clickhouse_driver/util/escape.py
  ESCAPE_CHAR_COMMON
      : BACKSLASH B
      | BACKSLASH F
      | BACKSLASH R
      | BACKSLASH N
      | BACKSLASH T
      | BACKSLASH '0'
      | BACKSLASH A
      | BACKSLASH V
      | BACKSLASH BACKSLASH;
  
  IDENTIFIER
      : (LETTER | UNDERSCORE | DOLLAR) (LETTER | UNDERSCORE | DEC_DIGIT | DOLLAR)*
      | BACKQUOTE ( ~([\\`]) | ESCAPE_CHAR_COMMON | BACKSLASH QUOTE_SINGLE | (BACKQUOTE BACKQUOTE) )* BACKQUOTE
      | QUOTE_DOUBLE ( ~([\\"]) | ESCAPE_CHAR_COMMON | BACKSLASH QUOTE_DOUBLE | (QUOTE_DOUBLE QUOTE_DOUBLE) )* QUOTE_DOUBLE
      ;
  FLOATING_LITERAL
      : HEXADECIMAL_LITERAL DOT HEX_DIGIT* (P | E) (PLUS | DASH)? DEC_DIGIT+
      | HEXADECIMAL_LITERAL (P | E) (PLUS | DASH)? DEC_DIGIT+
      | DECIMAL_LITERAL DOT DEC_DIGIT* E (PLUS | DASH)? DEC_DIGIT+
      | DOT DECIMAL_LITERAL E (PLUS | DASH)? DEC_DIGIT+
      | DECIMAL_LITERAL E (PLUS | DASH)? DEC_DIGIT+
      ;
  OCTAL_LITERAL: '0' OCT_DIGIT+;
  DECIMAL_LITERAL: DEC_DIGIT+;
  HEXADECIMAL_LITERAL: '0' X HEX_DIGIT+;
  
  // It's important that quote-symbol is a single character.
  STRING_LITERAL: QUOTE_SINGLE ( ~([\\']) | ESCAPE_CHAR_COMMON | BACKSLASH QUOTE_SINGLE | (QUOTE_SINGLE QUOTE_SINGLE) )* QUOTE_SINGLE;
  
  
  // Alphabet and allowed symbols
  
  fragment A: [aA];
  fragment B: [bB];
  fragment C: [cC];
  fragment D: [dD];
  fragment E: [eE];
  fragment F: [fF];
  fragment G: [gG];
  fragment H: [hH];
  fragment I: [iI];
  fragment J: [jJ];
  fragment K: [kK];
  fragment L: [lL];
  fragment M: [mM];
  fragment N: [nN];
  fragment O: [oO];
  fragment P: [pP];
  fragment Q: [qQ];
  fragment R: [rR];
  fragment S: [sS];
  fragment T: [tT];
  fragment U: [uU];
  fragment V: [vV];
  fragment W: [wW];
  fragment X: [xX];
  fragment Y: [yY];
  fragment Z: [zZ];
  
  fragment LETTER: [a-zA-Z];
  fragment OCT_DIGIT: [0-7];
  fragment DEC_DIGIT: [0-9];
  fragment HEX_DIGIT: [0-9a-fA-F];
  
  ARROW: '->';
  ASTERISK: '*';
  BACKQUOTE: '`';
  BACKSLASH: '\\';
  COLON: ':';
  COMMA: ',';
  CONCAT: '||';
  DASH: '-';
  DOLLAR: '$';
  DOT: '.';
  EQ_DOUBLE: '==';
  EQ_SINGLE: '=';
  GT_EQ: '>=';
  GT: '>';
  HASH: '#';
  IREGEX_SINGLE: '~*';
  IREGEX_DOUBLE: '=~*';
  LBRACE: '{' -> pushMode(DEFAULT_MODE);
  LBRACKET: '[';
  LPAREN: '(';
  LT_EQ: '<=';
  LT: '<';
  NOT_EQ: '!=' | '<>';
  NOT_IREGEX: '!~*';
  NOT_REGEX: '!~';
  NULL_PROPERTY: '?.';
  NULLISH: '??';
  PERCENT: '%';
  PLUS: '+';
  QUERY: '?';
  QUOTE_DOUBLE: '"';
  QUOTE_SINGLE_TEMPLATE: 'f\'' -> pushMode(IN_TEMPLATE_STRING); // start of regular f'' template strings
  QUOTE_SINGLE_TEMPLATE_FULL: 'F\'' -> pushMode(IN_FULL_TEMPLATE_STRING); // magic F' symbol used to parse "full text" templates
  QUOTE_SINGLE: '\'';
  REGEX_SINGLE: '~';
  REGEX_DOUBLE: '=~';
  RBRACE: '}' -> popMode;
  RBRACKET: ']';
  RPAREN: ')';
  SEMICOLON: ';';
  SLASH: '/';
  UNDERSCORE: '_';
  
  // Comments and whitespace
  
  MULTI_LINE_COMMENT: '/*' .*? '*/' -> skip;
  SINGLE_LINE_COMMENT: ('--' | '//') ~('\n'|'\r')* ('\n' | '\r' | EOF) -> skip;
  // whitespace is hidden and not skipped so that it's preserved in ANTLR errors like "no viable alternative"
  WHITESPACE: [ \u000B\u000C\t\r\n] -> channel(HIDDEN);
  
  // regular f' template strings
  mode IN_TEMPLATE_STRING;
  STRING_TEXT: ((~([\\'{])) | ESCAPE_CHAR_COMMON | BACKSLASH QUOTE_SINGLE | (BACKSLASH LBRACE) | (QUOTE_SINGLE QUOTE_SINGLE))+;
  STRING_ESCAPE_TRIGGER: LBRACE -> pushMode(DEFAULT_MODE);
  STRING_QUOTE_SINGLE: QUOTE_SINGLE -> type(QUOTE_SINGLE), popMode;
  
  // a magic F' takes us to "full template strings" mode, where we don't need to escape single quotes and parse until EOF
  // this can't be used within a normal columnExpr, but has to be parsed for separately
  mode IN_FULL_TEMPLATE_STRING;
  FULL_STRING_TEXT: ((~([{])) | ESCAPE_CHAR_COMMON | (BACKSLASH LBRACE))+;
  FULL_STRING_ESCAPE_TRIGGER: LBRACE -> pushMode(DEFAULT_MODE);
  
  </hogql_lexer>
  
  HogQL defines what functions are available with most (but not all) having a 1:1 mapping to ClickHouse functions.
  These are the non-aggregated HogQL functions and their ClickHouse function name mapping:
  ```
  {'plus': 'plus', 'minus': 'minus', 'multiply': 'multiply', 'divide': 'divide', 'intDiv': 'intDiv', 'intDivOrZero': 'intDivOrZero', 'modulo': 'modulo', 'moduloOrZero': 'moduloOrZero', 'positiveModulo': 'positiveModulo', 'negate': 'negate', 'abs': 'abs', 'gcd': 'gcd', 'lcm': 'lcm', 'max2': 'max2', 'min2': 'min2', 'multiplyDecimal': 'multiplyDecimal', 'divideDecimal': 'divideDecimal', 'empty': 'empty', 'notEmpty': 'notEmpty', 'length': 'length', 'reverse': 'reverse', 'array': 'array', 'range': 'range', 'arrayConcat': 'arrayConcat', 'arrayElement': 'arrayElement', 'has': 'has', 'hasAll': 'hasAll', 'hasAny': 'hasAny', 'hasSubstr': 'hasSubstr', 'indexOf': 'indexOf', 'arrayCount': 'arrayCount', 'countEqual': 'countEqual', 'arrayEnumerate': 'arrayEnumerate', 'arrayEnumerateUniq': 'arrayEnumerateUniq', 'arrayPopBack': 'arrayPopBack', 'arrayPopFront': 'arrayPopFront', 'arrayPushBack': 'arrayPushBack', 'arrayPushFront': 'arrayPushFront', 'arrayResize': 'arrayResize', 'arraySlice': 'arraySlice', 'arraySort': 'arraySort', 'arrayReverseSort': 'arraySort', 'arrayUniq': 'arrayUniq', 'arrayJoin': 'arrayJoin', 'arrayDifference': 'arrayDifference', 'arrayDistinct': 'arrayDistinct', 'arrayEnumerateDense': 'arrayEnumerateDense', 'arrayIntersect': 'arrayIntersect', 'arrayReverse': 'arrayReverse', 'arrayFilter': 'arrayFilter', 'arrayFlatten': 'arrayFlatten', 'arrayCompact': 'arrayCompact', 'arrayZip': 'arrayZip', 'arrayAUC': 'arrayAUC', 'arrayMap': 'arrayMap', 'arrayFill': 'arrayFill', 'arrayFold': 'arrayFold', 'arrayWithConstant': 'arrayWithConstant', 'arraySplit': 'arraySplit', 'arrayReverseFill': 'arrayReverseFill', 'arrayReverseSplit': 'arrayReverseSplit', 'arrayRotateLeft': 'arrayRotateLeft', 'arrayRotateRight': 'arrayRotateRight', 'arrayExists': 'arrayExists', 'arrayAll': 'arrayAll', 'arrayFirst': 'arrayFirst', 'arrayLast': 'arrayLast', 'arrayFirstIndex': 'arrayFirstIndex', 'arrayLastIndex': 'arrayLastIndex', 'arrayMin': 'arrayMin', 'arrayMax': 'arrayMax', 'arraySum': 'arraySum', 'arrayAvg': 'arrayAvg', 'arrayCumSum': 'arrayCumSum', 'arrayCumSumNonNegative': 'arrayCumSumNonNegative', 'arrayProduct': 'arrayProduct', 'equals': 'equals', 'notEquals': 'notEquals', 'less': 'less', 'greater': 'greater', 'lessOrEquals': 'lessOrEquals', 'greaterOrEquals': 'greaterOrEquals', 'and': 'and', 'or': 'or', 'xor': 'xor', 'not': 'not', 'hex': 'hex', 'unhex': 'unhex', 'reinterpretAsUInt8': 'reinterpretAsUInt8', 'reinterpretAsUInt16': 'reinterpretAsUInt16', 'reinterpretAsUInt32': 'reinterpretAsUInt32', 'reinterpretAsUInt64': 'reinterpretAsUInt64', 'reinterpretAsUInt128': 'reinterpretAsUInt128', 'reinterpretAsUInt256': 'reinterpretAsUInt256', 'reinterpretAsInt8': 'reinterpretAsInt8', 'reinterpretAsInt16': 'reinterpretAsInt16', 'reinterpretAsInt32': 'reinterpretAsInt32', 'reinterpretAsInt64': 'reinterpretAsInt64', 'reinterpretAsInt128': 'reinterpretAsInt128', 'reinterpretAsInt256': 'reinterpretAsInt256', 'reinterpretAsFloat32': 'reinterpretAsFloat32', 'reinterpretAsFloat64': 'reinterpretAsFloat64', 'reinterpretAsUUID': 'reinterpretAsUUID', 'toInt': 'accurateCastOrNull', '_toInt64': 'toInt64', '_toUInt64': 'toUInt64', '_toUInt128': 'toUInt128', 'toFloat': 'accurateCastOrNull', 'toDecimal': 'accurateCastOrNull', '_toDate': 'toDate', 'toDate': 'toDateOrNull', 'to_date': 'toDateOrNull', 'toDateTime': 'parseDateTime64BestEffortOrNull', 'toUUID': 'accurateCastOrNull', 'toString': 'toString', 'toBool': 'toBool', 'toJSONString': 'toJSONString', 'parseDateTime': 'parseDateTimeOrNull', 'parseDateTimeBestEffort': 'parseDateTime64BestEffortOrNull', 'toTypeName': 'toTypeName', 'cityHash64': 'cityHash64', 'timeZoneOf': 'timeZoneOf', 'timeZoneOffset': 'timeZoneOffset', 'toYear': 'toYear', 'toQuarter': 'toQuarter', 'toMonth': 'toMonth', 'toDayOfYear': 'toDayOfYear', 'toDayOfMonth': 'toDayOfMonth', 'toDayOfWeek': 'toDayOfWeek', 'toHour': 'toHour', 'toMinute': 'toMinute', 'toSecond': 'toSecond', 'toUnixTimestamp': 'toUnixTimestamp', 'toUnixTimestamp64Milli': 'toUnixTimestamp64Milli', 'toStartOfInterval': 'toStartOfInterval', 'toStartOfYear': 'toStartOfYear', 'toStartOfISOYear': 'toStartOfISOYear', 'toStartOfQuarter': 'toStartOfQuarter', 'toStartOfMonth': 'toStartOfMonth', 'toLastDayOfMonth': 'toLastDayOfMonth', 'toMonday': 'toMonday', 'toStartOfWeek': 'toStartOfWeek', 'toStartOfDay': 'toStartOfDay', 'toLastDayOfWeek': 'toLastDayOfWeek', 'toStartOfHour': 'toStartOfHour', 'toStartOfMinute': 'toStartOfMinute', 'toStartOfSecond': 'toStartOfSecond', 'toStartOfFiveMinutes': 'toStartOfFiveMinutes', 'toStartOfTenMinutes': 'toStartOfTenMinutes', 'toStartOfFifteenMinutes': 'toStartOfFifteenMinutes', 'toTime': 'toTime', 'toISOYear': 'toISOYear', 'toISOWeek': 'toISOWeek', 'toWeek': 'toWeek', 'toYearWeek': 'toYearWeek', 'age': 'age', 'dateAdd': 'dateAdd', 'dateSub': 'dateSub', 'timeStampAdd': 'timeStampAdd', 'timeStampSub': 'timeStampSub', 'nowInBlock': 'nowInBlock', 'rowNumberInBlock': 'rowNumberInBlock', 'rowNumberInAllBlocks': 'rowNumberInAllBlocks', 'yesterday': 'yesterday', 'timeSlot': 'timeSlot', 'toYYYYMM': 'toYYYYMM', 'toYYYYMMDD': 'toYYYYMMDD', 'toYYYYMMDDhhmmss': 'toYYYYMMDDhhmmss', 'addYears': 'addYears', 'addMonths': 'addMonths', 'addWeeks': 'addWeeks', 'addDays': 'addDays', 'addHours': 'addHours', 'addMinutes': 'addMinutes', 'addSeconds': 'addSeconds', 'addQuarters': 'addQuarters', 'subtractYears': 'subtractYears', 'subtractMonths': 'subtractMonths', 'subtractWeeks': 'subtractWeeks', 'subtractDays': 'subtractDays', 'subtractHours': 'subtractHours', 'subtractMinutes': 'subtractMinutes', 'subtractSeconds': 'subtractSeconds', 'subtractQuarters': 'subtractQuarters', 'timeSlots': 'timeSlots', 'formatDateTime': 'formatDateTime', 'dateName': 'dateName', 'monthName': 'monthName', 'fromUnixTimestamp': 'fromUnixTimestamp', 'toModifiedJulianDay': 'toModifiedJulianDayOrNull', 'fromModifiedJulianDay': 'fromModifiedJulianDayOrNull', 'toIntervalSecond': 'toIntervalSecond', 'toIntervalMinute': 'toIntervalMinute', 'toIntervalHour': 'toIntervalHour', 'toIntervalDay': 'toIntervalDay', 'toIntervalWeek': 'toIntervalWeek', 'toIntervalMonth': 'toIntervalMonth', 'toIntervalQuarter': 'toIntervalQuarter', 'toIntervalYear': 'toIntervalYear', 'left': 'left', 'right': 'right', 'lengthUTF8': 'lengthUTF8', 'leftPad': 'leftPad', 'rightPad': 'rightPad', 'leftPadUTF8': 'leftPadUTF8', 'rightPadUTF8': 'rightPadUTF8', 'lower': 'lower', 'upper': 'upper', 'lowerUTF8': 'lowerUTF8', 'upperUTF8': 'upperUTF8', 'isValidUTF8': 'isValidUTF8', 'toValidUTF8': 'toValidUTF8', 'repeat': 'repeat', 'format': 'format', 'reverseUTF8': 'reverseUTF8', 'concat': 'concat', 'substring': 'substring', 'substringUTF8': 'substringUTF8', 'appendTrailingCharIfAbsent': 'appendTrailingCharIfAbsent', 'convertCharset': 'convertCharset', 'base58Encode': 'base58Encode', 'base58Decode': 'base58Decode', 'tryBase58Decode': 'tryBase58Decode', 'base64Encode': 'base64Encode', 'base64Decode': 'base64Decode', 'tryBase64Decode': 'tryBase64Decode', 'endsWith': 'endsWith', 'startsWith': 'startsWith', 'encodeXMLComponent': 'encodeXMLComponent', 'decodeXMLComponent': 'decodeXMLComponent', 'extractTextFromHTML': 'extractTextFromHTML', 'ascii': 'ascii', 'concatWithSeparator': 'concatWithSeparator', 'position': 'position', 'positionCaseInsensitive': 'positionCaseInsensitive', 'positionUTF8': 'positionUTF8', 'positionCaseInsensitiveUTF8': 'positionCaseInsensitiveUTF8', 'multiSearchAllPositions': 'multiSearchAllPositions', 'multiSearchAllPositionsUTF8': 'multiSearchAllPositionsUTF8', 'multiSearchFirstPosition': 'multiSearchFirstPosition', 'multiSearchFirstIndex': 'multiSearchFirstIndex', 'multiSearchAny': 'multiSearchAny', 'match': 'match', 'multiMatchAny': 'multiMatchAny', 'multiMatchAnyIndex': 'multiMatchAnyIndex', 'multiMatchAllIndices': 'multiMatchAllIndices', 'multiFuzzyMatchAny': 'multiFuzzyMatchAny', 'multiFuzzyMatchAnyIndex': 'multiFuzzyMatchAnyIndex', 'multiFuzzyMatchAllIndices': 'multiFuzzyMatchAllIndices', 'extract': 'extract', 'extractAll': 'extractAll', 'extractAllGroupsHorizontal': 'extractAllGroupsHorizontal', 'extractAllGroupsVertical': 'extractAllGroupsVertical', 'like': 'like', 'ilike': 'ilike', 'notLike': 'notLike', 'notILike': 'notILike', 'ngramDistance': 'ngramDistance', 'ngramSearch': 'ngramSearch', 'countSubstrings': 'countSubstrings', 'countSubstringsCaseInsensitive': 'countSubstringsCaseInsensitive', 'countSubstringsCaseInsensitiveUTF8': 'countSubstringsCaseInsensitiveUTF8', 'countMatches': 'countMatches', 'regexpExtract': 'regexpExtract', 'replace': 'replace', 'replaceAll': 'replaceAll', 'replaceOne': 'replaceOne', 'replaceRegexpAll': 'replaceRegexpAll', 'replaceRegexpOne': 'replaceRegexpOne', 'regexpQuoteMeta': 'regexpQuoteMeta', 'translate': 'translate', 'translateUTF8': 'translateUTF8', 'if': 'if', 'multiIf': 'multiIf', 'e': 'e', 'pi': 'pi', 'exp': 'exp', 'log': 'log', 'ln': 'ln', 'exp2': 'exp2', 'log2': 'log2', 'exp10': 'exp10', 'log10': 'log10', 'sqrt': 'sqrt', 'cbrt': 'cbrt', 'erf': 'erf', 'erfc': 'erfc', 'lgamma': 'lgamma', 'tgamma': 'tgamma', 'sin': 'sin', 'cos': 'cos', 'tan': 'tan', 'asin': 'asin', 'acos': 'acos', 'atan': 'atan', 'pow': 'pow', 'power': 'power', 'intExp2': 'intExp2', 'intExp10': 'intExp10', 'cosh': 'cosh', 'acosh': 'acosh', 'sinh': 'sinh', 'asinh': 'asinh', 'atanh': 'atanh', 'atan2': 'atan2', 'hypot': 'hypot', 'log1p': 'log1p', 'sign': 'sign', 'degrees': 'degrees', 'radians': 'radians', 'factorial': 'factorial', 'width_bucket': 'width_bucket', 'floor': 'floor', 'ceil': 'ceil', 'trunc': 'trunc', 'round': 'round', 'roundBankers': 'roundBankers', 'roundToExp2': 'roundToExp2', 'roundDuration': 'roundDuration', 'roundAge': 'roundAge', 'roundDown': 'roundDown', 'map': 'map', 'mapFromArrays': 'mapFromArrays', 'mapAdd': 'mapAdd', 'mapSubtract': 'mapSubtract', 'mapPopulateSeries': 'mapPopulateSeries', 'mapContains': 'mapContains', 'mapKeys': 'mapKeys', 'mapValues': 'mapValues', 'mapContainsKeyLike': 'mapContainsKeyLike', 'mapExtractKeyLike': 'mapExtractKeyLike', 'mapApply': 'mapApply', 'mapFilter': 'mapFilter', 'mapUpdate': 'mapUpdate', 'splitByChar': 'splitByChar', 'splitByString': 'splitByString', 'splitByRegexp': 'splitByRegexp', 'splitByWhitespace': 'splitByWhitespace', 'splitByNonAlpha': 'splitByNonAlpha', 'arrayStringConcat': 'arrayStringConcat', 'alphaTokens': 'alphaTokens', 'extractAllGroups': 'extractAllGroups', 'ngrams': 'ngrams', 'tokens': 'tokens', 'bitAnd': 'bitAnd', 'bitOr': 'bitOr', 'bitXor': 'bitXor', 'bitNot': 'bitNot', 'bitShiftLeft': 'bitShiftLeft', 'bitShiftRight': 'bitShiftRight', 'bitRotateLeft': 'bitRotateLeft', 'bitRotateRight': 'bitRotateRight', 'bitSlice': 'bitSlice', 'bitTest': 'bitTest', 'bitTestAll': 'bitTestAll', 'bitTestAny': 'bitTestAny', 'bitCount': 'bitCount', 'bitHammingDistance': 'bitHammingDistance', 'bitmapBuild': 'bitmapBuild', 'bitmapToArray': 'bitmapToArray', 'bitmapSubsetInRange': 'bitmapSubsetInRange', 'bitmapSubsetLimit': 'bitmapSubsetLimit', 'subBitmap': 'subBitmap', 'bitmapContains': 'bitmapContains', 'bitmapHasAny': 'bitmapHasAny', 'bitmapHasAll': 'bitmapHasAll', 'bitmapCardinality': 'bitmapCardinality', 'bitmapMin': 'bitmapMin', 'bitmapMax': 'bitmapMax', 'bitmapTransform': 'bitmapTransform', 'bitmapAnd': 'bitmapAnd', 'bitmapOr': 'bitmapOr', 'bitmapXor': 'bitmapXor', 'bitmapAndnot': 'bitmapAndnot', 'bitmapAndCardinality': 'bitmapAndCardinality', 'bitmapOrCardinality': 'bitmapOrCardinality', 'bitmapXorCardinality': 'bitmapXorCardinality', 'bitmapAndnotCardinality': 'bitmapAndnotCardinality', 'protocol': 'protocol', 'domain': 'domain', 'domainWithoutWWW': 'domainWithoutWWW', 'topLevelDomain': 'topLevelDomain', 'firstSignificantSubdomain': 'firstSignificantSubdomain', 'cutToFirstSignificantSubdomain': 'cutToFirstSignificantSubdomain', 'cutToFirstSignificantSubdomainWithWWW': 'cutToFirstSignificantSubdomainWithWWW', 'port': 'port', 'path': 'path', 'pathFull': 'pathFull', 'queryString': 'queryString', 'fragment': 'fragment', 'queryStringAndFragment': 'queryStringAndFragment', 'extractURLParameter': 'extractURLParameter', 'extractURLParameters': 'extractURLParameters', 'extractURLParameterNames': 'extractURLParameterNames', 'URLHierarchy': 'URLHierarchy', 'URLPathHierarchy': 'URLPathHierarchy', 'encodeURLComponent': 'encodeURLComponent', 'decodeURLComponent': 'decodeURLComponent', 'encodeURLFormComponent': 'encodeURLFormComponent', 'decodeURLFormComponent': 'decodeURLFormComponent', 'netloc': 'netloc', 'cutWWW': 'cutWWW', 'cutQueryString': 'cutQueryString', 'cutFragment': 'cutFragment', 'cutQueryStringAndFragment': 'cutQueryStringAndFragment', 'cutURLParameter': 'cutURLParameter', 'isValidJSON': 'isValidJSON', 'JSONHas': 'JSONHas', 'JSONLength': 'JSONLength', 'JSONArrayLength': 'JSONArrayLength', 'JSONType': 'JSONType', 'JSONExtract': 'JSONExtract', 'JSONExtractUInt': 'JSONExtractUInt', 'JSONExtractInt': 'JSONExtractInt', 'JSONExtractFloat': 'JSONExtractFloat', 'JSONExtractBool': 'JSONExtractBool', 'JSONExtractString': 'JSONExtractString', 'JSONExtractKey': 'JSONExtractKey', 'JSONExtractKeys': 'JSONExtractKeys', 'JSONExtractRaw': 'JSONExtractRaw', 'JSONExtractArrayRaw': 'JSONExtractArrayRaw', 'JSONExtractKeysAndValues': 'JSONExtractKeysAndValues', 'JSONExtractKeysAndValuesRaw': 'JSONExtractKeysAndValuesRaw', 'JSON_VALUE': 'JSON_VALUE', 'in': 'in', 'notIn': 'notIn', 'greatCircleDistance': 'greatCircleDistance', 'geoDistance': 'geoDistance', 'greatCircleAngle': 'greatCircleAngle', 'pointInEllipses': 'pointInEllipses', 'pointInPolygon': 'pointInPolygon', 'geohashEncode': 'geohashEncode', 'geohashDecode': 'geohashDecode', 'geohashesInBox': 'geohashesInBox', 'isnull': 'isNull', 'isNotNull': 'isNotNull', 'coalesce': 'coalesce', 'ifnull': 'ifNull', 'nullif': 'nullIf', 'assumeNotNull': 'assumeNotNull', 'toNullable': 'toNullable', 'tuple': 'tuple', 'tupleElement': 'tupleElement', 'untuple': 'untuple', 'tupleHammingDistance': 'tupleHammingDistance', 'tupleToNameValuePairs': 'tupleToNameValuePairs', 'tuplePlus': 'tuplePlus', 'tupleMinus': 'tupleMinus', 'tupleMultiply': 'tupleMultiply', 'tupleDivide': 'tupleDivide', 'tupleNegate': 'tupleNegate', 'tupleMultiplyByNumber': 'tupleMultiplyByNumber', 'tupleDivideByNumber': 'tupleDivideByNumber', 'dotProduct': 'dotProduct', 'isFinite': 'isFinite', 'isInfinite': 'isInfinite', 'ifNotFinite': 'ifNotFinite', 'isNaN': 'isNaN', 'bar': 'bar', 'transform': 'transform', 'formatReadableDecimalSize': 'formatReadableDecimalSize', 'formatReadableSize': 'formatReadableSize', 'formatReadableQuantity': 'formatReadableQuantity', 'formatReadableTimeDelta': 'formatReadableTimeDelta', 'least': 'least', 'greatest': 'greatest', 'tumble': 'tumble', 'hop': 'hop', 'tumbleStart': 'tumbleStart', 'tumbleEnd': 'tumbleEnd', 'hopStart': 'hopStart', 'hopEnd': 'hopEnd', 'L1Norm': 'L1Norm', 'L2Norm': 'L2Norm', 'LinfNorm': 'LinfNorm', 'LpNorm': 'LpNorm', 'L1Distance': 'L1Distance', 'L2Distance': 'L2Distance', 'LinfDistance': 'LinfDistance', 'LpDistance': 'LpDistance', 'L1Normalize': 'L1Normalize', 'L2Normalize': 'L2Normalize', 'LinfNormalize': 'LinfNormalize', 'LpNormalize': 'LpNormalize', 'cosineDistance': 'cosineDistance', 'rank': 'rank', 'dense_rank': 'dense_rank', 'row_number': 'row_number', 'first_value': 'first_value', 'last_value': 'last_value', 'nth_value': 'nth_value', 'lagInFrame': 'lagInFrame', 'leadInFrame': 'leadInFrame', 'generateSeries': 'generate_series', 'date_part': "if({} = 'year', toYear({}), if({} = 'month', toMonth({}), if({} = 'day', toDayOfMonth({}), if({} = 'hour', toHour({}), if({} = 'minute', toMinute({}), if({} = 'second', toSecond({}), if({} = 'dow', toDayOfWeek({}), if({} = 'doy', toDayOfYear({}), if({} = 'quarter', toQuarter({}), null)))))))))", 'date_trunc': 'dateTrunc', 'dateTrunc': 'dateTrunc', 'to_timestamp': 'toDateTime(fromUnixTimestamp({}))', 'to_char': 'formatDateTime', 'make_timestamp': 'makeDateTime', 'make_date': 'makeDate', 'now': 'now64', 'current_timestamp': 'now64', 'today': 'today', 'current_date': 'today', 'date_add': 'date_add', 'date_subtract': 'date_sub', 'date_diff': 'dateDiff', 'dateDiff': 'dateDiff', 'make_interval': 'toIntervalYear({}) + toIntervalMonth({}) + toIntervalDay({}) + toIntervalHour({}) + toIntervalMinute({}) + toIntervalSecond({})', 'make_timestamptz': 'toTimeZone(makeDateTime({}, {}, {}, {}, {}, {}), {})', 'timezone': 'toTimeZone({1}, {0})', 'toTimeZone': 'toTimeZone', 'lag': 'lagInFrame', 'lead': 'leadInFrame', 'initcap': 'initcap', 'lpad': 'lpad', 'rpad': 'rpad', 'ltrim': 'trimLeft', 'trimLeft': 'trimLeft', 'rtrim': 'trimRight', 'trimRight': 'trimRight', 'btrim': 'trim', 'trim': 'trim', 'split_part': "if(empty(splitByString({1}, {0})), '', if(length(splitByString({1}, {0})) >= {2}, arrayElement(splitByString({1}, {0}), {2}), ''))", 'getSurveyResponse': 'getSurveyResponse', 'aggregate_funnel': 'aggregate_funnel_v7', 'aggregate_funnel_array': 'aggregate_funnel_array_v7', 'aggregate_funnel_cohort': 'aggregate_funnel_cohort_v7', 'aggregate_funnel_trends': 'aggregate_funnel_trends_v7', 'aggregate_funnel_array_trends': 'aggregate_funnel_array_trends_v7', 'aggregate_funnel_cohort_trends': 'aggregate_funnel_cohort_trends_v7', 'aggregate_funnel_test': 'aggregate_funnel_test_v7'}
  ```
  
  These are the aggregated HogQL functions and their ClickHouse function name mapping:
  ```
  {'count': 'count', 'countIf': 'countIf', 'countDistinctIf': 'countDistinctIf', 'min': 'min', 'minIf': 'minIf', 'max': 'max', 'maxIf': 'maxIf', 'sum': 'sum', 'sumForEach': 'sumForEach', 'sumIf': 'sumIf', 'avg': 'avg', 'avgIf': 'avgIf', 'any': 'any', 'anyIf': 'anyIf', 'stddevPop': 'stddevPop', 'stddevPopIf': 'stddevPopIf', 'stddevSamp': 'stddevSamp', 'stddevSampIf': 'stddevSampIf', 'varPop': 'varPop', 'varPopIf': 'varPopIf', 'varSamp': 'varSamp', 'varSampIf': 'varSampIf', 'covarPop': 'covarPop', 'covarPopIf': 'covarPopIf', 'covarSamp': 'covarSamp', 'covarSampIf': 'covarSampIf', 'corr': 'corr', 'array_agg': 'groupArray', 'groupArray': 'groupArray', 'json_agg': 'toJSONString(groupArray({}))', 'string_agg': 'arrayStringConcat(groupArray({}), {})', 'every': 'toBool(min({}))', 'anyHeavy': 'anyHeavy', 'anyHeavyIf': 'anyHeavyIf', 'anyLast': 'anyLast', 'anyLastIf': 'anyLastIf', 'argMin': 'argMin', 'argMinIf': 'argMinIf', 'argMax': 'argMax', 'argMaxIf': 'argMaxIf', 'argMinMerge': 'argMinMerge', 'argMaxMerge': 'argMaxMerge', 'avgState': 'avgState', 'avgMerge': 'avgMerge', 'avgMergeIf': 'avgMergeIf', 'avgWeighted': 'avgWeighted', 'avgWeightedIf': 'avgWeightedIf', 'avgArray': 'avgArrayOrNull', 'topK': 'topK', 'groupArrayIf': 'groupArrayIf', 'groupUniqArray': 'groupUniqArray', 'groupUniqArrayIf': 'groupUniqArrayIf', 'groupArrayInsertAt': 'groupArrayInsertAt', 'groupArrayInsertAtIf': 'groupArrayInsertAtIf', 'groupArrayMovingAvg': 'groupArrayMovingAvg', 'groupArrayMovingAvgIf': 'groupArrayMovingAvgIf', 'groupArrayMovingSum': 'groupArrayMovingSum', 'groupArrayMovingSumIf': 'groupArrayMovingSumIf', 'groupBitAnd': 'groupBitAnd', 'groupBitAndIf': 'groupBitAndIf', 'groupBitOr': 'groupBitOr', 'groupBitOrIf': 'groupBitOrIf', 'groupBitXor': 'groupBitXor', 'groupBitXorIf': 'groupBitXorIf', 'groupBitmap': 'groupBitmap', 'groupBitmapIf': 'groupBitmapIf', 'groupBitmapAnd': 'groupBitmapAnd', 'groupBitmapAndIf': 'groupBitmapAndIf', 'groupBitmapOr': 'groupBitmapOr', 'groupBitmapOrIf': 'groupBitmapOrIf', 'groupBitmapXor': 'groupBitmapXor', 'groupBitmapXorIf': 'groupBitmapXorIf', 'sumWithOverflow': 'sumWithOverflow', 'sumWithOverflowIf': 'sumWithOverflowIf', 'deltaSum': 'deltaSum', 'deltaSumIf': 'deltaSumIf', 'deltaSumTimestamp': 'deltaSumTimestamp', 'deltaSumTimestampIf': 'deltaSumTimestampIf', 'sumMap': 'sumMap', 'sumMapIf': 'sumMapIf', 'sumMapMerge': 'sumMapMerge', 'minMap': 'minMap', 'minMapIf': 'minMapIf', 'maxMap': 'maxMap', 'maxMapIf': 'maxMapIf', 'medianArray': 'medianArrayOrNull', 'skewSamp': 'skewSamp', 'skewSampIf': 'skewSampIf', 'skewPop': 'skewPop', 'skewPopIf': 'skewPopIf', 'kurtSamp': 'kurtSamp', 'kurtSampIf': 'kurtSampIf', 'kurtPop': 'kurtPop', 'kurtPopIf': 'kurtPopIf', 'uniq': 'uniq', 'uniqIf': 'uniqIf', 'uniqExact': 'uniqExact', 'uniqExactIf': 'uniqExactIf', 'uniqHLL12': 'uniqHLL12', 'uniqHLL12If': 'uniqHLL12If', 'uniqTheta': 'uniqTheta', 'uniqThetaIf': 'uniqThetaIf', 'uniqMerge': 'uniqMerge', 'uniqMap': 'uniqMap', 'uniqUpToMerge': 'uniqUpToMerge', 'median': 'median', 'medianIf': 'medianIf', 'medianExact': 'medianExact', 'medianExactIf': 'medianExactIf', 'medianExactLow': 'medianExactLow', 'medianExactLowIf': 'medianExactLowIf', 'medianExactHigh': 'medianExactHigh', 'medianExactHighIf': 'medianExactHighIf', 'medianExactWeighted': 'medianExactWeighted', 'medianExactWeightedIf': 'medianExactWeightedIf', 'medianTiming': 'medianTiming', 'medianTimingIf': 'medianTimingIf', 'medianTimingWeighted': 'medianTimingWeighted', 'medianTimingWeightedIf': 'medianTimingWeightedIf', 'medianDeterministic': 'medianDeterministic', 'medianDeterministicIf': 'medianDeterministicIf', 'medianTDigest': 'medianTDigest', 'medianTDigestIf': 'medianTDigestIf', 'medianTDigestWeighted': 'medianTDigestWeighted', 'medianTDigestWeightedIf': 'medianTDigestWeightedIf', 'medianBFloat16': 'medianBFloat16', 'medianBFloat16If': 'medianBFloat16If', 'quantile': 'quantile', 'quantileIf': 'quantileIf', 'quantiles': 'quantiles', 'quantilesIf': 'quantilesIf', 'simpleLinearRegression': 'simpleLinearRegression', 'simpleLinearRegressionIf': 'simpleLinearRegressionIf', 'contingency': 'contingency', 'contingencyIf': 'contingencyIf', 'cramersV': 'cramersV', 'cramersVIf': 'cramersVIf', 'cramersVBiasCorrected': 'cramersVBiasCorrected', 'cramersVBiasCorrectedIf': 'cramersVBiasCorrectedIf', 'theilsU': 'theilsU', 'theilsUIf': 'theilsUIf', 'maxIntersections': 'maxIntersections', 'maxIntersectionsIf': 'maxIntersectionsIf', 'maxIntersectionsPosition': 'maxIntersectionsPosition', 'maxIntersectionsPositionIf': 'maxIntersectionsPositionIf', 'windowFunnel': 'windowFunnel'}
  ```
  
  And lastly these are some HogQL specific functions that have no mapping to ClickHouse:
  ```
  ['matchesAction', 'sparkline', 'recording_button', 'hogql_lookupDomainType', 'hogql_lookupPaidSourceType', 'hogql_lookupPaidMediumType', 'hogql_lookupOrganicSourceType', 'hogql_lookupOrganicMediumType', 'convertCurrency']
  ```
  
  You fix HogQL errors that may come from either HogQL resolver errors or clickhouse execution errors. You don't help with other knowledge.
  
  Important HogQL differences versus other SQL dialects:
  - JSON properties are accessed like `properties.foo.bar` instead of `properties->foo->bar`
  
  This is a list of all the available tables in the database:
  ```
  ['events', 'groups', 'persons', 'sessions', 'query_log']
  ```
  
  Person or event metadata unspecified above (emails, names, etc.) is stored in `properties` fields, accessed like: `properties.foo.bar`.
  Note: "persons" means "users" here - instead of a "users" table, we have a "persons" table.
  
  Standardized events/properties such as pageview or screen start with `$`. Custom events/properties start with any other character.
  
  `virtual_table` and `lazy_table` fields are connections to linked tables, e.g. the virtual table field `person` allows accessing person properties like so: `person.properties.foo`.
  '''
# ---
# name: test_get_user_prompt
  '''
  
  Fix the errors in the HogQL query below and only return the new updated query in your response.
  
  - Don't update any other part of the query if it's not relevant to the error, including rewriting shorthand clickhouse SQL to the full version.
  - Don't change the capitalisation of the query if it's not relevant to the error, such as rewriting `select` as `SELECT` or `from` as `FROM`
  - Don't convert syntax to an alternative if it's not relevant to the error, such as changing `toIntervalDay(1)` to `INTERVAL 1 DAY`
  - There may also be more than one error in the syntax.
  
  This is the schema of tables currently used in the provided query:
  
  Table `events` with fields:
  - uuid (string)
  - event (string)
  - properties (json)
  - timestamp (datetime)
  - distinct_id (string)
  - elements_chain (string)
  - created_at (datetime)
  - $session_id (string)
  - $window_id (string)
  - pdi (lazy_table)
  - poe (virtual_table)
  - goe_0 (virtual_table)
  - goe_1 (virtual_table)
  - goe_2 (virtual_table)
  - goe_3 (virtual_table)
  - goe_4 (virtual_table)
  - person (lazy_table)
  - person_id (expression)
  - $group_0 (string)
  - group_0 (lazy_table)
  - $group_1 (string)
  - group_1 (lazy_table)
  - $group_2 (string)
  - group_2 (lazy_table)
  - $group_3 (string)
  - group_3 (lazy_table)
  - $group_4 (string)
  - group_4 (lazy_table)
  - session (lazy_table)
  - elements_chain_href (string)
  - elements_chain_texts (array)
  - elements_chain_ids (array)
  - elements_chain_elements (array)
  - event_person_id (string)
  - override (lazy_table)
  - event_issue_id (expression)
  - exception_issue_override (lazy_table)
  - issue_id (expression)
  
  Below is the current HogQL query and the error message
  
  
  <hogql_query>{{{hogql_query}}}</hogql_query>
  
  <error>{{{error_message}}}</error>
  '''
# ---
