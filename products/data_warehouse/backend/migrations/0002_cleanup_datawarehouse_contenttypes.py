# Generated by Django

import logging

from django.db import migrations

logger = logging.getLogger(__name__)


def cleanup_broken_contenttypes(apps, schema_editor):
    """
    Clean up scenario where buggy migration created ContentTypes with app_label="datawarehouse"
    while Django auto-created correct ones with app_label="data_warehouse".

    This handles the case where:
    1. Buggy migration 0897 created ContentTypes with app_label="datawarehouse"
    2. Django auto-created ContentTypes with app_label="data_warehouse" when models were accessed
    3. Now we have duplicate ContentTypes and Permissions

    The main issue is Permissions - Django creates permissions per ContentType, so duplicates
    mean duplicate permissions and broken permission checks.

    Strategy (following products/early_access_features/backend/migrations/0003 pattern):
    - Find all ContentTypes with app_label="datawarehouse" (wrong)
    - For each one, check if correct "data_warehouse" version exists
    - If both exist:
      * Safety check: verify no user/group assignments to duplicate permissions
      * Delete duplicate permissions pointing to wrong ContentType
      * Delete wrong ContentType
      * The correct ContentType with correct permissions already exists
    - If only wrong one exists: rename it to correct name
    """
    ContentType = apps.get_model("contenttypes", "ContentType")
    Permission = apps.get_model("auth", "Permission")

    models_to_fix = [
        "datamodelingjob",
        "datawarehousecredential",
        "datawarehousejoin",
        "datawarehousemanagedviewset",
        "datawarehousemodelpath",
        "datawarehousesavedquery",
        "datawarehousesavedquerydraft",
        "datawarehousetable",
        "datawarehouseviewlink",
        "externaldatajob",
        "externaldataschema",
        "externaldatasource",
        "externaldatasourcerevenueanalyticsconfig",
        "querytabstate",
    ]

    for model_name in models_to_fix:
        try:
            wrong_ct = ContentType.objects.get(app_label="datawarehouse", model=model_name)
        except ContentType.DoesNotExist:
            # No broken ContentType exists, skip
            continue

        try:
            ContentType.objects.get(app_label="data_warehouse", model=model_name)
            # Both exist - need to clean up duplicates

            # Safety check: ensure no permissions are assigned to users/groups for the wrong ContentType
            from django.db import connection

            with connection.cursor() as cursor:
                # Check user permissions
                cursor.execute(
                    """
                    SELECT COUNT(*)
                    FROM posthog_user_user_permissions uup
                    JOIN auth_permission p ON uup.permission_id = p.id
                    WHERE p.content_type_id = %s
                """,
                    [wrong_ct.id],
                )
                user_perm_count = cursor.fetchone()[0]

                # Check group permissions
                cursor.execute(
                    """
                    SELECT COUNT(*)
                    FROM auth_group_permissions gp
                    JOIN auth_permission p ON gp.permission_id = p.id
                    WHERE p.content_type_id = %s
                """,
                    [wrong_ct.id],
                )
                group_perm_count = cursor.fetchone()[0]

            if user_perm_count != 0 or group_perm_count != 0:
                logger.warning(
                    f"[MIGRATION 0898] Found {user_perm_count} user permissions and {group_perm_count} "
                    f"group permissions assigned. Skipping cleanup for {model_name} - manual intervention required."
                )
                continue

            # Keep the ORIGINAL ContentType (from buggy migration, has all historical references)
            # Delete the DUPLICATE ContentType (Django auto-created, has no references yet)
            # Then rename original to correct app_label
            Permission.objects.filter(
                content_type=ContentType.objects.get(app_label="data_warehouse", model=model_name)
            ).delete()
            ContentType.objects.get(app_label="data_warehouse", model=model_name).delete()
            wrong_ct.app_label = "data_warehouse"
            wrong_ct.save()

        except ContentType.DoesNotExist:
            # Correct version doesn't exist yet, just rename the wrong one
            wrong_ct.app_label = "data_warehouse"
            wrong_ct.save()


class Migration(migrations.Migration):
    dependencies = [
        ("data_warehouse", "0001_migrate_data_warehouse_models"),
        ("posthog", "0897_migrate_data_warehouse_models"),
    ]

    operations = [
        migrations.RunPython(cleanup_broken_contenttypes, migrations.RunPython.noop, elidable=True),
    ]
