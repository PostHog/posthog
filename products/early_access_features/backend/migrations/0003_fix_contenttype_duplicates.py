# Generated by Django 4.2.22 on 2025-10-10 12:56

from django.db import migrations


def fix_contenttype_duplicates(apps, schema_editor):
    """
    Fix duplicate ContentType entries for EarlyAccessFeature.

    Background:
    When early_access_features was migrated from posthog app to products app
    in PR #26693 (Jan 2025), migration 0548_migrate_early_access_features used
    SeparateDatabaseAndState to move the model, but did not update ContentType.

    This caused Django to create a NEW ContentType entry when it saw the model
    registered under app_label='early_access_features', while the OLD ContentType
    with app_label='posthog' remained.

    Production investigation (2025-10-10) confirmed:
    - ContentType ID 296: app_label='posthog' (original, needs update)
    - ContentType ID 2580: app_label='early_access_features' (duplicate, needs deletion)
    - Both have 4 permissions each (8 total duplicates)
    - 0 permissions assigned to users/groups (no data loss risk)
    - 0 django_admin_log entries
    - Activity logging uses scope strings, not ContentType IDs

    This migration:
    1. Deletes duplicate permissions pointing to the new ContentType
    2. Deletes the duplicate new ContentType
    3. Updates the original ContentType to have the correct app_label

    This is what SHOULD have been done in the original migration, as documented
    in the model migration workflow and as done correctly for error_tracking in
    migration 0878_migrate_error_tracking_models.
    """
    ContentType = apps.get_model("contenttypes", "ContentType")
    Permission = apps.get_model("auth", "Permission")

    try:
        # Get both ContentType entries
        old_ct = ContentType.objects.get(app_label="posthog", model="earlyaccessfeature")
        new_ct = ContentType.objects.get(app_label="early_access_features", model="earlyaccessfeature")

        # Sanity check: ensure no permissions are assigned to users/groups
        # If this fails, it means the state has changed and we need to investigate
        import logging

        from django.db import connection

        logger = logging.getLogger(__name__)

        with connection.cursor() as cursor:
            # Check user permissions
            cursor.execute(
                """
                SELECT COUNT(*)
                FROM posthog_user_user_permissions uup
                JOIN auth_permission p ON uup.permission_id = p.id
                WHERE p.content_type_id IN (%s, %s)
            """,
                [old_ct.id, new_ct.id],
            )
            user_perm_count = cursor.fetchone()[0]

            # Check group permissions
            cursor.execute(
                """
                SELECT COUNT(*)
                FROM auth_group_permissions gp
                JOIN auth_permission p ON gp.permission_id = p.id
                WHERE p.content_type_id IN (%s, %s)
            """,
                [old_ct.id, new_ct.id],
            )
            group_perm_count = cursor.fetchone()[0]

        if user_perm_count != 0 or group_perm_count != 0:
            logger.warning(
                f"[MIGRATION 0003] Expected 0 assigned permissions, but found {user_perm_count} user permissions "
                f"and {group_perm_count} group permissions. State has changed since investigation. "
                f"Skipping ContentType cleanup - manual intervention required."
            )
            return

        # Delete permissions pointing to the new ContentType
        # (Production check confirmed 0 assigned to users/groups, so safe to delete)
        Permission.objects.filter(content_type=new_ct).delete()

        # Delete the duplicate new ContentType
        new_ct.delete()

        # Update the original ContentType to have the correct app_label
        old_ct.app_label = "early_access_features"
        old_ct.save()

    except ContentType.DoesNotExist:
        # Already fixed or never had the issue (e.g., fresh install)
        pass


def reverse_fix(apps, schema_editor):
    """
    Reverse is a no-op since we can't reliably recreate the duplicate state.
    The forward migration is safe because no permissions were assigned.
    """
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("early_access_features", "0002_alter_earlyaccessfeature_options_and_more"),
    ]

    operations = [
        migrations.RunPython(fix_contenttype_duplicates, reverse_fix, elidable=True),
    ]
