# serializer version: 1
# name: TestEventDefinitionTypeScriptGeneration.test_typescript_allows_additional_properties
  '''
  /**
   * GENERATED FILE - DO NOT EDIT
   *
   * This file was auto-generated by PostHog
   * Generated at: <TIMESTAMP>
   * Generator version: 1.0.0
   *
   * Provides capture() for type-safe events and captureRaw() for flexibility
   */
  import originalPostHog from 'posthog-js'
  import type { CaptureOptions, CaptureResult, PostHog as OriginalPostHog, Properties } from 'posthog-js'
  // Define event schemas with their required and optional fields
  interface EventSchemas {
      "a'a\\'b\"c>?>%}}%%>c<[[?${{%}}cake'": {
          "prop'with\\'quotes\"\\slash": string
      }
      "optional_event": {
          "optional_only"?: string
      }
      "test_event": {
          "optional_field"?: string
          "required_field": number
      }
      "untyped_event": Record<string, any>
  }
  // Type alias for all valid event names
  export type EventName = keyof EventSchemas
  
  // Type helper to get properties for a specific event
  // Intersects the schema with Record<string, any> to allow additional properties
  export type EventProperties<K extends EventName> = EventSchemas[K] & Record<string, any>
  
  // Helper type to check if a type has required properties
  type HasRequiredProperties<K extends EventName> = {} extends EventSchemas[K] ? false : true
  
  // Helper to detect if T is exactly 'string' (not a literal)
  type IsExactlyString<T> = string extends T ? (T extends string ? true : false) : false
  
  // Enhanced PostHog interface with typed capture
  interface TypedPostHog extends Omit<OriginalPostHog, 'capture'> {
      /**
       * Type-safe capture for defined events, or flexible capture for undefined events
       *
       * Note: For defined events, wrap properties in a variable to allow additional properties:
       * const props = { file_size_b: 100, extra: 'data' }
       * posthog.capture('downloaded_file', props)
       *
       * @example
       * // Defined event with type safety
       * posthog.capture('uploaded_file', {
       *   file_name: 'test.txt',
       *   file_size_b: 100
       * })
       *
       * @example
       * // For events with all optional properties, properties argument is optional
       * posthog.capture('logged_out') // no properties needed
       *
       * @example
       * // Undefined events work with arbitrary properties
       * posthog.capture('custom_event', { whatever: 'data' })
       * posthog.capture('another_event') // or no properties
       */
      // Overload 1: For known events (specific EventName literals)
      // This should match first for all known event names
      capture<K extends EventName>(
          event_name: K,
          ...args: HasRequiredProperties<K> extends true
              ? [properties: EventProperties<K>, options?: CaptureOptions]
              : [properties?: EventProperties<K>, options?: CaptureOptions]
      ): CaptureResult | undefined
  
      // Overload 2: For undefined events and blocking string variables
      // Only matches if event_name is NOT a known EventName
      // The conditional type rejects broad string type
      capture<T extends string>(
          event_name: IsExactlyString<T> extends true ? never : (T extends EventName ? never : T),
          properties?: Properties | null,
          options?: CaptureOptions
      ): CaptureResult | undefined
  
      /**
       * Raw capture for any event (original behavior, no type checking)
       *
       * Use capture() for type-safe defined events or flexible undefined events.
       * Use captureRaw() only when you need to bypass all type checking.
       *
       * @example
       * posthog.captureRaw('Any Event Name', { whatever: 'data' })
       */
      captureRaw(event_name: string, properties?: Properties | null, options?: CaptureOptions): CaptureResult | undefined
  }
  
  // Create the implementation
  const createTypedPostHog = (original: OriginalPostHog): TypedPostHog => {
      // Create the enhanced PostHog object
      const enhanced: TypedPostHog = Object.create(original)
  
      // Add capture method (type-safe for defined events, flexible for undefined)
      enhanced.capture = function (event_name: string, ...args: any[]): CaptureResult | undefined {
          const [properties, options] = args
          return original.capture(event_name, properties, options)
      }
  
      // Add captureRaw method for untyped/flexible event tracking
      enhanced.captureRaw = function (
          event_name: string,
          properties?: Properties | null,
          options?: CaptureOptions
      ): CaptureResult | undefined {
          return original.capture(event_name, properties, options)
      }
  
      // Proxy to delegate all other properties/methods to the original
      return new Proxy(enhanced, {
          get(target, prop) {
              if (prop in target) {
                  return (target as any)[prop]
              }
              return (original as any)[prop]
          },
          set(target, prop, value) {
              ;(original as any)[prop] = value
              return true
          },
      })
  }
  
  // Create and export the typed instance
  const posthog = createTypedPostHog(originalPostHog as OriginalPostHog)
  
  export default posthog
  export type { EventSchemas, TypedPostHog }
  
  // Re-export everything else from posthog-js
  export * from 'posthog-js'
  
  /**
   * USAGE GUIDE
   * ===========
   *
   * For type-safe defined events (recommended):
   *   posthog.capture('uploaded_file', { file_name: 'test.txt', file_size_b: 100 })
   *
   * For undefined events (flexible):
   *   posthog.capture('Custom Event', { whatever: 'data' })
   *
   * For bypassing all type checking (rare):
   *   posthog.captureRaw('Any Event', { whatever: 'data' })
   */
  
  '''
# ---
