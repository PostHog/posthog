import re
from datetime import datetime

from django.db.models import QuerySet

import orjson

from ...models import EventDefinition, SchemaPropertyGroupProperty
from .base import EventDefinitionGenerator


class PythonGenerator(EventDefinitionGenerator):
    def generator_version(self) -> str:
        return "1.0.0"

    def language_name(self) -> str:
        return "Python"

    def generate(
        self, event_definitions: QuerySet[EventDefinition], schema_map: dict[str, list[SchemaPropertyGroupProperty]]
    ) -> str:
        now = datetime.now().isoformat()

        typed_dict_blocks: list[str] = []
        overload_blocks: list[str] = []
        event_property_mappings: dict[str, dict[str, str]] = {}
        datetime_import = ""

        for event_def in event_definitions:
            properties = schema_map.get(str(event_def.id), [])
            event_name = event_def.name

            # Check if any property uses DateTime type thus if we need to import the datetime module
            if any(prop.property_type == "DateTime" for prop in properties) and not datetime_import:
                datetime_import = "from datetime import datetime\n"

            # Generate TypedDict for this event's properties (and get property mappings)
            typed_dict, prop_mappings = self._generate_typed_dict(event_name, properties)
            typed_dict_blocks.append(typed_dict)
            if prop_mappings:
                event_property_mappings[event_name] = prop_mappings

            overload = self._generate_overload(event_name, properties)
            overload_blocks.append(overload)

        typed_dicts_section = "\n" + "\n\n\n".join(typed_dict_blocks) if typed_dict_blocks else ""
        overloads_section = (
            "\n\n\n# Type-safe capture overloads\n" + "\n\n".join(overload_blocks) if overload_blocks else ""
        )

        # This section includes both the mapping dict and the helper function, placed before overloads
        if event_property_mappings:
            mappings_lines = [
                "# Property name mappings (EventName => Python identifier -> original property name)",
                "_PROPERTY_MAPPINGS: Dict[str, Dict[str, str]] = {",
            ]
            for event_name in sorted(event_property_mappings.keys()):
                mappings = event_property_mappings[event_name]
                escaped_event = self._escape_python_string(event_name)
                mappings_lines.append(f'    "{escaped_event}": {{')
                for py_name, orig_name in sorted(mappings.items()):
                    escaped_orig = self._escape_python_string(orig_name)
                    mappings_lines.append(f'        "{py_name}": "{escaped_orig}",')
                mappings_lines.append("    },")
            mappings_lines.append("}")
            property_mappings_section = "\n".join(mappings_lines) + "\n"
        else:
            property_mappings_section = "_PROPERTY_MAPPINGS: Dict[str, Dict[str, str]] = {}\n"

        header = f'''"""
GENERATED FILE - DO NOT EDIT

This file was auto-generated by PostHog
Generated at: {now}
Generator version: {self.generator_version()}

Provides type-safe event tracking with validated event names and properties.

USAGE GUIDE
===========
1. Save the generated file in your project (if not generated there already):
2. Migrate towards `posthog_typed.capture` for type-safe event tracking:
   import posthog
   import posthog_typed

   # posthog.capture(...) then becomes posthog_typed.capture(...):
   posthog_typed.capture("event_name", distinct_id="user_123", properties={{"property": "value"}})
3. Use posthog.capture for untyped/dynamic events:
   import posthog

   posthog.capture("dynamic_event", distinct_id="user_123", properties={{"anything": "goes"}})

Alternative: If you only use capture() and want a cleaner import:
   import posthog_typed as posthog

   posthog.capture("event_name", distinct_id="user_123", properties={{"property": "value"}})

Note: This pattern means you won't have access to other SDK methods
(identify, group, feature_enabled, etc.) unless you also import the
original posthog module separately. But this way you only need to
update the import.
"""
{datetime_import}from typing import Any, Dict, Literal, Optional, TypedDict, overload

from typing_extensions import NotRequired, Required, Unpack

import posthog as _posthog
from posthog.args import OptionalCaptureArgs


'''
        map_properties_function = '''

def _map_properties(event: str, properties: Any) -> Any:
    """Map Python property names back to their original names for PostHog."""
    if properties is None or event not in _PROPERTY_MAPPINGS:
        return properties
    mapping = _PROPERTY_MAPPINGS[event]
    return {mapping.get(k, k): v for k, v in properties.items()}

'''

        # Runtime implementation of capture (must immediately follow @overload definitions)
        # Note: The implementation uses a broad type signature that accepts all overload signatures.
        # Type checkers will enforce the specific TypedDict shapes via the @overload definitions.
        capture_implementation = '''

def capture(  # type: ignore[misc]  # mypy doesn't understand overload impl pattern
    event: str,
    **kwargs: Unpack[OptionalCaptureArgs],
) -> Optional[str]:
    """
    Type-safe capture for defined events.

    For defined events, the type checker will validate that required properties
    are provided and that property types match the schema.

    Args:
        event: The event name (type-checked against defined events)
        **kwargs: Capture arguments from posthog.args.OptionalCaptureArgs (including the typed properties)
    Returns:
        The UUID of the captured event, or None if capture failed.
    """
    properties = kwargs.get("properties")
    mapped_properties = _map_properties(event, properties)
    if mapped_properties is not properties:
        new_kwargs = dict(kwargs)
        new_kwargs["properties"] = mapped_properties
        return _posthog.capture(event=event, **new_kwargs)  # type: ignore[arg-type]  # mypy can't infer TypedDict from dict()
    return _posthog.capture(event=event, **kwargs)
'''

        return (
            header
            + property_mappings_section
            + map_properties_function
            + typed_dicts_section
            + overloads_section
            + capture_implementation
        )

    def _generate_typed_dict(
        self, event_name: str, properties: list[SchemaPropertyGroupProperty]
    ) -> tuple[str, dict[str, str]]:
        """
        Generate a TypedDict class for an event's properties.

        Returns:
            A tuple of (typed_dict_code, property_mappings) where property_mappings
            is a dict mapping Python identifiers to original property names (only for
            properties where the name was transformed). This is needed to ensure we map data back correctly
            when calling the API.
        """
        class_name = self._to_class_name(event_name)
        escaped_event_name = self._escape_python_string(event_name)

        if not properties:
            # Event with no schema - accept any properties
            return (
                f'''class {class_name}(TypedDict, total=False):
    """Properties for the `{escaped_event_name}` event (no schema defined)"""
    pass''',
                {},
            )

        lines = [
            f"class {class_name}(TypedDict, total=False):",
            f'    """Properties for the `{escaped_event_name}` event"""',
        ]

        used_names: set[str] = set()
        tracked_property_mappings: dict[str, str] = {}

        # Sort required first and then alphabetically by name.
        sorted_props = sorted(properties, key=lambda p: (not p.is_required, p.name))
        for prop in sorted_props:
            py_type = self._map_property_type(prop.property_type)
            prop_name = self._get_unique_name(self._to_python_identifier(prop.name), used_names)
            wrapper = "Required" if prop.is_required else "NotRequired"
            lines.append(f"    {prop_name}: {wrapper}[{py_type}]")

            if prop_name != prop.name:
                tracked_property_mappings[prop_name] = prop.name

        return "\n".join(lines), tracked_property_mappings

    def _generate_overload(self, event_name: str, properties: list[SchemaPropertyGroupProperty]) -> str:
        class_name = self._to_class_name(event_name)
        escaped_event_name = self._escape_python_string(event_name)
        has_required_property = any(p.is_required for p in properties)
        properties_type = class_name if has_required_property else f"Optional[{class_name}] = ..."

        # type: ignore[misc] suppresses "Overlap between argument names and ** TypedDict items"
        # This is intentional: we want our typed `properties` param to take precedence over
        # the generic one in OptionalCaptureArgs, while still getting type hints for other kwargs
        return f"""@overload
def capture(  # type: ignore[misc]  # This is needed to ensure our typed `properties` take precedence over the SDK kwargs
    event: Literal["{escaped_event_name}"],
    *,
    properties: {properties_type},
    **kwargs: Unpack[OptionalCaptureArgs],
) -> Optional[str]: ..."""

    def _map_property_type(self, property_type: str) -> str:
        """Map PostHog property types to Python types"""
        type_map = {
            "String": "str",
            "Numeric": "float",
            "Boolean": "bool",
            "DateTime": "datetime",
            "Array": "list[Any]",
            "Object": "Dict[str, Any]",
        }
        return type_map.get(property_type, "Any")

    def _to_class_name(self, event_name: str) -> str:
        """
        Convert event name to PascalCase class name.
        Examples: 'downloaded_file' -> 'DownloadedFile', '$pageview' -> 'Pageview'

        Note: It attempts to make the parameters type-safe on an best effort basis
        """
        # Split on non-alphanumeric characters
        parts = re.split(r"[^0-9A-Za-z]+", event_name)
        pascal = "".join(p.capitalize() for p in parts if p)

        if not pascal:
            pascal = "Event"
        if pascal[0].isdigit():
            pascal = "Event" + pascal

        return pascal + "Props"

    def _to_python_identifier(self, prop_name: str) -> str:
        """
        Convert property name to valid Python identifier.
        Examples: 'file-name' -> 'file_name', '123test' -> 'prop_123test'

        Note: It attempts to make the parameters type-safe on an best effort basis
        """
        reserved_keywords = {
            "False",
            "None",
            "True",
            "and",
            "as",
            "assert",
            "async",
            "await",
            "break",
            "class",
            "continue",
            "def",
            "del",
            "elif",
            "else",
            "except",
            "finally",
            "for",
            "from",
            "global",
            "if",
            "import",
            "in",
            "is",
            "lambda",
            "nonlocal",
            "not",
            "or",
            "pass",
            "raise",
            "return",
            "try",
            "while",
            "with",
            "yield",
        }

        # Replace non-alphanumeric with underscore
        identifier = re.sub(r"[^0-9A-Za-z]+", "_", prop_name)
        identifier = identifier.strip("_")
        if not identifier:
            return "value"

        if identifier[0].isdigit():
            identifier = "prop_" + identifier
        if identifier in reserved_keywords:
            identifier = identifier + "_"

        return identifier

    def _get_unique_name(self, base_name: str, used_names: set[str]) -> str:
        """
        Generate a unique name by adding numeric suffixes if there are collisions.

        Examples:
            - First usage: "file_name" → "file_name"
            - Second usage: "file_name" → "file_name_2"
            - Third usage: "file_name" → "file_name_3"
        """
        if base_name not in used_names:
            used_names.add(base_name)
            return base_name

        # Add numeric suffix for collision
        i = 2
        while f"{base_name}_{i}" in used_names:
            i += 1
        unique_name = f"{base_name}_{i}"
        used_names.add(unique_name)
        return unique_name

    def _escape_python_string(self, value: str) -> str:
        """Escape a string for use in Python string literals"""
        return orjson.dumps(value).decode("utf-8")[1:-1]
