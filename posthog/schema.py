# generated by datamodel-codegen:
#   filename:  schema.json

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel
from typing_extensions import Literal


class SchemaRoot(RootModel):
    root: Any


class MathGroupTypeIndex(float, Enum):
    number_0 = 0
    number_1 = 1
    number_2 = 2
    number_3 = 3
    number_4 = 4


class AggregationAxisFormat(str, Enum):
    numeric = "numeric"
    duration = "duration"
    duration_ms = "duration_ms"
    percentage = "percentage"
    percentage_scaled = "percentage_scaled"


class BaseMathType(str, Enum):
    total = "total"
    dau = "dau"
    weekly_active = "weekly_active"
    monthly_active = "monthly_active"
    unique_session = "unique_session"


class BreakdownAttributionType(str, Enum):
    first_touch = "first_touch"
    last_touch = "last_touch"
    all_events = "all_events"
    step = "step"


class BreakdownType(str, Enum):
    cohort = "cohort"
    person = "person"
    event = "event"
    group = "group"
    session = "session"
    hogql = "hogql"


class ChartAxis(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    column: str


class ChartDisplayType(str, Enum):
    ActionsLineGraph = "ActionsLineGraph"
    ActionsLineGraphCumulative = "ActionsLineGraphCumulative"
    ActionsAreaGraph = "ActionsAreaGraph"
    ActionsTable = "ActionsTable"
    ActionsPie = "ActionsPie"
    ActionsBar = "ActionsBar"
    ActionsBarValue = "ActionsBarValue"
    WorldMap = "WorldMap"
    BoldNumber = "BoldNumber"


class CohortPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: Literal["id"] = "id"
    label: Optional[str] = None
    type: Literal["cohort"] = "cohort"
    value: float


class CountPerActorMathType(str, Enum):
    avg_count_per_actor = "avg_count_per_actor"
    min_count_per_actor = "min_count_per_actor"
    max_count_per_actor = "max_count_per_actor"
    median_count_per_actor = "median_count_per_actor"
    p90_count_per_actor = "p90_count_per_actor"
    p95_count_per_actor = "p95_count_per_actor"
    p99_count_per_actor = "p99_count_per_actor"


class DatabaseSchemaQueryResponseField(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    chain: Optional[List[str]] = None
    fields: Optional[List[str]] = None
    key: str
    table: Optional[str] = None
    type: str


class DateRange(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date_from: Optional[str] = None
    date_to: Optional[str] = None


class Key(str, Enum):
    tag_name = "tag_name"
    text = "text"
    href = "href"
    selector = "selector"


class ElementType(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    attr_class: Optional[List[str]] = None
    attr_id: Optional[str] = None
    attributes: Dict[str, str]
    href: Optional[str] = None
    nth_child: Optional[float] = None
    nth_of_type: Optional[float] = None
    order: Optional[float] = None
    tag_name: str
    text: Optional[str] = None


class EmptyPropertyFilter(BaseModel):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class EntityType(str, Enum):
    actions = "actions"
    events = "events"
    new_entity = "new_entity"


class Person(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distinct_ids: List[str]
    is_identified: Optional[bool] = None
    properties: Dict[str, Any]


class EventType(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    distinct_id: str
    elements: List[ElementType]
    elements_chain: Optional[str] = None
    event: str
    id: str
    person: Optional[Person] = None
    properties: Dict[str, Any]
    timestamp: str
    uuid: Optional[str] = None


class Response(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    next: Optional[str] = None
    results: List[EventType]


class Properties(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    email: Optional[str] = None
    name: Optional[str] = None


class EventsQueryPersonColumn(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    created_at: str
    distinct_id: str
    properties: Properties
    uuid: str


class FilterLogicalOperator(str, Enum):
    AND = "AND"
    OR = "OR"


class FunnelConversionWindowTimeUnit(str, Enum):
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"


class FunnelExclusion(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_name: Optional[str] = None
    funnel_from_step: Optional[float] = None
    funnel_to_step: Optional[float] = None
    id: Optional[Union[str, float]] = None
    index: Optional[float] = None
    name: Optional[str] = None
    order: Optional[float] = None
    type: Optional[EntityType] = None


class FunnelLayout(str, Enum):
    horizontal = "horizontal"
    vertical = "vertical"


class FunnelPathType(str, Enum):
    funnel_path_before_step = "funnel_path_before_step"
    funnel_path_between_steps = "funnel_path_between_steps"
    funnel_path_after_step = "funnel_path_after_step"


class FunnelStepReference(str, Enum):
    total = "total"
    previous = "previous"


class FunnelVizType(str, Enum):
    steps = "steps"
    time_to_convert = "time_to_convert"
    trends = "trends"


class GoalLine(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: str
    value: float


class HogQLNotice(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end: Optional[int] = None
    fix: Optional[str] = None
    message: str
    start: Optional[int] = None


class InCohortVia(str, Enum):
    leftjoin = "leftjoin"
    subquery = "subquery"


class MaterializationMode(str, Enum):
    auto = "auto"
    legacy_null_as_string = "legacy_null_as_string"
    legacy_null_as_null = "legacy_null_as_null"
    disabled = "disabled"


class PersonsArgMaxVersion(str, Enum):
    auto = "auto"
    v1 = "v1"
    v2 = "v2"


class PersonsOnEventsMode(str, Enum):
    disabled = "disabled"
    v1_enabled = "v1_enabled"
    v1_mixed = "v1_mixed"
    v2_enabled = "v2_enabled"


class HogQLQueryModifiers(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    inCohortVia: Optional[InCohortVia] = None
    materializationMode: Optional[MaterializationMode] = None
    personsArgMaxVersion: Optional[PersonsArgMaxVersion] = None
    personsOnEventsMode: Optional[PersonsOnEventsMode] = None


class InsightFilterProperty(str, Enum):
    trendsFilter = "trendsFilter"
    funnelsFilter = "funnelsFilter"
    retentionFilter = "retentionFilter"
    pathsFilter = "pathsFilter"
    stickinessFilter = "stickinessFilter"
    lifecycleFilter = "lifecycleFilter"


class InsightNodeKind(str, Enum):
    TrendsQuery = "TrendsQuery"
    FunnelsQuery = "FunnelsQuery"
    RetentionQuery = "RetentionQuery"
    PathsQuery = "PathsQuery"
    StickinessQuery = "StickinessQuery"
    LifecycleQuery = "LifecycleQuery"


class InsightType(str, Enum):
    TRENDS = "TRENDS"
    STICKINESS = "STICKINESS"
    LIFECYCLE = "LIFECYCLE"
    FUNNELS = "FUNNELS"
    RETENTION = "RETENTION"
    PATHS = "PATHS"
    JSON = "JSON"
    SQL = "SQL"


class IntervalType(str, Enum):
    hour = "hour"
    day = "day"
    week = "week"
    month = "month"


class LifecycleToggle(str, Enum):
    new = "new"
    resurrecting = "resurrecting"
    returning = "returning"
    dormant = "dormant"


class NodeKind(str, Enum):
    EventsNode = "EventsNode"
    ActionsNode = "ActionsNode"
    EventsQuery = "EventsQuery"
    PersonsNode = "PersonsNode"
    HogQLQuery = "HogQLQuery"
    HogQLMetadata = "HogQLMetadata"
    PersonsQuery = "PersonsQuery"
    SessionsTimelineQuery = "SessionsTimelineQuery"
    DataTableNode = "DataTableNode"
    DataVisualizationNode = "DataVisualizationNode"
    SavedInsightNode = "SavedInsightNode"
    InsightVizNode = "InsightVizNode"
    TrendsQuery = "TrendsQuery"
    FunnelsQuery = "FunnelsQuery"
    RetentionQuery = "RetentionQuery"
    PathsQuery = "PathsQuery"
    StickinessQuery = "StickinessQuery"
    LifecycleQuery = "LifecycleQuery"
    InsightPersonsQuery = "InsightPersonsQuery"
    WebOverviewQuery = "WebOverviewQuery"
    WebTopClicksQuery = "WebTopClicksQuery"
    WebStatsTableQuery = "WebStatsTableQuery"
    TimeToSeeDataSessionsQuery = "TimeToSeeDataSessionsQuery"
    TimeToSeeDataQuery = "TimeToSeeDataQuery"
    TimeToSeeDataSessionsJSONNode = "TimeToSeeDataSessionsJSONNode"
    TimeToSeeDataSessionsWaterfallNode = "TimeToSeeDataSessionsWaterfallNode"
    DatabaseSchemaQuery = "DatabaseSchemaQuery"


class PathCleaningFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    alias: Optional[str] = None
    regex: Optional[str] = None


class PathType(str, Enum):
    field_pageview = "$pageview"
    field_screen = "$screen"
    custom_event = "custom_event"
    hogql = "hogql"


class PathsFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    edge_limit: Optional[float] = None
    end_point: Optional[str] = None
    exclude_events: Optional[List[str]] = None
    funnel_filter: Optional[Dict[str, Any]] = None
    funnel_paths: Optional[FunnelPathType] = None
    include_event_types: Optional[List[PathType]] = None
    local_path_cleaning_filters: Optional[List[PathCleaningFilter]] = None
    max_edge_weight: Optional[float] = None
    min_edge_weight: Optional[float] = None
    path_groupings: Optional[List[str]] = None
    path_replacements: Optional[bool] = None
    path_type: Optional[PathType] = None
    paths_hogql_expression: Optional[str] = None
    start_point: Optional[str] = None
    step_limit: Optional[float] = None


class PropertyFilterType(str, Enum):
    meta = "meta"
    event = "event"
    person = "person"
    element = "element"
    feature = "feature"
    session = "session"
    cohort = "cohort"
    recording = "recording"
    group = "group"
    hogql = "hogql"


class PropertyMathType(str, Enum):
    avg = "avg"
    sum = "sum"
    min = "min"
    max = "max"
    median = "median"
    p90 = "p90"
    p95 = "p95"
    p99 = "p99"


class PropertyOperator(str, Enum):
    exact = "exact"
    is_not = "is_not"
    icontains = "icontains"
    not_icontains = "not_icontains"
    regex = "regex"
    not_regex = "not_regex"
    gt = "gt"
    gte = "gte"
    lt = "lt"
    lte = "lte"
    is_set = "is_set"
    is_not_set = "is_not_set"
    is_date_exact = "is_date_exact"
    is_date_before = "is_date_before"
    is_date_after = "is_date_after"
    between = "between"
    not_between = "not_between"
    min = "min"
    max = "max"


class QueryStatus(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    complete: Optional[bool] = False
    end_time: Optional[datetime] = None
    error: Optional[bool] = False
    error_message: Optional[str] = ""
    expiration_time: Optional[datetime] = None
    id: str
    query_async: Optional[bool] = True
    results: Optional[Any] = None
    start_time: Optional[datetime] = None
    task_id: Optional[str] = None
    team_id: int


class QueryTiming(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    k: str = Field(..., description="Key. Shortened to 'k' to save on data.")
    t: float = Field(..., description="Time in seconds. Shortened to 't' to save on data.")


class RecordingDurationFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: Literal["duration"] = "duration"
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["recording"] = "recording"
    value: float


class Kind(str, Enum):
    ActionsNode = "ActionsNode"
    EventsNode = "EventsNode"


class RetentionEntity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_name: Optional[str] = None
    id: Optional[Union[str, float]] = None
    kind: Optional[Kind] = None
    name: Optional[str] = None
    order: Optional[float] = None
    type: Optional[EntityType] = None
    uuid: Optional[str] = None


class RetentionReference(str, Enum):
    total = "total"
    previous = "previous"


class RetentionPeriod(str, Enum):
    Hour = "Hour"
    Day = "Day"
    Week = "Week"
    Month = "Month"


class RetentionType(str, Enum):
    retention_recurring = "retention_recurring"
    retention_first_time = "retention_first_time"


class RetentionValue(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    count: int


class SessionPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: Literal["$session_duration"] = "$session_duration"
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["session"] = "session"
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class StepOrderValue(str, Enum):
    strict = "strict"
    unordered = "unordered"
    ordered = "ordered"


class StickinessFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    compare: Optional[bool] = None
    display: Optional[ChartDisplayType] = None
    hidden_legend_indexes: Optional[List[float]] = None
    show_legend: Optional[bool] = None
    show_values_on_series: Optional[bool] = None


class TimeToSeeDataQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: Literal["TimeToSeeDataQuery"] = "TimeToSeeDataQuery"
    response: Optional[Dict[str, Any]] = Field(default=None, description="Cached query response")
    sessionEnd: Optional[str] = None
    sessionId: Optional[str] = Field(default=None, description="Project to filter on. Defaults to current session")
    sessionStart: Optional[str] = Field(
        default=None, description="Session start time. Defaults to current time - 2 hours"
    )
    teamId: Optional[float] = Field(default=None, description="Project to filter on. Defaults to current project")


class TimeToSeeDataSessionsQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    results: List[Dict[str, Any]]


class TimeToSeeDataWaterfallNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: Literal["TimeToSeeDataSessionsWaterfallNode"] = "TimeToSeeDataSessionsWaterfallNode"
    source: TimeToSeeDataQuery


class TimelineEntry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[EventType]
    recording_duration_s: Optional[float] = Field(default=None, description="Duration of the recording in seconds.")
    sessionId: Optional[str] = Field(default=None, description="Session ID. None means out-of-session events")


class TrendsFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_axis_format: Optional[AggregationAxisFormat] = None
    aggregation_axis_postfix: Optional[str] = None
    aggregation_axis_prefix: Optional[str] = None
    breakdown_histogram_bin_count: Optional[float] = None
    compare: Optional[bool] = None
    decimal_places: Optional[float] = None
    display: Optional[ChartDisplayType] = None
    formula: Optional[str] = None
    hidden_legend_indexes: Optional[List[float]] = None
    show_labels_on_series: Optional[bool] = None
    show_legend: Optional[bool] = None
    show_percent_stack_view: Optional[bool] = None
    show_values_on_series: Optional[bool] = None
    smoothing_intervals: Optional[float] = None


class TrendsQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List[Dict[str, Any]]
    timings: Optional[List[QueryTiming]] = None


class ActionsPie(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    disableHoverOffset: Optional[bool] = None
    hideAggregation: Optional[bool] = None


class RETENTION(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hideLineGraph: Optional[bool] = None
    hideSizeColumn: Optional[bool] = None
    useSmallLayout: Optional[bool] = None


class VizSpecificOptions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ActionsPie: Optional[ActionsPie] = None
    RETENTION: Optional[RETENTION] = None


class Kind1(str, Enum):
    unit = "unit"
    duration_s = "duration_s"
    percentage = "percentage"


class WebOverviewItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    changeFromPreviousPct: Optional[float] = None
    isIncreaseBad: Optional[bool] = None
    key: str
    kind: Kind1
    previous: Optional[float] = None
    value: Optional[float] = None


class WebOverviewQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List[WebOverviewItem]
    timings: Optional[List[QueryTiming]] = None


class WebStatsBreakdown(str, Enum):
    Page = "Page"
    InitialPage = "InitialPage"
    InitialChannelType = "InitialChannelType"
    InitialReferringDomain = "InitialReferringDomain"
    InitialUTMSource = "InitialUTMSource"
    InitialUTMCampaign = "InitialUTMCampaign"
    InitialUTMMedium = "InitialUTMMedium"
    InitialUTMTerm = "InitialUTMTerm"
    InitialUTMContent = "InitialUTMContent"
    Browser = "Browser"
    OS = "OS"
    DeviceType = "DeviceType"
    Country = "Country"
    Region = "Region"
    City = "City"


class WebStatsTableQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    columns: Optional[List] = None
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List
    timings: Optional[List[QueryTiming]] = None
    types: Optional[List] = None


class WebTopClicksQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    columns: Optional[List] = None
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List
    timings: Optional[List[QueryTiming]] = None
    types: Optional[List] = None


class AnyResponseTypeItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    next: Optional[str] = None
    results: List[EventType]


class Breakdown(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    normalize_url: Optional[bool] = None
    property: Union[str, float]
    type: BreakdownType


class BreakdownFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    breakdown: Optional[Union[str, float, List[Union[str, float]]]] = None
    breakdown_group_type_index: Optional[float] = None
    breakdown_hide_other_aggregation: Optional[bool] = None
    breakdown_histogram_bin_count: Optional[float] = None
    breakdown_limit: Optional[float] = None
    breakdown_normalize_url: Optional[bool] = None
    breakdown_type: Optional[BreakdownType] = None
    breakdowns: Optional[List[Breakdown]] = None


class DataNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: NodeKind
    response: Optional[Dict[str, Any]] = Field(default=None, description="Cached query response")


class ChartSettings(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    goalLines: Optional[List[GoalLine]] = None
    xAxis: Optional[ChartAxis] = None
    yAxis: Optional[List[ChartAxis]] = None


class ElementPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: Key
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["element"] = "element"
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class EventPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: str
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["event"] = Field(default="event", description="Event properties")
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class EventsQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    columns: List
    hasMore: Optional[bool] = None
    hogql: str
    limit: int
    offset: int
    results: List[List]
    timings: Optional[List[QueryTiming]] = None
    types: List[str]


class FeaturePropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: str
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["feature"] = Field(default="feature", description='Event property with "$feature/" prepended')
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class FunnelsFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bin_count: Optional[Union[float, str]] = None
    breakdown_attribution_type: Optional[BreakdownAttributionType] = None
    breakdown_attribution_value: Optional[float] = None
    exclusions: Optional[List[FunnelExclusion]] = None
    funnel_aggregate_by_hogql: Optional[str] = None
    funnel_from_step: Optional[float] = None
    funnel_order_type: Optional[StepOrderValue] = None
    funnel_step_reference: Optional[FunnelStepReference] = None
    funnel_to_step: Optional[float] = None
    funnel_viz_type: Optional[FunnelVizType] = None
    funnel_window_interval: Optional[float] = None
    funnel_window_interval_unit: Optional[FunnelConversionWindowTimeUnit] = None
    hidden_legend_breakdowns: Optional[List[str]] = None
    layout: Optional[FunnelLayout] = None


class GroupPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    group_type_index: Optional[float] = None
    key: str
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["group"] = "group"
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class HogQLMetadataResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    errors: List[HogQLNotice]
    inputExpr: Optional[str] = None
    inputSelect: Optional[str] = None
    isValid: Optional[bool] = None
    isValidView: Optional[bool] = None
    notices: List[HogQLNotice]
    warnings: List[HogQLNotice]


class HogQLPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: str
    label: Optional[str] = None
    type: Literal["hogql"] = "hogql"
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class HogQLQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    clickhouse: Optional[str] = Field(default=None, description="Executed ClickHouse query")
    columns: Optional[List] = Field(default=None, description="Returned columns")
    error: Optional[str] = Field(
        default=None, description="Query error. Returned only if 'explain' is true. Throws an error otherwise."
    )
    explain: Optional[List[str]] = Field(default=None, description="Query explanation output")
    hogql: Optional[str] = Field(default=None, description="Generated HogQL query")
    modifiers: Optional[HogQLQueryModifiers] = Field(
        default=None, description="Modifiers used when performing the query"
    )
    query: Optional[str] = Field(default=None, description="Input query string")
    results: Optional[List] = Field(default=None, description="Query results")
    timings: Optional[List[QueryTiming]] = Field(
        default=None, description="Measured timings for different parts of the query generation process"
    )
    types: Optional[List] = Field(default=None, description="Types of returned columns")


class LifecycleFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    show_values_on_series: Optional[bool] = None
    toggledLifecycles: Optional[List[LifecycleToggle]] = None


class LifecycleQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List[Dict[str, Any]]
    timings: Optional[List[QueryTiming]] = None


class Node(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: NodeKind


class PersonPropertyFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    key: str
    label: Optional[str] = None
    operator: PropertyOperator
    type: Literal["person"] = Field(default="person", description="Person properties")
    value: Optional[Union[str, float, List[Union[str, float]]]] = None


class PersonsQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    columns: List
    hasMore: Optional[bool] = None
    hogql: str
    limit: int
    missing_actors_count: Optional[int] = None
    offset: int
    results: List[List]
    timings: Optional[List[QueryTiming]] = None
    types: List[str]


class QueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List
    timings: Optional[List[QueryTiming]] = None


class RetentionFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    period: Optional[RetentionPeriod] = None
    retention_reference: Optional[RetentionReference] = None
    retention_type: Optional[RetentionType] = None
    returning_entity: Optional[RetentionEntity] = None
    target_entity: Optional[RetentionEntity] = None
    total_intervals: Optional[int] = None


class RetentionResult(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date: datetime
    label: str
    values: List[RetentionValue]


class SavedInsightNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    allowSorting: Optional[bool] = Field(
        default=None, description="Can the user click on column headers to sort the table? (default: true)"
    )
    embedded: Optional[bool] = Field(default=None, description="Query is embedded inside another bordered component")
    expandable: Optional[bool] = Field(
        default=None, description="Can expand row to show raw event data (default: true)"
    )
    full: Optional[bool] = Field(
        default=None, description="Show with most visual options enabled. Used in insight scene."
    )
    hidePersonsModal: Optional[bool] = None
    kind: Literal["SavedInsightNode"] = "SavedInsightNode"
    propertiesViaUrl: Optional[bool] = Field(default=None, description="Link properties via the URL (default: false)")
    shortId: str
    showActions: Optional[bool] = Field(default=None, description="Show the kebab menu at the end of the row")
    showColumnConfigurator: Optional[bool] = Field(
        default=None, description="Show a button to configure the table's columns if possible"
    )
    showCorrelationTable: Optional[bool] = None
    showDateRange: Optional[bool] = Field(default=None, description="Show date range selector")
    showElapsedTime: Optional[bool] = Field(default=None, description="Show the time it takes to run a query")
    showEventFilter: Optional[bool] = Field(
        default=None, description="Include an event filter above the table (EventsNode only)"
    )
    showExport: Optional[bool] = Field(default=None, description="Show the export button")
    showFilters: Optional[bool] = None
    showHeader: Optional[bool] = None
    showHogQLEditor: Optional[bool] = Field(default=None, description="Include a HogQL query editor above HogQL tables")
    showLastComputation: Optional[bool] = None
    showLastComputationRefresh: Optional[bool] = None
    showOpenEditorButton: Optional[bool] = Field(
        default=None, description="Show a button to open the current query as a new insight. (default: true)"
    )
    showPersistentColumnConfigurator: Optional[bool] = Field(
        default=None, description="Show a button to configure and persist the table's default columns if possible"
    )
    showPropertyFilter: Optional[bool] = Field(default=None, description="Include a property filter above the table")
    showReload: Optional[bool] = Field(default=None, description="Show a reload button")
    showResults: Optional[bool] = None
    showResultsTable: Optional[bool] = Field(default=None, description="Show a results table")
    showSavedQueries: Optional[bool] = Field(default=None, description="Shows a list of saved queries")
    showSearch: Optional[bool] = Field(default=None, description="Include a free text search field (PersonsNode only)")
    showTable: Optional[bool] = None
    showTimings: Optional[bool] = Field(default=None, description="Show a detailed query timing breakdown")
    suppressSessionAnalysisWarning: Optional[bool] = None
    vizSpecificOptions: Optional[VizSpecificOptions] = None


class SessionsTimelineQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hasMore: Optional[bool] = None
    hogql: Optional[str] = None
    results: List[TimelineEntry]
    timings: Optional[List[QueryTiming]] = None


class TimeToSeeDataJSONNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: Literal["TimeToSeeDataSessionsJSONNode"] = "TimeToSeeDataSessionsJSONNode"
    source: TimeToSeeDataQuery


class TimeToSeeDataNode(RootModel):
    root: Union[TimeToSeeDataJSONNode, TimeToSeeDataWaterfallNode]


class TimeToSeeDataSessionsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    kind: Literal["TimeToSeeDataSessionsQuery"] = "TimeToSeeDataSessionsQuery"
    response: Optional[TimeToSeeDataSessionsQueryResponse] = Field(default=None, description="Cached query response")
    teamId: Optional[float] = Field(default=None, description="Project to filter on. Defaults to current project")


class WebAnalyticsQueryBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = None
    properties: List[Union[EventPropertyFilter, PersonPropertyFilter]]


class WebOverviewQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = None
    kind: Literal["WebOverviewQuery"] = "WebOverviewQuery"
    properties: List[Union[EventPropertyFilter, PersonPropertyFilter]]
    response: Optional[WebOverviewQueryResponse] = None


class WebStatsTableQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    breakdownBy: WebStatsBreakdown
    dateRange: Optional[DateRange] = None
    includeScrollDepth: Optional[bool] = None
    kind: Literal["WebStatsTableQuery"] = "WebStatsTableQuery"
    properties: List[Union[EventPropertyFilter, PersonPropertyFilter]]
    response: Optional[WebStatsTableQueryResponse] = None


class WebTopClicksQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = None
    kind: Literal["WebTopClicksQuery"] = "WebTopClicksQuery"
    properties: List[Union[EventPropertyFilter, PersonPropertyFilter]]
    response: Optional[WebTopClicksQueryResponse] = None


class AnyResponseType(RootModel):
    root: Union[
        Dict[str, Any], HogQLQueryResponse, HogQLMetadataResponse, Union[AnyResponseTypeItem, Any], EventsQueryResponse
    ]


class DashboardFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    date_from: Optional[str] = None
    date_to: Optional[str] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = None


class DatabaseSchemaQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    kind: Literal["DatabaseSchemaQuery"] = "DatabaseSchemaQuery"
    response: Optional[Dict[str, List[DatabaseSchemaQueryResponseField]]] = Field(
        default=None, description="Cached query response"
    )


class EntityNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_name: Optional[str] = None
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(
        default=None,
        description="Fixed properties in the query, can't be edited in the interface (e.g. scoping down by person)",
    )
    kind: NodeKind
    math: Optional[
        Union[BaseMathType, PropertyMathType, CountPerActorMathType, Literal["unique_group"], Literal["hogql"]]
    ] = None
    math_group_type_index: Optional[MathGroupTypeIndex] = None
    math_hogql: Optional[str] = None
    math_property: Optional[str] = None
    name: Optional[str] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(default=None, description="Properties configurable in the interface")
    response: Optional[Dict[str, Any]] = Field(default=None, description="Cached query response")


class EventsNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_name: Optional[str] = None
    event: Optional[str] = Field(default=None, description="The event or `null` for all events.")
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(
        default=None,
        description="Fixed properties in the query, can't be edited in the interface (e.g. scoping down by person)",
    )
    kind: Literal["EventsNode"] = "EventsNode"
    limit: Optional[float] = None
    math: Optional[
        Union[BaseMathType, PropertyMathType, CountPerActorMathType, Literal["unique_group"], Literal["hogql"]]
    ] = None
    math_group_type_index: Optional[MathGroupTypeIndex] = None
    math_hogql: Optional[str] = None
    math_property: Optional[str] = None
    name: Optional[str] = None
    orderBy: Optional[List[str]] = Field(default=None, description="Columns to order by")
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(default=None, description="Properties configurable in the interface")
    response: Optional[Response] = Field(default=None, description="Return a limited set of data")


class EventsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    actionId: Optional[int] = Field(default=None, description="Show events matching a given action")
    after: Optional[str] = Field(default=None, description="Only fetch events that happened after this timestamp")
    before: Optional[str] = Field(default=None, description="Only fetch events that happened before this timestamp")
    event: Optional[str] = Field(default=None, description="Limit to events matching this string")
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(
        default=None,
        description="Fixed properties in the query, can't be edited in the interface (e.g. scoping down by person)",
    )
    kind: Literal["EventsQuery"] = "EventsQuery"
    limit: Optional[int] = Field(default=None, description="Number of rows to return")
    offset: Optional[int] = Field(default=None, description="Number of rows to skip before returning rows")
    orderBy: Optional[List[str]] = Field(default=None, description="Columns to order by")
    personId: Optional[str] = Field(default=None, description="Show events for a given person")
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(default=None, description="Properties configurable in the interface")
    response: Optional[EventsQueryResponse] = Field(default=None, description="Cached query response")
    select: List[str] = Field(..., description="Return a limited set of data. Required.")
    where: Optional[List[str]] = Field(default=None, description="HogQL filters to apply on returned data")


class HogQLFilters(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = None


class HogQLMetadata(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expr: Optional[str] = Field(
        default=None, description="HogQL expression to validate (use `select` or `expr`, but not both)"
    )
    filters: Optional[HogQLFilters] = None
    kind: Literal["HogQLMetadata"] = "HogQLMetadata"
    response: Optional[HogQLMetadataResponse] = Field(default=None, description="Cached query response")
    select: Optional[str] = Field(
        default=None, description="Full select query to validate (use `select` or `expr`, but not both)"
    )
    table: Optional[str] = Field(default=None, description="Table to validate the expression against")


class HogQLQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    explain: Optional[bool] = None
    filters: Optional[HogQLFilters] = None
    kind: Literal["HogQLQuery"] = "HogQLQuery"
    modifiers: Optional[HogQLQueryModifiers] = None
    query: str
    response: Optional[HogQLQueryResponse] = Field(default=None, description="Cached query response")
    values: Optional[Dict[str, Any]] = Field(
        default=None, description="Constant values that can be referenced with the {placeholder} syntax in the query"
    )


class InsightFilter(RootModel):
    root: Union[TrendsFilter, FunnelsFilter, RetentionFilter, PathsFilter, StickinessFilter, LifecycleFilter]


class PersonsNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cohort: Optional[float] = None
    distinctId: Optional[str] = None
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(
        default=None,
        description="Fixed properties in the query, can't be edited in the interface (e.g. scoping down by person)",
    )
    kind: Literal["PersonsNode"] = "PersonsNode"
    limit: Optional[float] = None
    offset: Optional[float] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(default=None, description="Properties configurable in the interface")
    response: Optional[Dict[str, Any]] = Field(default=None, description="Cached query response")
    search: Optional[str] = None


class PropertyGroupFilterValue(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: FilterLogicalOperator
    values: List[
        Union[
            PropertyGroupFilterValue,
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ],
        ]
    ]


class RetentionQueryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    hogql: Optional[str] = None
    is_cached: Optional[bool] = None
    last_refresh: Optional[str] = None
    next_allowed_client_refresh: Optional[str] = None
    results: List[RetentionResult]
    timings: Optional[List[QueryTiming]] = None


class SessionsTimelineQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    after: Optional[str] = Field(
        default=None, description="Only fetch sessions that started after this timestamp (default: '-24h')"
    )
    before: Optional[str] = Field(
        default=None, description="Only fetch sessions that started before this timestamp (default: '+5s')"
    )
    kind: Literal["SessionsTimelineQuery"] = "SessionsTimelineQuery"
    personId: Optional[str] = Field(default=None, description="Fetch sessions only for a given person")
    response: Optional[SessionsTimelineQueryResponse] = Field(default=None, description="Cached query response")


class ActionsNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custom_name: Optional[str] = None
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(
        default=None,
        description="Fixed properties in the query, can't be edited in the interface (e.g. scoping down by person)",
    )
    id: float
    kind: Literal["ActionsNode"] = "ActionsNode"
    math: Optional[
        Union[BaseMathType, PropertyMathType, CountPerActorMathType, Literal["unique_group"], Literal["hogql"]]
    ] = None
    math_group_type_index: Optional[MathGroupTypeIndex] = None
    math_hogql: Optional[str] = None
    math_property: Optional[str] = None
    name: Optional[str] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = Field(default=None, description="Properties configurable in the interface")
    response: Optional[Dict[str, Any]] = Field(default=None, description="Cached query response")


class DataVisualizationNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    chartSettings: Optional[ChartSettings] = None
    display: Optional[ChartDisplayType] = None
    kind: Literal["DataVisualizationNode"] = "DataVisualizationNode"
    source: HogQLQuery


class HasPropertiesNode(RootModel):
    root: Union[EventsNode, EventsQuery, PersonsNode]


class PropertyGroupFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: FilterLogicalOperator
    values: List[PropertyGroupFilterValue]


class RetentionQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_group_type_index: Optional[int] = Field(default=None, description="Groups aggregation")
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    kind: Literal["RetentionQuery"] = "RetentionQuery"
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    response: Optional[RetentionQueryResponse] = None
    retentionFilter: RetentionFilter = Field(..., description="Properties specific to the retention insight")
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")


class StickinessQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    interval: Optional[IntervalType] = Field(
        default=None, description="Granularity of the response. Can be one of `hour`, `day`, `week` or `month`"
    )
    kind: Literal["StickinessQuery"] = "StickinessQuery"
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")
    series: List[Union[EventsNode, ActionsNode]] = Field(..., description="Events and actions to include")
    stickinessFilter: Optional[StickinessFilter] = Field(
        default=None, description="Properties specific to the stickiness insight"
    )


class TrendsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_group_type_index: Optional[int] = Field(default=None, description="Groups aggregation")
    breakdown: Optional[BreakdownFilter] = Field(default=None, description="Breakdown of the events and actions")
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    interval: Optional[IntervalType] = Field(
        default=None, description="Granularity of the response. Can be one of `hour`, `day`, `week` or `month`"
    )
    kind: Literal["TrendsQuery"] = "TrendsQuery"
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    response: Optional[TrendsQueryResponse] = None
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")
    series: List[Union[EventsNode, ActionsNode]] = Field(..., description="Events and actions to include")
    trendsFilter: Optional[TrendsFilter] = Field(default=None, description="Properties specific to the trends insight")


class FilterType(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    actions: Optional[List[Dict[str, Any]]] = None
    aggregation_group_type_index: Optional[float] = None
    breakdown: Optional[Union[str, float, List[Union[str, float]]]] = None
    breakdown_group_type_index: Optional[float] = None
    breakdown_hide_other_aggregation: Optional[bool] = None
    breakdown_normalize_url: Optional[bool] = None
    breakdown_type: Optional[BreakdownType] = None
    breakdowns: Optional[List[Breakdown]] = None
    date_from: Optional[str] = None
    date_to: Optional[str] = None
    entity_id: Optional[Union[str, float]] = None
    entity_math: Optional[str] = None
    entity_type: Optional[EntityType] = None
    events: Optional[List[Dict[str, Any]]] = None
    explicit_date: Optional[Union[bool, str]] = Field(
        default=None,
        description='Whether the `date_from` and `date_to` should be used verbatim. Disables rounding to the start and end of period. Strings are cast to bools, e.g. "true" -> true.',
    )
    filter_test_accounts: Optional[bool] = None
    from_dashboard: Optional[Union[bool, float]] = None
    insight: Optional[InsightType] = None
    interval: Optional[IntervalType] = None
    new_entity: Optional[List[Dict[str, Any]]] = None
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = None
    sampling_factor: Optional[float] = None


class FunnelsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_group_type_index: Optional[int] = Field(default=None, description="Groups aggregation")
    breakdown: Optional[BreakdownFilter] = Field(default=None, description="Breakdown of the events and actions")
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    funnelsFilter: Optional[FunnelsFilter] = Field(
        default=None, description="Properties specific to the funnels insight"
    )
    interval: Optional[IntervalType] = Field(
        default=None, description="Granularity of the response. Can be one of `hour`, `day`, `week` or `month`"
    )
    kind: Literal["FunnelsQuery"] = "FunnelsQuery"
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")
    series: List[Union[EventsNode, ActionsNode]] = Field(..., description="Events and actions to include")


class InsightsQueryBase(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_group_type_index: Optional[int] = Field(default=None, description="Groups aggregation")
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    kind: NodeKind
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")


class LifecycleQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    interval: Optional[IntervalType] = Field(
        default=None, description="Granularity of the response. Can be one of `hour`, `day`, `week` or `month`"
    )
    kind: Literal["LifecycleQuery"] = "LifecycleQuery"
    lifecycleFilter: Optional[LifecycleFilter] = Field(
        default=None, description="Properties specific to the lifecycle insight"
    )
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    response: Optional[LifecycleQueryResponse] = None
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")
    series: List[Union[EventsNode, ActionsNode]] = Field(..., description="Events and actions to include")


class NamedParametersTypeofDateRangeForFilter(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    source: Optional[FilterType] = None


class PathsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregation_group_type_index: Optional[int] = Field(default=None, description="Groups aggregation")
    dateRange: Optional[DateRange] = Field(default=None, description="Date range for the query")
    filterTestAccounts: Optional[bool] = Field(
        default=None, description="Exclude internal and test users by applying the respective filters"
    )
    kind: Literal["PathsQuery"] = "PathsQuery"
    pathsFilter: Optional[PathsFilter] = Field(default=None, description="Properties specific to the paths insight")
    properties: Optional[
        Union[
            List[
                Union[
                    EventPropertyFilter,
                    PersonPropertyFilter,
                    ElementPropertyFilter,
                    SessionPropertyFilter,
                    CohortPropertyFilter,
                    RecordingDurationFilter,
                    GroupPropertyFilter,
                    FeaturePropertyFilter,
                    HogQLPropertyFilter,
                    EmptyPropertyFilter,
                ]
            ],
            PropertyGroupFilter,
        ]
    ] = Field(default=None, description="Property filters for all series")
    samplingFactor: Optional[float] = Field(default=None, description="Sampling rate")


class InsightVizNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    embedded: Optional[bool] = Field(default=None, description="Query is embedded inside another bordered component")
    full: Optional[bool] = Field(
        default=None, description="Show with most visual options enabled. Used in insight scene."
    )
    hidePersonsModal: Optional[bool] = None
    kind: Literal["InsightVizNode"] = "InsightVizNode"
    showCorrelationTable: Optional[bool] = None
    showFilters: Optional[bool] = None
    showHeader: Optional[bool] = None
    showLastComputation: Optional[bool] = None
    showLastComputationRefresh: Optional[bool] = None
    showResults: Optional[bool] = None
    showTable: Optional[bool] = None
    source: Union[TrendsQuery, FunnelsQuery, RetentionQuery, PathsQuery, StickinessQuery, LifecycleQuery]
    suppressSessionAnalysisWarning: Optional[bool] = None
    vizSpecificOptions: Optional[VizSpecificOptions] = None


class InsightPersonsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    day: Optional[str] = None
    interval: Optional[int] = Field(
        default=None, description="An interval selected out of available intervals in source query"
    )
    kind: Literal["InsightPersonsQuery"] = "InsightPersonsQuery"
    response: Optional[PersonsQueryResponse] = None
    source: Union[TrendsQuery, FunnelsQuery, RetentionQuery, PathsQuery, StickinessQuery, LifecycleQuery]
    status: Optional[str] = None


class PersonsQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fixedProperties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = None
    kind: Literal["PersonsQuery"] = "PersonsQuery"
    limit: Optional[int] = None
    offset: Optional[int] = None
    orderBy: Optional[List[str]] = None
    properties: Optional[
        List[
            Union[
                EventPropertyFilter,
                PersonPropertyFilter,
                ElementPropertyFilter,
                SessionPropertyFilter,
                CohortPropertyFilter,
                RecordingDurationFilter,
                GroupPropertyFilter,
                FeaturePropertyFilter,
                HogQLPropertyFilter,
                EmptyPropertyFilter,
            ]
        ]
    ] = None
    response: Optional[PersonsQueryResponse] = Field(default=None, description="Cached query response")
    search: Optional[str] = None
    select: Optional[List[str]] = None
    source: Optional[Union[InsightPersonsQuery, HogQLQuery]] = None


class DataTableNode(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    allowSorting: Optional[bool] = Field(
        default=None, description="Can the user click on column headers to sort the table? (default: true)"
    )
    columns: Optional[List[str]] = Field(
        default=None, description="Columns shown in the table, unless the `source` provides them."
    )
    embedded: Optional[bool] = Field(default=None, description="Uses the embedded version of LemonTable")
    expandable: Optional[bool] = Field(
        default=None, description="Can expand row to show raw event data (default: true)"
    )
    full: Optional[bool] = Field(default=None, description="Show with most visual options enabled. Used in scenes.")
    hiddenColumns: Optional[List[str]] = Field(
        default=None, description="Columns that aren't shown in the table, even if in columns or returned data"
    )
    kind: Literal["DataTableNode"] = "DataTableNode"
    propertiesViaUrl: Optional[bool] = Field(default=None, description="Link properties via the URL (default: false)")
    showActions: Optional[bool] = Field(default=None, description="Show the kebab menu at the end of the row")
    showColumnConfigurator: Optional[bool] = Field(
        default=None, description="Show a button to configure the table's columns if possible"
    )
    showDateRange: Optional[bool] = Field(default=None, description="Show date range selector")
    showElapsedTime: Optional[bool] = Field(default=None, description="Show the time it takes to run a query")
    showEventFilter: Optional[bool] = Field(
        default=None, description="Include an event filter above the table (EventsNode only)"
    )
    showExport: Optional[bool] = Field(default=None, description="Show the export button")
    showHogQLEditor: Optional[bool] = Field(default=None, description="Include a HogQL query editor above HogQL tables")
    showOpenEditorButton: Optional[bool] = Field(
        default=None, description="Show a button to open the current query as a new insight. (default: true)"
    )
    showPersistentColumnConfigurator: Optional[bool] = Field(
        default=None, description="Show a button to configure and persist the table's default columns if possible"
    )
    showPropertyFilter: Optional[bool] = Field(default=None, description="Include a property filter above the table")
    showReload: Optional[bool] = Field(default=None, description="Show a reload button")
    showResultsTable: Optional[bool] = Field(default=None, description="Show a results table")
    showSavedQueries: Optional[bool] = Field(default=None, description="Shows a list of saved queries")
    showSearch: Optional[bool] = Field(default=None, description="Include a free text search field (PersonsNode only)")
    showTimings: Optional[bool] = Field(default=None, description="Show a detailed query timing breakdown")
    source: Union[
        EventsNode,
        EventsQuery,
        PersonsNode,
        PersonsQuery,
        HogQLQuery,
        TimeToSeeDataSessionsQuery,
        WebOverviewQuery,
        WebStatsTableQuery,
        WebTopClicksQuery,
    ] = Field(..., description="Source of the events")


class QuerySchema(RootModel):
    root: Union[
        DataVisualizationNode,
        DataTableNode,
        SavedInsightNode,
        InsightVizNode,
        TrendsQuery,
        FunnelsQuery,
        RetentionQuery,
        PathsQuery,
        StickinessQuery,
        LifecycleQuery,
        TimeToSeeDataSessionsQuery,
        DatabaseSchemaQuery,
        Union[
            EventsNode,
            ActionsNode,
            PersonsNode,
            TimeToSeeDataSessionsQuery,
            EventsQuery,
            PersonsQuery,
            InsightPersonsQuery,
            SessionsTimelineQuery,
            HogQLQuery,
            HogQLMetadata,
            WebOverviewQuery,
            WebStatsTableQuery,
            WebTopClicksQuery,
        ],
    ]


PropertyGroupFilterValue.model_rebuild()
