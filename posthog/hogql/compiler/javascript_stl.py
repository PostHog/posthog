# TODO: this should be autogenerated from common/hogvm/typescript/src/stl/*

STL_FUNCTIONS: dict[str, list[str | list[str]]] = {
    "concat": [
        "function concat (...args) { return args.map((arg) => (arg === null ? '' : __STLToString(arg))).join('') }",
        ["__STLToString"],
    ],
    "match": [
        "function match (str, pattern) { return !str || !pattern ? false : new RegExp(pattern).test(str) }",
        [],
    ],
    "__imatch": [
        "function __imatch (str, pattern) { return !str || !pattern ? false : new RegExp(pattern, 'i').test(str) }",
        [],
    ],
    "like": [
        "function like (str, pattern) { return __like(str, pattern, false) }",
        ["__like"],
    ],
    "ilike": [
        "function ilike (str, pattern) { return __like(str, pattern, true) }",
        ["__like"],
    ],
    "notLike": [
        "function notLike (str, pattern) { return !__like(str, pattern, false) }",
        ["__like"],
    ],
    "notILike": [
        "function notILike (str, pattern) { return !__like(str, pattern, true) }",
        ["__like"],
    ],
    "toString": [
        "function toString (value) { return __STLToString(value) }",
        ["__STLToString"],
    ],
    "toUUID": [
        "function toUUID (value) { return __STLToString(value) }",
        ["__STLToString"],
    ],
    "toInt": [
        """function toInt(value) {
    if (__isHogDateTime(value)) { return Math.floor(value.dt); }
    else if (__isHogDate(value)) { const date = new Date(Date.UTC(value.year, value.month - 1, value.day)); const epoch = new Date(Date.UTC(1970, 0, 1)); const diffInDays = Math.floor((date - epoch) / (1000 * 60 * 60 * 24)); return diffInDays; }
    return !isNaN(parseInt(value)) ? parseInt(value) : null; }""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "toFloat": [
        """function toFloat(value) {
    if (__isHogDateTime(value)) { return value.dt; }
    else if (__isHogDate(value)) { const date = new Date(Date.UTC(value.year, value.month - 1, value.day)); const epoch = new Date(Date.UTC(1970, 0, 1)); const diffInDays = (date - epoch) / (1000 * 60 * 60 * 24); return diffInDays; }
    return !isNaN(parseFloat(value)) ? parseFloat(value) : null; }""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "ifNull": [
        "function ifNull (value, defaultValue) { return value !== null ? value : defaultValue } ",
        [],
    ],
    "isNull": [
        "function isNull (value) { return value === null || value === undefined }",
        [],
    ],
    "isNotNull": [
        "function isNotNull (value) { return value !== null && value !== undefined }",
        [],
    ],
    "length": [
        "function length (value) { return value.length }",
        [],
    ],
    "empty": [
        """function empty (value) {
    if (typeof value === 'object') {
        if (Array.isArray(value)) { return value.length === 0 } else if (value === null) { return true } else if (value instanceof Map) { return value.size === 0 }
        return Object.keys(value).length === 0
    } else if (typeof value === 'number' || typeof value === 'boolean') { return false }
    return !value }""",
        [],
    ],
    "notEmpty": [
        "function notEmpty (value) { return !empty(value) }",
        ["empty"],
    ],
    "tuple": [
        "function tuple (...args) { const tuple = args.slice(); tuple.__isHogTuple = true; return tuple; }",
        [],
    ],
    "lower": [
        "function lower (value) { if (value === null || value === undefined) { return null } return value.toLowerCase() }",
        [],
    ],
    "upper": [
        "function upper (value) { return value.toUpperCase() }",
        [],
    ],
    "reverse": [
        "function reverse (value) { return value.split('').reverse().join('') }",
        [],
    ],
    "print": [
        "function print (...args) { console.log(...args.map(__printHogStringOutput)) }",
        ["__printHogStringOutput"],
    ],
    "jsonParse": [
        """function jsonParse (str) {
    function convert(x) {
        if (Array.isArray(x)) { return x.map(convert) }
        else if (typeof x === 'object' && x !== null) {
            if (x.__hogDateTime__) { return __toHogDateTime(x.dt, x.zone)
            } else if (x.__hogDate__) { return __toHogDate(x.year, x.month, x.day)
            } else if (x.__hogError__) { return __newHogError(x.type, x.message, x.payload) }
            const obj = {}; for (const key in x) { obj[key] = convert(x[key]) }; return obj }
        return x }
    return convert(JSON.parse(str)) }""",
        ["__toHogDateTime", "__toHogDate", "__newHogError"],
    ],
    "jsonStringify": [
        """function jsonStringify (value, spacing) {
    function convert(x, marked) {
        if (!marked) { marked = new Set() }
        if (typeof x === 'object' && x !== null) {
            if (marked.has(x)) { return null }
            marked.add(x)
            try {
                if (x instanceof Map) {
                    const obj = {}
                    x.forEach((value, key) => { obj[convert(key, marked)] = convert(value, marked) })
                    return obj
                }
                if (Array.isArray(x)) { return x.map((v) => convert(v, marked)) }
                if (__isHogDateTime(x) || __isHogDate(x) || __isHogError(x)) { return x }
                if (typeof x === 'function') { return `fn<${x.name || 'lambda'}(${x.length})>` }
                const obj = {}; for (const key in x) { obj[key] = convert(x[key], marked) }
                return obj
            } finally {
                marked.delete(x)
            }
        }
        return x
    }
    if (spacing && typeof spacing === 'number' && spacing > 0) {
        return JSON.stringify(convert(value), null, spacing)
    }
    return JSON.stringify(convert(value), (key, val) => typeof val === 'function' ? `fn<${val.name || 'lambda'}(${val.length})>` : val)
}""",
        ["__isHogDateTime", "__isHogDate", "__isHogError"],
    ],
    "JSONHas": [
        """function JSONHas (obj, ...path) {
    let current = obj
    for (const key of path) {
        let currentParsed = current
        if (typeof current === 'string') { try { currentParsed = JSON.parse(current) } catch (e) { return false } }
        if (currentParsed instanceof Map) { if (!currentParsed.has(key)) { return false }; current = currentParsed.get(key) }
        else if (typeof currentParsed === 'object' && currentParsed !== null) {
            if (typeof key === 'number') {
                if (Array.isArray(currentParsed)) {
                    if (key < 0) { if (key < -currentParsed.length) { return false }; current = currentParsed[currentParsed.length + key] }
                    else if (key === 0) { return false }
                    else { if (key > currentParsed.length) { return false }; current = currentParsed[key - 1] }
                } else { return false }
            } else {
                if (!(key in currentParsed)) { return false }
                current = currentParsed[key]
            }
        } else { return false }
    }
    return true }""",
        [],
    ],
    "isValidJSON": [
        "function isValidJSON (str) { try { JSON.parse(str); return true } catch (e) { return false } }",
        [],
    ],
    "JSONLength": [
        """function JSONLength (obj, ...path) {
    try { if (typeof obj === 'string') { obj = JSON.parse(obj) } } catch (e) { return 0 }
    if (typeof obj === 'object' && obj !== null) {
        const value = __getNestedValue(obj, path, true)
        if (Array.isArray(value)) {
            return value.length
        } else if (value instanceof Map) {
            return value.size
        } else if (typeof value === 'object' && value !== null) {
            return Object.keys(value).length
        }
    }
    return 0 }""",
        ["__getNestedValue"],
    ],
    "JSONExtractBool": [
        """function JSONExtractBool (obj, ...path) {
    try {
        if (typeof obj === 'string') {
            obj = JSON.parse(obj)
        }
    } catch (e) {
        return false
    }
    if (path.length > 0) {
        obj = __getNestedValue(obj, path, true)
    }
    if (typeof obj === 'boolean') {
        return obj
    }
    return false
}""",
        ["__getNestedValue"],
    ],
    "base64Encode": [
        "function base64Encode (str) { return Buffer.from(str).toString('base64') }",
        [],
    ],
    "base64Decode": [
        "function base64Decode (str) { return Buffer.from(str, 'base64').toString() } ",
        [],
    ],
    "tryBase64Decode": [
        "function tryBase64Decode (str) { try { return Buffer.from(str, 'base64').toString() } catch (e) { return '' } }",
        [],
    ],
    "encodeURLComponent": [
        "function encodeURLComponent (str) { return encodeURIComponent(str) }",
        [],
    ],
    "decodeURLComponent": [
        "function decodeURLComponent (str) { return decodeURIComponent(str) }",
        [],
    ],
    "replaceOne": [
        "function replaceOne (str, searchValue, replaceValue) { return str.replace(searchValue, replaceValue) }",
        [],
    ],
    "replaceAll": [
        "function replaceAll (str, searchValue, replaceValue) { return str.replaceAll(searchValue, replaceValue) }",
        [],
    ],
    "position": [
        "function position (str, elem) { if (typeof str === 'string') { return str.indexOf(String(elem)) + 1 } else { return 0 } }",
        [],
    ],
    "positionCaseInsensitive": [
        "function positionCaseInsensitive (str, elem) { if (typeof str === 'string') { return str.toLowerCase().indexOf(String(elem).toLowerCase()) + 1 } else { return 0 } }",
        [],
    ],
    "trim": [
        """function trim (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let start = 0
    while (str[start] === char) {
        start++
    }
    let end = str.length
    while (str[end - 1] === char) {
        end--
    }
    if (start >= end) {
        return ''
    }
    return str.slice(start, end)
}""",
        [],
    ],
    "trimLeft": [
        """function trimLeft (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let start = 0
    while (str[start] === char) {
        start++
    }
    return str.slice(start)
}""",
        [],
    ],
    "trimRight": [
        """function trimRight (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let end = str.length
    while (str[end - 1] === char) {
        end--
    }
    return str.slice(0, end)
}""",
        [],
    ],
    "splitByString": [
        "function splitByString (separator, str, maxSplits) { if (maxSplits === undefined || maxSplits === null) { return str.split(separator) } return str.split(separator, maxSplits) }",
        [],
    ],
    "generateUUIDv4": [
        "function generateUUIDv4 () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0; const v = c === 'x' ? r : (r & 0x3) | 0x8; return v.toString(16) })}",
        [],
    ],
    "sha256Hex": [
        'function sha256Hex(data) {if (data === null || data == undefined) return null; let h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a,h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19,tsz=0,bp=0;const k=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2],rrot=(x,n)=>(x>>>n)|(x<<(32-n)),w=new Uint32Array(64),buf=new Uint8Array(64),process=()=>{for(let j=0,r=0;j<16;j++,r+=4){w[j]=(buf[r]<<24)|(buf[r+1]<<16)|(buf[r+2]<<8)|buf[r+3]}for(let j=16;j<64;j++){let s0=rrot(w[j-15],7)^rrot(w[j-15],18)^(w[j-15]>>>3);let s1=rrot(w[j-2],17)^rrot(w[j-2],19)^(w[j-2]>>>10);w[j]=(w[j-16]+s0+w[j-7]+s1)|0}let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7;for(let j=0;j<64;j++){let S1=rrot(e,6)^rrot(e,11)^rrot(e,25),ch=(e&f)^((~e)&g),t1=(h+S1+ch+k[j]+w[j])|0,S0=rrot(a,2)^rrot(a,13)^rrot(a,22),maj=(a&b)^(a&c)^(b&c),t2=(S0+maj)|0;h=g;g=f;f=e;e=(d+t1)|0;d=c;c=b;b=a;a=(t1+t2)|0}h0=(h0+a)|0;h1=(h1+b)|0;h2=(h2+c)|0;h3=(h3+d)|0;h4=(h4+e)|0;h5=(h5+f)|0;h6=(h6+g)|0;h7=(h7+h)|0;bp=0},add=data=>{if(typeof data==="string"){data=typeof TextEncoder==="undefined"?Buffer.from(data):(new TextEncoder).encode(data)}for(let i=0;i<data.length;i++){buf[bp++]=data[i];if(bp===64)process();}tsz+=data.length},digest=()=>{buf[bp++]=0x80;if(bp==64)process();if(bp+8>64){while(bp<64)buf[bp++]=0x00;process()}while(bp<58)buf[bp++]=0x00;let L=tsz*8;buf[bp++]=(L/1099511627776.)&255;buf[bp++]=(L/4294967296.)&255;buf[bp++]=L>>>24;buf[bp++]=(L>>>16)&255;buf[bp++]=(L>>>8)&255;buf[bp++]=L&255;process();let reply=new Uint8Array(32);reply[0]=h0>>>24;reply[1]=(h0>>>16)&255;reply[2]=(h0>>>8)&255;reply[3]=h0&255;reply[4]=h1>>>24;reply[5]=(h1>>>16)&255;reply[6]=(h1>>>8)&255;reply[7]=h1&255;reply[8]=h2>>>24;reply[9]=(h2>>>16)&255;reply[10]=(h2>>>8)&255;reply[11]=h2&255;reply[12]=h3>>>24;reply[13]=(h3>>>16)&255;reply[14]=(h3>>>8)&255;reply[15]=h3&255;reply[16]=h4>>>24;reply[17]=(h4>>>16)&255;reply[18]=(h4>>>8)&255;reply[19]=h4&255;reply[20]=h5>>>24;reply[21]=(h5>>>16)&255;reply[22]=(h5>>>8)&255;reply[23]=h5&255;reply[24]=h6>>>24;reply[25]=(h6>>>16)&255;reply[26]=(h6>>>8)&255;reply[27]=h6&255;reply[28]=h7>>>24;reply[29]=(h7>>>16)&255;reply[30]=(h7>>>8)&255;reply[31]=h7&255;reply.hex=()=>{let res="";reply.forEach(x=>res+=("0"+x.toString(16)).slice(-2));return res};return reply};if(data===undefined)return{add,digest};add(data);return digest().hex()}',
        [],
    ],
    "md5Hex": [
        "function md5Hex(s) {if (s === null || s == undefined) return null; var k=[],i=0;for(;i<64;){k[i]=0|Math.sin(++i%Math.PI)*4294967296}var b,c,d,h=[b=0x67452301,c=0xEFCDAB89,~b,~c],words=[],j=unescape(encodeURI(s))+'\x80',a=j.length;s=(--a/4+2)|15;words[--s]=a*8;for(;~a;){words[a>>2]|=j.charCodeAt(a)<<8*a--}for(i=j=0;i<s;i+=16){a=h;for(;j<64;a=[d=a[3],(b+((d=a[0]+[b&c|~b&d,d&b|~d&c,b^c^d,c^(b|~d)][a=j>>4]+k[j]+~~words[i|[j,5*j+1,3*j+5,7*j][a]&15])<<(a=[7,12,17,22,5,9,14,20,4,11,16,23,6,10,15,21][4*a+j++%4])|d>>>-a)),b,c]){b=a[1]|0;c=a[2]}for(j=4;j;)h[--j]+=a[j]}for(s='';j<32;){s+=((h[j>>3]>>((1^j++)*4))&15).toString(16)}return s}",
        [],
    ],
    "sha256HmacChainHex": [
        "function sha256HmacChainHex (data, options) { return 'sha256HmacChainHex not implemented' }",
        [],
    ],
    "isIPAddressInRange": [
        """
function isIPAddressInRange(address, prefix) {
    function toBytes(ip, isV4) {
        if (isV4) {
            const p = ip.split('.')
            if (p.length !== 4) return null

            const b = new Uint8Array(4)
            for (let i = 0; i < 4; i++) {
                const n = +p[i]
                if (isNaN(n) || n < 0 || n > 255 || p[i] !== n.toString()) return null
                b[i] = n
            }
            return b
        }

        const b = new Uint8Array(16)
        let s

        if (ip.includes('::')) {
            if ((ip.match(/::/g) || []).length > 1) return null

            const [pre, post] = ip.split('::')
            const preSeg = pre ? pre.split(':') : []
            const postSeg = post ? post.split(':') : []

            if (preSeg.length + postSeg.length > 7) return null

            s = [...preSeg, ...Array(8 - preSeg.length - postSeg.length).fill('0'), ...postSeg]
        } else {
            s = ip.split(':')
            if (s.length !== 8) return null
        }

        for (let i = 0; i < 8; i++) {
            if (!s[i] && s[i] !== '0') return null

            const v = parseInt(s[i], 16)
            if (isNaN(v) || v < 0 || v > 0xffff) return null

            b[i * 2] = v >> 8
            b[i * 2 + 1] = v & 0xff
        }
        return b
    }

    try {
        if (!address || !prefix) return false

        const [net, mask] = prefix.split('/')
        if (!net || !mask) return false

        const cidr = +mask
        if (isNaN(cidr) || cidr < 0) return false

        const v4 = address.includes('.') && net.includes('.')
        const v6 = !v4 && address.includes(':') && net.includes(':')
        if (!v4 && !v6) return false
        if ((v4 && cidr > 32) || (v6 && cidr > 128)) return false

        const aBytes = toBytes(address, v4)
        const nBytes = toBytes(net, v4)
        if (!aBytes || !nBytes) return false

        const fullBytes = cidr >> 3
        for (let i = 0; i < fullBytes; i++) if (aBytes[i] !== nBytes[i]) return false

        const bits = cidr & 7
        if (bits && fullBytes < aBytes.length) {
            const m = 0xff << (8 - bits)
            if ((aBytes[fullBytes] & m) !== (nBytes[fullBytes] & m)) return false
        }

        return true
    } catch {
        return false
    }
}""",
        [],
    ],
    "keys": [
        """function keys (obj) { if (typeof obj === 'object' && obj !== null) { if (Array.isArray(obj)) { return Array.from(obj.keys()) } else if (obj instanceof Map) { return Array.from(obj.keys()) } return Object.keys(obj) } return [] }""",
        [],
    ],
    "values": [
        """function values (obj) { if (typeof obj === 'object' && obj !== null) { if (Array.isArray(obj)) { return [...obj] } else if (obj instanceof Map) { return Array.from(obj.values()) } return Object.values(obj) } return [] }""",
        [],
    ],
    "indexOf": [
        "function indexOf (arrOrString, elem) { if (Array.isArray(arrOrString)) { return arrOrString.indexOf(elem) + 1 } else { return 0 } }",
        [],
    ],
    "arrayPushBack": [
        "function arrayPushBack (arr, item) { if (!Array.isArray(arr)) { return [item] } return [...arr, item] }",
        [],
    ],
    "arrayPushFront": [
        "function arrayPushFront (arr, item) { if (!Array.isArray(arr)) { return [item] } return [item, ...arr] }",
        [],
    ],
    "arrayPopBack": [
        "function arrayPopBack (arr) { if (!Array.isArray(arr)) { return [] } return arr.slice(0, arr.length - 1) }",
        [],
    ],
    "arrayPopFront": [
        "function arrayPopFront (arr) { if (!Array.isArray(arr)) { return [] } return arr.slice(1) }",
        [],
    ],
    "arraySort": [
        "function arraySort (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].sort() }",
        [],
    ],
    "arrayReverse": [
        "function arrayReverse (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].reverse() }",
        [],
    ],
    "arrayReverseSort": [
        "function arrayReverseSort (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].sort().reverse() }",
        [],
    ],
    "arrayStringConcat": [
        "function arrayStringConcat (arr, separator = '') { if (!Array.isArray(arr)) { return '' } return arr.join(separator) }",
        [],
    ],
    "arrayCount": [
        "function arrayCount (func, arr) { let count = 0; for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { count = count + 1 } } return count }",
        [],
    ],
    "arrayExists": [
        """function arrayExists (func, arr) { for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { return true } } return false }""",
        [],
    ],
    "arrayFilter": [
        """function arrayFilter (func, arr) { let result = []; for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { result = arrayPushBack(result, arr[i]) } } return result}""",
        ["arrayPushBack"],
    ],
    "arrayMap": [
        """function arrayMap (func, arr) { let result = []; for (let i = 0; i < arr.length; i++) { result = arrayPushBack(result, func(arr[i])) } return result }""",
        ["arrayPushBack"],
    ],
    "arrayReduce": [
        """function arrayReduce (func, arr, initial) { let result = initial; for (let i = 0; i < arr.length; i++) { result = func(result, arr[i]) } return result }""",
        [],
    ],
    "has": [
        """function has (arr, elem) { if (!Array.isArray(arr) || arr.length === 0) { return false } return arr.includes(elem) }""",
        [],
    ],
    "now": [
        """function now () { return __now() }""",
        ["__now"],
    ],
    "toUnixTimestamp": [
        """function toUnixTimestamp (input, zone) { return __toUnixTimestamp(input, zone) }""",
        ["__toUnixTimestamp"],
    ],
    "fromUnixTimestamp": [
        """function fromUnixTimestamp (input) { return __fromUnixTimestamp(input) }""",
        ["__fromUnixTimestamp"],
    ],
    "toUnixTimestampMilli": [
        """function toUnixTimestampMilli (input, zone) { return __toUnixTimestampMilli(input, zone) }""",
        ["__toUnixTimestampMilli"],
    ],
    "fromUnixTimestampMilli": [
        """function fromUnixTimestampMilli (input) { return __fromUnixTimestampMilli(input) }""",
        ["__fromUnixTimestampMilli"],
    ],
    "toTimeZone": [
        """function toTimeZone (input, zone) { return __toTimeZone(input, zone) }""",
        ["__toTimeZone"],
    ],
    "toDate": [
        """function toDate (input) { return __toDate(input) }""",
        ["__toDate"],
    ],
    "toDateTime": [
        """function toDateTime (input, zone) { return __toDateTime(input, zone) }""",
        ["__toDateTime"],
    ],
    "formatDateTime": [
        """function formatDateTime (input, format, zone) { return __formatDateTime(input, format, zone) }""",
        ["__formatDateTime"],
    ],
    "HogError": [
        """function HogError (type, message, payload) { return __newHogError(type, message, payload) }""",
        ["__newHogError"],
    ],
    "Error": [
        """function __x_Error (message, payload) { return __newHogError('Error', message, payload) }""",
        ["__newHogError"],
    ],
    "RetryError": [
        """function RetryError (message, payload) { return __newHogError('RetryError', message, payload) }""",
        ["__newHogError"],
    ],
    "NotImplementedError": [
        """function NotImplementedError (message, payload) { return __newHogError('NotImplementedError', message, payload) }""",
        ["__newHogError"],
    ],
    "typeof": [
        """function __x_typeof (value) {
    if (value === null || value === undefined) { return 'null'
    } else if (__isHogDateTime(value)) { return 'datetime'
    } else if (__isHogDate(value)) { return 'date'
    } else if (__isHogError(value)) { return 'error'
    } else if (typeof value === 'function') { return 'function'
    } else if (Array.isArray(value)) { if (value.__isHogTuple) { return 'tuple' } return 'array'
    } else if (typeof value === 'object') { return 'object'
    } else if (typeof value === 'number') { return Number.isInteger(value) ? 'integer' : 'float'
    } else if (typeof value === 'string') { return 'string'
    } else if (typeof value === 'boolean') { return 'boolean' }
    return 'unknown'
}
""",
        ["__isHogDateTime", "__isHogDate", "__isHogError"],
    ],
    "__DateTimeToString": [
        r"""function __DateTimeToString(dt) {
    if (__isHogDateTime(dt)) {
        const date = new Date(dt.dt * 1000);
        const timeZone = dt.zone || 'UTC';
        const milliseconds = Math.floor(dt.dt * 1000 % 1000);
        const options = { timeZone, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const formatter = new Intl.DateTimeFormat('en-US', options);
        const parts = formatter.formatToParts(date);
        let year, month, day, hour, minute, second;
        for (const part of parts) {
            switch (part.type) {
                case 'year': year = part.value; break;
                case 'month': month = part.value; break;
                case 'day': day = part.value; break;
                case 'hour': hour = part.value; break;
                case 'minute': minute = part.value; break;
                case 'second': second = part.value; break;
                default: break;
            }
        }
        const getOffset = (date, timeZone) => {
            const tzDate = new Date(date.toLocaleString('en-US', { timeZone }));
            const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));
            const offset = (tzDate - utcDate) / 60000; // in minutes
            const sign = offset >= 0 ? '+' : '-';
            const absOffset = Math.abs(offset);
            const hours = Math.floor(absOffset / 60);
            const minutes = absOffset % 60;
            return `${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        };
        let offset = 'Z';
        if (timeZone !== 'UTC') {
            offset = getOffset(date, timeZone);
        }
        let isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
        isoString += `.${milliseconds.toString().padStart(3, '0')}`;
        isoString += offset;
        return isoString;
    }
}
    """,
        [],
    ],
    "__STLToString": [
        r"""function __STLToString(arg) {
    if (arg && __isHogDate(arg)) { return `${arg.year}-${arg.month.toString().padStart(2, '0')}-${arg.day.toString().padStart(2, '0')}`; }
    else if (arg && __isHogDateTime(arg)) { return __DateTimeToString(arg); }
    return __printHogStringOutput(arg); }""",
        ["__isHogDate", "__isHogDateTime", "__printHogStringOutput", "__DateTimeToString"],
    ],
    "__isHogDate": [
        """function __isHogDate(obj) { return obj && obj.__hogDate__ === true }""",
        [],
    ],
    "__isHogDateTime": [
        """function __isHogDateTime(obj) { return obj && obj.__hogDateTime__ === true }""",
        [],
    ],
    "__toHogDate": [
        """function __toHogDate(year, month, day) { return { __hogDate__: true, year: year, month: month, day: day, } }""",
        [],
    ],
    "__toHogDateTime": [
        """function __toHogDateTime(timestamp, zone) {
    if (__isHogDate(timestamp)) {
        const date = new Date(Date.UTC(timestamp.year, timestamp.month - 1, timestamp.day));
        const dt = date.getTime() / 1000;
        return { __hogDateTime__: true, dt: dt, zone: zone || 'UTC' };
    }
    return { __hogDateTime__: true, dt: timestamp, zone: zone || 'UTC' }; }""",
        ["__isHogDate"],
    ],
    "__now": [
        """function __now(zone) { return __toHogDateTime(Date.now() / 1000, zone) }""",
        ["__toHogDateTime"],
    ],
    "__toUnixTimestamp": [
        """function __toUnixTimestamp(input, zone) {
    if (__isHogDateTime(input)) { return input.dt; }
    if (__isHogDate(input)) { return __toHogDateTime(input).dt; }
    const date = new Date(input);
    if (isNaN(date.getTime())) { throw new Error('Invalid date input'); }
    return Math.floor(date.getTime() / 1000);}""",
        ["__isHogDateTime", "__isHogDate", "__toHogDateTime"],
    ],
    "__fromUnixTimestamp": [
        """function __fromUnixTimestamp(input) { return __toHogDateTime(input) }""",
        ["__toHogDateTime"],
    ],
    "__toUnixTimestampMilli": [
        """function __toUnixTimestampMilli(input, zone) { return __toUnixTimestamp(input, zone) * 1000 }""",
        ["__toUnixTimestamp"],
    ],
    "__fromUnixTimestampMilli": [
        """function __fromUnixTimestampMilli(input) { return __toHogDateTime(input / 1000) }""",
        ["__toHogDateTime"],
    ],
    "__toTimeZone": [
        """function __toTimeZone(input, zone) { if (!__isHogDateTime(input)) { throw new Error('Expected a DateTime') }; return { ...input, zone }}""",
        ["__isHogDateTime"],
    ],
    "__toDate": [
        """function __toDate(input) { let date;
    if (typeof input === 'number') { date = new Date(input * 1000); } else { date = new Date(input); }
    if (isNaN(date.getTime())) { throw new Error('Invalid date input'); }
    return { __hogDate__: true, year: date.getUTCFullYear(), month: date.getUTCMonth() + 1, day: date.getUTCDate() }; }""",
        [],
    ],
    "__toDateTime": [
        """function __toDateTime(input, zone) { let dt;
    if (typeof input === 'number') { dt = input; }
    else { const date = new Date(input); if (isNaN(date.getTime())) { throw new Error('Invalid date input'); } dt = date.getTime() / 1000; }
    return { __hogDateTime__: true, dt: dt, zone: zone || 'UTC' }; }""",
        [],
    ],
    "__formatDateTime": [
        """function __formatDateTime(input, format, zone) {
    if (!__isHogDateTime(input)) { throw new Error('Expected a DateTime'); }
    if (!format) { throw new Error('formatDateTime requires at least 2 arguments'); }
    const timestamp = input.dt * 1000;
    let date = new Date(timestamp);
    if (!zone) { zone = 'UTC'; }
    const padZero = (num, len = 2) => String(num).padStart(len, '0');
    const padSpace = (num, len = 2) => String(num).padStart(len, ' ');
    const getDateComponent = (type, options = {}) => {
        const formatter = new Intl.DateTimeFormat('en-US', { ...options, timeZone: zone });
        const parts = formatter.formatToParts(date);
        const part = parts.find(p => p.type === type);
        return part ? part.value : '';
    };
    const getNumericComponent = (type, options = {}) => {
        const value = getDateComponent(type, options);
        return parseInt(value, 10);
    };
    const getWeekNumber = (d) => {
        const dateInZone = new Date(d.toLocaleString('en-US', { timeZone: zone }));
        const target = new Date(Date.UTC(dateInZone.getFullYear(), dateInZone.getMonth(), dateInZone.getDate()));
        const dayNr = (target.getUTCDay() + 6) % 7;
        target.setUTCDate(target.getUTCDate() - dayNr + 3);
        const firstThursday = new Date(Date.UTC(target.getUTCFullYear(), 0, 4));
        const weekNumber = 1 + Math.round(((target - firstThursday) / 86400000 - 3 + ((firstThursday.getUTCDay() + 6) % 7)) / 7);
        return weekNumber;
    };
    const getDayOfYear = (d) => {
        const startOfYear = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        const dateInZone = new Date(d.toLocaleString('en-US', { timeZone: zone }));
        const diff = dateInZone - startOfYear;
        return Math.floor(diff / 86400000) + 1;
    };
    // Token mapping with corrections
    const tokens = {
        '%a': () => getDateComponent('weekday', { weekday: 'short' }),
        '%b': () => getDateComponent('month', { month: 'short' }),
        '%c': () => padZero(getNumericComponent('month', { month: '2-digit' })),
        '%C': () => getDateComponent('year', { year: '2-digit' }),
        '%d': () => padZero(getNumericComponent('day', { day: '2-digit' })),
        '%D': () => {
            const month = padZero(getNumericComponent('month', { month: '2-digit' }));
            const day = padZero(getNumericComponent('day', { day: '2-digit' }));
            const year = getDateComponent('year', { year: '2-digit' });
            return `${month}/${day}/${year}`;
        },
        '%e': () => padSpace(getNumericComponent('day', { day: 'numeric' })),
        '%F': () => {
            const year = getNumericComponent('year', { year: 'numeric' });
            const month = padZero(getNumericComponent('month', { month: '2-digit' }));
            const day = padZero(getNumericComponent('day', { day: '2-digit' }));
            return `${year}-${month}-${day}`;
        },
        '%g': () => getDateComponent('year', { year: '2-digit' }),
        '%G': () => getNumericComponent('year', { year: 'numeric' }),
        '%h': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%H': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false })),
        '%i': () => padZero(getNumericComponent('minute', { minute: '2-digit' })),
        '%I': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%j': () => padZero(getDayOfYear(date), 3),
        '%k': () => padSpace(getNumericComponent('hour', { hour: 'numeric', hour12: false })),
        '%l': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%m': () => padZero(getNumericComponent('month', { month: '2-digit' })),
        '%M': () => getDateComponent('month', { month: 'long' }),
        '%n': () => '\\n',
        '%p': () => getDateComponent('dayPeriod', { hour: 'numeric', hour12: true }),
        '%r': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            const second = padZero(getNumericComponent('second', { second: '2-digit' }));
            const period = getDateComponent('dayPeriod', { hour: 'numeric', hour12: true });
            return `${hour}:${minute} ${period}`;
        },
        '%R': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            return `${hour}:${minute}`;
        },
        '%s': () => padZero(getNumericComponent('second', { second: '2-digit' })),
        '%S': () => padZero(getNumericComponent('second', { second: '2-digit' })),
        '%t': () => '\\t',
        '%T': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            const second = padZero(getNumericComponent('second', { second: '2-digit' }));
            return `${hour}:${minute}:${second}`;
        },
        '%u': () => {
            let day = getDateComponent('weekday', { weekday: 'short' });
            const dayMap = { 'Mon': '1', 'Tue': '2', 'Wed': '3', 'Thu': '4', 'Fri': '5', 'Sat': '6', 'Sun': '7' };
            return dayMap[day];
        },
        '%V': () => padZero(getWeekNumber(date)),
        '%w': () => {
            let day = getDateComponent('weekday', { weekday: 'short' });
            const dayMap = { 'Sun': '0', 'Mon': '1', 'Tue': '2', 'Wed': '3', 'Thu': '4', 'Fri': '5', 'Sat': '6' };
            return dayMap[day];
        },
        '%W': () => getDateComponent('weekday', { weekday: 'long' }),
        '%y': () => getDateComponent('year', { year: '2-digit' }),
        '%Y': () => getNumericComponent('year', { year: 'numeric' }),
        '%z': () => {
            if (zone === 'UTC') {
                return '+0000';
            } else {
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: zone,
                    timeZoneName: 'shortOffset',
                });
                const parts = formatter.formatToParts(date);
                const offsetPart = parts.find(part => part.type === 'timeZoneName');
                if (offsetPart && offsetPart.value) {
                    const offsetValue = offsetPart.value;
                    const match = offsetValue.match(/GMT([+-]\\d{1,2})(?::(\\d{2}))?/);
                    if (match) {
                        const sign = match[1][0];
                        const hours = padZero(Math.abs(parseInt(match[1], 10)));
                        const minutes = padZero(match[2] ? parseInt(match[2], 10) : 0);
                        return `${sign}${hours}${minutes}`;
                    }
                }
                return '';
            }
        },
        '%%': () => '%',
    };

    // Replace tokens in the format string
    let result = '';
    let i = 0;
    while (i < format.length) {
        if (format[i] === '%') {
            const token = format.substring(i, i + 2);
            if (tokens[token]) {
                result += tokens[token]();
                i += 2;
            } else {
                // If token not found, include '%' and move to next character
                result += format[i];
                i += 1;
            }
        } else {
            result += format[i];
            i += 1;
        }
    }

    return result;
}
""",
        ["__isHogDateTime"],
    ],
    "__printHogStringOutput": [
        """function __printHogStringOutput(obj) { if (typeof obj === 'string') { return obj } return __printHogValue(obj) } """,
        ["__printHogValue"],
    ],
    "__printHogValue": [
        """
function __printHogValue(obj, marked = new Set()) {
    if (typeof obj === 'object' && obj !== null && obj !== undefined) {
        if (marked.has(obj) && !__isHogDateTime(obj) && !__isHogDate(obj) && !__isHogError(obj)) { return 'null'; }
        marked.add(obj);
        try {
            if (Array.isArray(obj)) {
                if (obj.__isHogTuple) { return obj.length < 2 ? `tuple(${obj.map((o) => __printHogValue(o, marked)).join(', ')})` : `(${obj.map((o) => __printHogValue(o, marked)).join(', ')})`; }
                return `[${obj.map((o) => __printHogValue(o, marked)).join(', ')}]`;
            }
            if (__isHogDateTime(obj)) { const millis = String(obj.dt); return `DateTime(${millis}${millis.includes('.') ? '' : '.0'}, ${__escapeString(obj.zone)})`; }
            if (__isHogDate(obj)) return `Date(${obj.year}, ${obj.month}, ${obj.day})`;
            if (__isHogError(obj)) { return `${String(obj.type)}(${__escapeString(obj.message)}${obj.payload ? `, ${__printHogValue(obj.payload, marked)}` : ''})`; }
            if (obj instanceof Map) { return `{${Array.from(obj.entries()).map(([key, value]) => `${__printHogValue(key, marked)}: ${__printHogValue(value, marked)}`).join(', ')}}`; }
            return `{${Object.entries(obj).map(([key, value]) => `${__printHogValue(key, marked)}: ${__printHogValue(value, marked)}`).join(', ')}}`;
        } finally {
            marked.delete(obj);
        }
    } else if (typeof obj === 'boolean') return obj ? 'true' : 'false';
    else if (obj === null || obj === undefined) return 'null';
    else if (typeof obj === 'string') return __escapeString(obj);
            if (typeof obj === 'function') return `fn<${__escapeIdentifier(obj.name || 'lambda')}(${obj.length})>`;
    return obj.toString();
}
""",
        [
            "__isHogDateTime",
            "__isHogDate",
            "__isHogError",
            "__escapeString",
            "__escapeIdentifier",
        ],
    ],
    "__escapeString": [
        """
function __escapeString(value) {
    const singlequoteEscapeCharsMap = { '\\b': '\\\\b', '\\f': '\\\\f', '\\r': '\\\\r', '\\n': '\\\\n', '\\t': '\\\\t', '\\0': '\\\\0', '\\v': '\\\\v', '\\\\': '\\\\\\\\', "'": "\\\\'" }
    return `'${value.split('').map((c) => singlequoteEscapeCharsMap[c] || c).join('')}'`;
}
""",
        [],
    ],
    "__escapeIdentifier": [
        """
function __escapeIdentifier(identifier) {
    const backquoteEscapeCharsMap = { '\\b': '\\\\b', '\\f': '\\\\f', '\\r': '\\\\r', '\\n': '\\\\n', '\\t': '\\\\t', '\\0': '\\\\0', '\\v': '\\\\v', '\\\\': '\\\\\\\\', '`': '\\\\`' }
    if (typeof identifier === 'number') return identifier.toString();
    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(identifier)) return identifier;
    return `\\`${identifier.split('').map((c) => backquoteEscapeCharsMap[c] || c).join('')}\\``;
}
""",
        [],
    ],
    "__newHogError": [
        """
function __newHogError(type, message, payload) {
    let error = new Error(message || 'An error occurred');
    error.__hogError__ = true
    error.type = type
    error.payload = payload
    return error
}
""",
        [],
    ],
    "__isHogError": [
        """function __isHogError(obj) {return obj && obj.__hogError__ === true}""",
        [],
    ],
    "__getNestedValue": [
        """
function __getNestedValue(obj, path, allowNull = false) {
    let current = obj
    for (const key of path) {
        if (current == null) {
            return null
        }
        if (current instanceof Map) {
            current = current.get(key)
        } else if (typeof current === 'object' && current !== null) {
            current = current[key]
        } else {
            return null
        }
    }
    if (current === null && !allowNull) {
        return null
    }
    return current
}
""",
        [],
    ],
    "__like": [
        """
function __like(str, pattern, caseInsensitive = false) {
    if (caseInsensitive) {
        str = str.toLowerCase()
        pattern = pattern.toLowerCase()
    }
    pattern = String(pattern)
        .replaceAll(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')
        .replaceAll('%', '.*')
        .replaceAll('_', '.')
    return new RegExp(pattern).test(str)
}
""",
        [],
    ],
    "__getProperty": [
        """
function __getProperty(objectOrArray, key, nullish) {
    if ((nullish && !objectOrArray) || key === 0) { return null }
    if (Array.isArray(objectOrArray)) { return key > 0 ? objectOrArray[key - 1] : objectOrArray[objectOrArray.length + key] }
    else { return objectOrArray[key] }
}
""",
        [],
    ],
    "__setProperty": [
        """
function __setProperty(objectOrArray, key, value) {
    if (Array.isArray(objectOrArray)) { if (key > 0) { objectOrArray[key - 1] = value } else { objectOrArray[objectOrArray.length + key] = value } }
    else { objectOrArray[key] = value }
    return objectOrArray
}
""",
        [],
    ],
    "__lambda": [
        """function __lambda (fn) { return fn }""",
        [],
    ],
    "__toHogInterval": [
        """function __toHogInterval(value, unit) {
    return { __hogInterval__: true, value: value, unit: unit };
}""",
        [],
    ],
    "__isHogInterval": [
        """function __isHogInterval(obj) { return obj && obj.__hogInterval__ === true }""",
        [],
    ],
    "__applyIntervalToDateTime": [
        """function __applyIntervalToDateTime(base, interval) {
    // base can be HogDate or HogDateTime
    if (!(__isHogDate(base) || __isHogDateTime(base))) {
        throw new Error("Expected a HogDate or HogDateTime");
    }

    let zone = __isHogDateTime(base) ? (base.zone || 'UTC') : 'UTC';

    function toDate(obj) {
        if (__isHogDateTime(obj)) {
            return new Date(obj.dt * 1000);
        } else {
            return new Date(Date.UTC(obj.year, obj.month - 1, obj.day));
        }
    }

    const dt = toDate(base);
    const value = interval.value;
    let unit = interval.unit;

    // Expand weeks/years if needed
    if (unit === 'week') {
        unit = 'day';
        interval.value = value * 7;
    } else if (unit === 'year') {
        unit = 'month';
        interval.value = value * 12;
    }

    let year = dt.getUTCFullYear();
    let month = dt.getUTCMonth() + 1;
    let day = dt.getUTCDate();
    let hours = dt.getUTCHours();
    let minutes = dt.getUTCMinutes();
    let seconds = dt.getUTCSeconds();
    let ms = dt.getUTCMilliseconds();

    if (unit === 'day') {
        day += interval.value;
    } else if (unit === 'hour') {
        hours += interval.value;
    } else if (unit === 'minute') {
        minutes += interval.value;
    } else if (unit === 'second') {
        seconds += interval.value;
    } else if (unit === 'month') {
        month += interval.value;
        // Adjust year and month
        year += Math.floor((month - 1) / 12);
        month = ((month - 1) % 12) + 1;
        // If day is invalid for the new month, clamp it
        let maxDay = new Date(Date.UTC(year, month, 0)).getUTCDate();
        if (day > maxDay) { day = maxDay; }
    } else {
        throw new Error("Unsupported interval unit: " + unit);
    }

    const newDt = new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds, ms));

    if (__isHogDate(base)) {
        return __toHogDate(newDt.getUTCFullYear(), newDt.getUTCMonth() + 1, newDt.getUTCDate());
    } else {
        return __toHogDateTime(newDt.getTime() / 1000, zone);
    }
}""",
        ["__isHogDate", "__isHogDateTime", "__toHogDate", "__toHogDateTime"],
    ],
    "JSONExtractArrayRaw": [
        """function JSONExtractArrayRaw(obj, ...path) {
    try {
        if (typeof obj === 'string') { obj = JSON.parse(obj); }
    } catch (e) { return null; }
    const val = __getNestedValue(obj, path, true);
    return Array.isArray(val) ? val : null;
}""",
        ["__getNestedValue"],
    ],
    "JSONExtractFloat": [
        """function JSONExtractFloat(obj, ...path) {
    try {
        if (typeof obj === 'string') { obj = JSON.parse(obj); }
    } catch (e) { return null; }
    const val = __getNestedValue(obj, path, true);
    const f = parseFloat(val);
    return isNaN(f) ? null : f;
}""",
        ["__getNestedValue"],
    ],
    "JSONExtractInt": [
        """function JSONExtractInt(obj, ...path) {
    try {
        if (typeof obj === 'string') { obj = JSON.parse(obj); }
    } catch (e) { return null; }
    const val = __getNestedValue(obj, path, true);
    const i = parseInt(val);
    return isNaN(i) ? null : i;
}""",
        ["__getNestedValue"],
    ],
    "JSONExtractString": [
        """function JSONExtractString(obj, ...path) {
    try {
        if (typeof obj === 'string') { obj = JSON.parse(obj); }
    } catch (e) { return null; }
    const val = __getNestedValue(obj, path, true);
    return val != null ? String(val) : null;
}""",
        ["__getNestedValue"],
    ],
    "addDays": [
        """function addDays(dateOrDt, days) {
    const interval = __toHogInterval(days, 'day');
    return __applyIntervalToDateTime(dateOrDt, interval);
}""",
        ["__toHogInterval", "__applyIntervalToDateTime"],
    ],
    "assumeNotNull": [
        """function assumeNotNull(value) {
    if (value === null || value === undefined) {
        throw new Error("Value is null in assumeNotNull");
    }
    return value;
}""",
        [],
    ],
    "coalesce": [
        """function coalesce(...args) {
    for (let a of args) {
        if (a !== null && a !== undefined) return a;
    }
    return null;
}""",
        [],
    ],
    "dateAdd": [
        """function dateAdd(unit, amount, datetime) {
    // transform unit if needed (week -> day, year -> month)
    if (unit === 'week') {
        unit = 'day';
        amount = amount * 7;
    } else if (unit === 'year') {
        unit = 'month';
        amount = amount * 12;
    }
    const interval = __toHogInterval(amount, unit);
    return __applyIntervalToDateTime(datetime, interval);
}""",
        ["__toHogInterval", "__applyIntervalToDateTime"],
    ],
    "dateDiff": [
        """function dateDiff(unit, startVal, endVal) {
    function toDateTime(obj) {
        if (__isHogDateTime(obj)) {
            return new Date(obj.dt * 1000);
        } else if (__isHogDate(obj)) {
            return new Date(Date.UTC(obj.year, obj.month - 1, obj.day));
        } else {
            return new Date(obj);
        }
    }
    const start = toDateTime(startVal);
    const end = toDateTime(endVal);
    const diffMs = end - start;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    if (unit === 'day') {
        return diffDays;
    } else if (unit === 'hour') {
        return Math.floor(diffMs / (1000 * 60 * 60));
    } else if (unit === 'minute') {
        return Math.floor(diffMs / (1000 * 60));
    } else if (unit === 'second') {
        return Math.floor(diffMs / 1000);
    } else if (unit === 'week') {
        return Math.floor(diffDays / 7);
    } else if (unit === 'month') {
        // Approx months difference
        const sy = start.getUTCFullYear();
        const sm = start.getUTCMonth() + 1;
        const ey = end.getUTCFullYear();
        const em = end.getUTCMonth() + 1;
        return (ey - sy)*12 + (em - sm);
    } else if (unit === 'year') {
        return end.getUTCFullYear() - start.getUTCFullYear();
    } else {
        throw new Error("Unsupported unit for dateDiff: " + unit);
    }
}""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "dateTrunc": [
        """function dateTrunc(unit, val) {
    if (!__isHogDateTime(val)) {
        throw new Error('Expected a DateTime for dateTrunc');
    }
    const zone = val.zone || 'UTC';
    const date = new Date(val.dt * 1000);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth();
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = 0;
    let ms = 0;

    if (unit === 'year') {
        month = 0; day = 1; hour = 0; minute = 0; second = 0;
    } else if (unit === 'month') {
        day = 1; hour = 0; minute = 0; second = 0;
    } else if (unit === 'day') {
        hour = 0; minute = 0; second = 0;
    } else if (unit === 'hour') {
        minute = 0; second = 0;
    } else if (unit === 'minute') {
        second = 0;
    } else {
        throw new Error("Unsupported unit for dateTrunc: " + unit);
    }

    const truncated = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
    return { __hogDateTime__: true, dt: truncated.getTime()/1000, zone: zone };
}""",
        ["__isHogDateTime"],
    ],
    "equals": [
        """function equals(a, b) { return a === b }""",
        [],
    ],
    "extract": [
        """function extract(part, val) {
    function toDate(obj) {
        if (__isHogDateTime(obj)) {
            return new Date(obj.dt * 1000);
        } else if (__isHogDate(obj)) {
            return new Date(Date.UTC(obj.year, obj.month - 1, obj.day));
        } else {
            return new Date(obj);
        }
    }
    const date = toDate(val);
    if (part === 'year') return date.getUTCFullYear();
    else if (part === 'month') return date.getUTCMonth() + 1;
    else if (part === 'day') return date.getUTCDate();
    else if (part === 'hour') return date.getUTCHours();
    else if (part === 'minute') return date.getUTCMinutes();
    else if (part === 'second') return date.getUTCSeconds();
    else throw new Error("Unknown extract part: " + part);
}""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "floor": [
        "function floor(a) { return Math.floor(a) }",
        [],
    ],
    "greater": [
        "function greater(a, b) { return a > b }",
        [],
    ],
    "greaterOrEquals": [
        "function greaterOrEquals(a, b) { return a >= b }",
        [],
    ],
    "if": [
        "function __x_if(condition, thenVal, elseVal) { return condition ? thenVal : elseVal }",
        [],
    ],
    "in": [
        """function __x_in(val, arr) {
    if (Array.isArray(arr) || (arr && arr.__isHogTuple)) {
        return arr.includes(val);
    }
    return false;
}""",
        [],
    ],
    "less": [
        "function less(a, b) { return a < b }",
        [],
    ],
    "lessOrEquals": [
        "function lessOrEquals(a, b) { return a <= b }",
        [],
    ],
    "min2": [
        "function min2(a, b) { return a < b ? a : b }",
        [],
    ],
    "minus": [
        "function minus(a, b) { return a - b }",
        [],
    ],
    "multiIf": [
        """function multiIf(...args) {
    // multiIf(cond1,val1, cond2,val2, ..., default)
    const defaultVal = args[args.length-1];
    const pairs = args.slice(0, -1);
    for (let i=0; i<pairs.length; i+=2) {
        if (pairs[i]) { return pairs[i+1]; }
    }
    return defaultVal;
}""",
        [],
    ],
    "not": [
        "function not(a) { return !a }",
        [],
    ],
    "notEquals": [
        "function notEquals(a, b) { return a !== b }",
        [],
    ],
    "and": [
        "function and(...args) { return args.every(Boolean) }",
        [],
    ],
    "or": [
        "function or(...args) { return args.some(Boolean) }",
        [],
    ],
    "plus": [
        "function plus(a, b) { return a + b }",
        [],
    ],
    "range": [
        """function range(...args) {
    if (args.length === 1) {
        const end = args[0];
        return Array.from({length:end}, (_,i)=>i);
    } else {
        const start = args[0];
        const end = args[1];
        return Array.from({length:end - start}, (_,i)=>start+i);
    }
}""",
        [],
    ],
    "round": [
        "function round(a) { return Math.round(a) }",
        [],
    ],
    "startsWith": [
        """function startsWith(str, prefix) {
    return typeof str === 'string' && typeof prefix === 'string' && str.startsWith(prefix);
}""",
        [],
    ],
    "substring": [
        """function substring(s, start, optionalLength) {
    if (typeof s !== 'string') return '';
    const startIdx = start - 1;
    const length = typeof optionalLength === 'number' ? optionalLength : s.length - startIdx;
    if (startIdx < 0 || length < 0) return '';
    const endIdx = startIdx + length;
    return startIdx < s.length ? s.slice(startIdx, endIdx) : '';
}""",
        [],
    ],
    "toIntervalDay": [
        """function toIntervalDay(val) { return __toHogInterval(val, 'day') }""",
        ["__toHogInterval"],
    ],
    "toIntervalHour": [
        """function toIntervalHour(val) { return __toHogInterval(val, 'hour') }""",
        ["__toHogInterval"],
    ],
    "toIntervalMinute": [
        """function toIntervalMinute(val) { return __toHogInterval(val, 'minute') }""",
        ["__toHogInterval"],
    ],
    "toIntervalMonth": [
        """function toIntervalMonth(val) { return __toHogInterval(val, 'month') }""",
        ["__toHogInterval"],
    ],
    "toMonth": [
        "function toMonth(value) { return extract('month', value) }",
        ["extract"],
    ],
    "toStartOfDay": [
        """function toStartOfDay(value) {
    if (!__isHogDateTime(value) && !__isHogDate(value)) {
        throw new Error('Expected HogDate or HogDateTime for toStartOfDay');
    }
    if (__isHogDate(value)) {
        value = __toHogDateTime(Date.UTC(value.year, value.month-1, value.day)/1000, 'UTC');
    }
    return dateTrunc('day', value);
}""",
        ["__isHogDateTime", "__isHogDate", "__toHogDateTime", "dateTrunc"],
    ],
    "toStartOfHour": [
        """function toStartOfHour(value) {
    if (!__isHogDateTime(value) && !__isHogDate(value)) {
        throw new Error('Expected HogDate or HogDateTime for toStartOfHour');
    }
    if (__isHogDate(value)) {
        value = __toHogDateTime(Date.UTC(value.year, value.month-1, value.day)/1000, 'UTC');
    }
    return dateTrunc('hour', value);
}""",
        ["__isHogDateTime", "__isHogDate", "__toHogDateTime", "dateTrunc"],
    ],
    "toStartOfMonth": [
        """function toStartOfMonth(value) {
    if (!__isHogDateTime(value) && !__isHogDate(value)) {
        throw new Error('Expected HogDate or HogDateTime');
    }
    if (__isHogDate(value)) {
        value = __toHogDateTime(Date.UTC(value.year, value.month-1, value.day)/1000, 'UTC');
    }
    return dateTrunc('month', value);
}""",
        ["__isHogDateTime", "__isHogDate", "__toHogDateTime", "dateTrunc"],
    ],
    "toStartOfWeek": [
        """function toStartOfWeek(value) {
    if (!__isHogDateTime(value) && !__isHogDate(value)) {
        throw new Error('Expected HogDate or HogDateTime');
    }
    let d;
    if (__isHogDate(value)) {
        d = new Date(Date.UTC(value.year, value.month - 1, value.day));
    } else {
        d = new Date(value.dt * 1000);
    }
    // Monday=1,... Sunday=7
    // getUTCDay(): Sunday=0,... Saturday=6
    // We want ISO weekday: Monday=1,... Sunday=7
    let dayOfWeek = d.getUTCDay(); // Sunday=0,...
    let isoWeekday = dayOfWeek === 0 ? 7 : dayOfWeek;

    // subtract isoWeekday-1 days
    const start = new Date(d.getTime() - (isoWeekday - 1) * 24 * 3600 * 1000);

    // Zero out hours, minutes, seconds, ms
    start.setUTCHours(0, 0, 0, 0);

    return { __hogDateTime__: true, dt: start.getTime() / 1000, zone: (__isHogDateTime(value) ? value.zone : 'UTC') };
}""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "toYYYYMM": [
        """function toYYYYMM(value) {
    const y = extract('year', value);
    const m = extract('month', value);
    return y*100 + m;
}""",
        ["extract"],
    ],
    "toYear": [
        "function toYear(value) { return extract('year', value) }",
        ["extract"],
    ],
    "today": [
        """function today() {
    const now = new Date();
    return __toHogDate(now.getUTCFullYear(), now.getUTCMonth()+1, now.getUTCDate());
}""",
        ["__toHogDate"],
    ],
}


def import_stl_functions(requested_functions):
    """
    Given a list of requested function names, returns a string containing the code
    for these functions and all their dependencies, in an order suitable for evaluation.
    """

    # Set to keep track of all required functions
    required_functions = set()
    visited = set()

    # Recursive function to find all dependencies
    def dfs(func_name):
        if func_name in visited:
            return
        visited.add(func_name)
        if func_name not in STL_FUNCTIONS:
            raise ValueError(f"Function '{func_name}' is not defined.")
        _, dependencies = STL_FUNCTIONS[func_name]
        for dep in sorted(dependencies):
            dfs(dep)
        required_functions.add(func_name)

    # Start DFS from each requested function
    for func in requested_functions:
        dfs(func)

    # Build the dependency graph
    dependency_graph = {}
    for func in sorted(required_functions):
        _, dependencies = STL_FUNCTIONS[func]
        dependency_graph[func] = dependencies

    # Perform topological sort
    def topological_sort(graph):
        visited = set()
        temp_mark = set()
        result = []

        def visit(node):
            if node in visited:
                return
            if node in temp_mark:
                raise ValueError(f"Circular dependency detected involving {node}")
            temp_mark.add(node)
            for neighbor in sorted(graph.get(node, [])):
                visit(neighbor)
            temp_mark.remove(node)
            visited.add(node)
            result.append(node)

        for node in sorted(graph):
            visit(node)
        return result[::-1]  # reverse the list to get correct order

    sorted_functions = topological_sort(dependency_graph)

    # Build the final code
    code_pieces = []
    for func in sorted_functions:
        code, _ = STL_FUNCTIONS[func]
        code_pieces.append(str(code).strip())

    return "\n".join(code_pieces)
