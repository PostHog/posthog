# TODO: this should be autogenerated from hogvm/typescript/src/stl/*

STL_FUNCTIONS: dict[str, list[str | list[str]]] = {
    "concat": [
        "function concat (...args) { return args.map((arg) => (arg === null ? '' : __STLToString(arg))).join('') }",
        ["__STLToString"],
    ],
    "match": [
        "function match (str, pattern) { return new RegExp(pattern).test(str) }",
        [],
    ],
    "like": [
        "function like (str, pattern) { return __like(str, pattern, false) }",
        ["__like"],
    ],
    "ilike": [
        "function ilike (str, pattern) { return __like(str, pattern, true) }",
        ["__like"],
    ],
    "notLike": [
        "function notLike (str, pattern) { return !__like(str, pattern, false) }",
        ["__like"],
    ],
    "notILike": [
        "function notILike (str, pattern) { return !__like(str, pattern, true) }",
        ["__like"],
    ],
    "toString": [
        "function toString (value) { return __STLToString(value) }",
        ["__STLToString"],
    ],
    "toUUID": [
        "function toUUID (value) { return __STLToString(value) }",
        ["__STLToString"],
    ],
    "toInt": [
        """function toInt(value) {
    if (__isHogDateTime(value)) { return Math.floor(value.dt); }
    else if (__isHogDate(value)) { const date = new Date(Date.UTC(value.year, value.month - 1, value.day)); const epoch = new Date(Date.UTC(1970, 0, 1)); const diffInDays = Math.floor((date - epoch) / (1000 * 60 * 60 * 24)); return diffInDays; }
    return !isNaN(parseInt(value)) ? parseInt(value) : null; }""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "toFloat": [
        """function toFloat(value) {
    if (__isHogDateTime(value)) { return value.dt; }
    else if (__isHogDate(value)) { const date = new Date(Date.UTC(value.year, value.month - 1, value.day)); const epoch = new Date(Date.UTC(1970, 0, 1)); const diffInDays = (date - epoch) / (1000 * 60 * 60 * 24); return diffInDays; }
    return !isNaN(parseFloat(value)) ? parseFloat(value) : null; }""",
        ["__isHogDateTime", "__isHogDate"],
    ],
    "ifNull": [
        "function ifNull (value, defaultValue) { return value !== null ? value : defaultValue } ",
        [],
    ],
    "length": [
        "function length (value) { return value.length }",
        [],
    ],
    "empty": [
        """function empty (value) {
    if (typeof value === 'object') {
        if (Array.isArray(value)) { return value.length === 0 } else if (value === null) { return true } else if (value instanceof Map) { return value.size === 0 }
        return Object.keys(value).length === 0
    } else if (typeof value === 'number' || typeof value === 'boolean') { return false }
    return !value }""",
        [],
    ],
    "notEmpty": [
        "function notEmpty (value) { return !empty(value) }",
        ["empty"],
    ],
    "tuple": [
        "function tuple (...args) { const tuple = args.slice(); tuple.__isHogTuple = true; return tuple; }",
        [],
    ],
    "lower": [
        "function lower (value) { return value.toLowerCase() }",
        [],
    ],
    "upper": [
        "function upper (value) { return value.toUpperCase() }",
        [],
    ],
    "reverse": [
        "function reverse (value) { return value.split('').reverse().join('') }",
        [],
    ],
    "print": [
        "function print (...args) { console.log(...args.map(__printHogStringOutput)) }",
        ["__printHogStringOutput"],
    ],
    "jsonParse": [
        """function jsonParse (str) {
    function convert(x) {
        if (Array.isArray(x)) { return x.map(convert) }
        else if (typeof x === 'object' && x !== null) {
            if (x.__hogDateTime__) { return __toHogDateTime(x.dt, x.zone)
            } else if (x.__hogDate__) { return __toHogDate(x.year, x.month, x.day)
            } else if (x.__hogError__) { return __newHogError(x.type, x.message, x.payload) }
            const obj = {}; for (const key in x) { obj[key] = convert(x[key]) }; return obj }
        return x }
    return convert(JSON.parse(str)) }""",
        ["__toHogDateTime", "__toHogDate", "__newHogError"],
    ],
    "jsonStringify": [
        """function jsonStringify (value, spacing) {
    function convert(x, marked) {
        if (!marked) { marked = new Set() }
        if (typeof x === 'object' && x !== null) {
            if (marked.has(x)) { return null }
            marked.add(x)
            try {
                if (x instanceof Map) {
                    const obj = {}
                    x.forEach((value, key) => { obj[convert(key, marked)] = convert(value, marked) })
                    return obj
                }
                if (Array.isArray(x)) { return x.map((v) => convert(v, marked)) }
                if (__isHogDateTime(x) || __isHogDate(x) || __isHogError(x)) { return x }
                if (typeof x === 'function') { return `fn<${x.name || 'lambda'}(${x.length})>` }
                const obj = {}; for (const key in x) { obj[key] = convert(x[key], marked) }
                return obj
            } finally {
                marked.delete(x)
            }
        }
        return x
    }
    if (spacing && typeof spacing === 'number' && spacing > 0) {
        return JSON.stringify(convert(value), null, spacing)
    }
    return JSON.stringify(convert(value), (key, val) => typeof val === 'function' ? `fn<${val.name || 'lambda'}(${val.length})>` : val)
}""",
        ["__isHogDateTime", "__isHogDate", "__isHogError"],
    ],
    "JSONHas": [
        """function JSONHas (obj, ...path) {
    let current = obj
    for (const key of path) {
        let currentParsed = current
        if (typeof current === 'string') { try { currentParsed = JSON.parse(current) } catch (e) { return false } }
        if (currentParsed instanceof Map) { if (!currentParsed.has(key)) { return false }; current = currentParsed.get(key) }
        else if (typeof currentParsed === 'object' && currentParsed !== null) {
            if (typeof key === 'number') {
                if (Array.isArray(currentParsed)) {
                    if (key < 0) { if (key < -currentParsed.length) { return false }; current = currentParsed[currentParsed.length + key] }
                    else if (key === 0) { return false }
                    else { if (key > currentParsed.length) { return false }; current = currentParsed[key - 1] }
                } else { return false }
            } else {
                if (!(key in currentParsed)) { return false }
                current = currentParsed[key]
            }
        } else { return false }
    }
    return true }""",
        [],
    ],
    "isValidJSON": [
        "function isValidJSON (str) { try { JSON.parse(str); return true } catch (e) { return false } }",
        [],
    ],
    "JSONLength": [
        """function JSONLength (obj, ...path) {
    try { if (typeof obj === 'string') { obj = JSON.parse(obj) } } catch (e) { return 0 }
    if (typeof obj === 'object' && obj !== null) {
        const value = __getNestedValue(obj, path, true)
        if (Array.isArray(value)) {
            return value.length
        } else if (value instanceof Map) {
            return value.size
        } else if (typeof value === 'object' && value !== null) {
            return Object.keys(value).length
        }
    }
    return 0 }""",
        ["__getNestedValue"],
    ],
    "JSONExtractBool": [
        """function JSONExtractBool (obj, ...path) {
    try {
        if (typeof obj === 'string') {
            obj = JSON.parse(obj)
        }
    } catch (e) {
        return false
    }
    if (path.length > 0) {
        obj = __getNestedValue(obj, path, true)
    }
    if (typeof obj === 'boolean') {
        return obj
    }
    return false
}""",
        ["__getNestedValue"],
    ],
    "base64Encode": [
        "function base64Encode (str) { return Buffer.from(str).toString('base64') }",
        [],
    ],
    "base64Decode": [
        "function base64Decode (str) { return Buffer.from(str, 'base64').toString() } ",
        [],
    ],
    "tryBase64Decode": [
        "function tryBase64Decode (str) { try { return Buffer.from(str, 'base64').toString() } catch (e) { return '' } }",
        [],
    ],
    "encodeURLComponent": [
        "function encodeURLComponent (str) { return encodeURIComponent(str) }",
        [],
    ],
    "decodeURLComponent": [
        "function decodeURLComponent (str) { return decodeURIComponent(str) }",
        [],
    ],
    "replaceOne": [
        "function replaceOne (str, searchValue, replaceValue) { return str.replace(searchValue, replaceValue) }",
        [],
    ],
    "replaceAll": [
        "function replaceAll (str, searchValue, replaceValue) { return str.replaceAll(searchValue, replaceValue) }",
        [],
    ],
    "position": [
        "function position (str, elem) { if (typeof str === 'string') { return str.indexOf(String(elem)) + 1 } else { return 0 } }",
        [],
    ],
    "positionCaseInsensitive": [
        "function positionCaseInsensitive (str, elem) { if (typeof str === 'string') { return str.toLowerCase().indexOf(String(elem).toLowerCase()) + 1 } else { return 0 } }",
        [],
    ],
    "trim": [
        """function trim (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let start = 0
    while (str[start] === char) {
        start++
    }
    let end = str.length
    while (str[end - 1] === char) {
        end--
    }
    if (start >= end) {
        return ''
    }
    return str.slice(start, end)
}""",
        [],
    ],
    "trimLeft": [
        """function trimLeft (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let start = 0
    while (str[start] === char) {
        start++
    }
    return str.slice(start)
}""",
        [],
    ],
    "trimRight": [
        """function trimRight (str, char) {
    if (char === null || char === undefined) {
        char = ' '
    }
    if (char.length !== 1) {
        return ''
    }
    let end = str.length
    while (str[end - 1] === char) {
        end--
    }
    return str.slice(0, end)
}""",
        [],
    ],
    "splitByString": [
        "function splitByString (separator, str, maxSplits) { if (maxSplits === undefined || maxSplits === null) { return str.split(separator) } return str.split(separator, maxSplits) }",
        [],
    ],
    "generateUUIDv4": [
        "function generateUUIDv4 () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = (Math.random() * 16) | 0; const v = c === 'x' ? r : (r & 0x3) | 0x8; return v.toString(16) })}",
        [],
    ],
    "sha256Hex": [
        "function sha256Hex (str, options) { return 'SHA256 is not implemented' }",
        [],
    ],
    "md5Hex": [
        """function md5Hex(string) { return 'MD5 is not implemented' }""",
        [],
    ],
    "sha256HmacChainHex": [
        "function sha256HmacChainHex (data, options) { return 'sha256HmacChainHex not implemented' }",
        [],
    ],
    "keys": [
        """function keys (obj) { if (typeof obj === 'object' && obj !== null) { if (Array.isArray(obj)) { return Array.from(obj.keys()) } else if (obj instanceof Map) { return Array.from(obj.keys()) } return Object.keys(obj) } return [] }""",
        [],
    ],
    "values": [
        """function values (obj) { if (typeof obj === 'object' && obj !== null) { if (Array.isArray(obj)) { return [...obj] } else if (obj instanceof Map) { return Array.from(obj.values()) } return Object.values(obj) } return [] }""",
        [],
    ],
    "indexOf": [
        "function indexOf (arrOrString, elem) { if (Array.isArray(arrOrString)) { return arrOrString.indexOf(elem) + 1 } else { return 0 } }",
        [],
    ],
    "arrayPushBack": [
        "function arrayPushBack (arr, item) { if (!Array.isArray(arr)) { return [item] } return [...arr, item] }",
        [],
    ],
    "arrayPushFront": [
        "function arrayPushFront (arr, item) { if (!Array.isArray(arr)) { return [item] } return [item, ...arr] }",
        [],
    ],
    "arrayPopBack": [
        "function arrayPopBack (arr) { if (!Array.isArray(arr)) { return [] } return arr.slice(0, arr.length - 1) }",
        [],
    ],
    "arrayPopFront": [
        "function arrayPopFront (arr) { if (!Array.isArray(arr)) { return [] } return arr.slice(1) }",
        [],
    ],
    "arraySort": [
        "function arraySort (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].sort() }",
        [],
    ],
    "arrayReverse": [
        "function arrayReverse (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].reverse() }",
        [],
    ],
    "arrayReverseSort": [
        "function arrayReverseSort (arr) { if (!Array.isArray(arr)) { return [] } return [...arr].sort().reverse() }",
        [],
    ],
    "arrayStringConcat": [
        "function arrayStringConcat (arr, separator = '') { if (!Array.isArray(arr)) { return '' } return arr.join(separator) }",
        [],
    ],
    "arrayCount": [
        "function arrayCount (func, arr) { let count = 0; for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { count = count + 1 } } return count }",
        [],
    ],
    "arrayExists": [
        """function arrayExists (func, arr) { for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { return true } } return false }""",
        [],
    ],
    "arrayFilter": [
        """function arrayFilter (func, arr) { let result = []; for (let i = 0; i < arr.length; i++) { if (func(arr[i])) { result = arrayPushBack(result, arr[i]) } } return result}""",
        ["arrayPushBack"],
    ],
    "arrayMap": [
        """function arrayMap (func, arr) { let result = []; for (let i = 0; i < arr.length; i++) { result = arrayPushBack(result, func(arr[i])) } return result }""",
        ["arrayPushBack"],
    ],
    "has": [
        """function has (arr, elem) { if (!Array.isArray(arr) || arr.length === 0) { return false } return arr.includes(elem) }""",
        [],
    ],
    "now": [
        """function now () { return __now() }""",
        ["__now"],
    ],
    "toUnixTimestamp": [
        """function toUnixTimestamp (input, zone) { return __toUnixTimestamp(input, zone) }""",
        ["__toUnixTimestamp"],
    ],
    "fromUnixTimestamp": [
        """function fromUnixTimestamp (input) { return __fromUnixTimestamp(input) }""",
        ["__fromUnixTimestamp"],
    ],
    "toUnixTimestampMilli": [
        """function toUnixTimestampMilli (input, zone) { return __toUnixTimestampMilli(input, zone) }""",
        ["__toUnixTimestampMilli"],
    ],
    "fromUnixTimestampMilli": [
        """function fromUnixTimestampMilli (input) { return __fromUnixTimestampMilli(input) }""",
        ["__fromUnixTimestampMilli"],
    ],
    "toTimeZone": [
        """function toTimeZone (input, zone) { return __toTimeZone(input, zone) }""",
        ["__toTimeZone"],
    ],
    "toDate": [
        """function toDate (input) { return __toDate(input) }""",
        ["__toDate"],
    ],
    "toDateTime": [
        """function toDateTime (input, zone) { return __toDateTime(input, zone) }""",
        ["__toDateTime"],
    ],
    "formatDateTime": [
        """function formatDateTime (input, format, zone) { return __formatDateTime(input, format, zone) }""",
        ["__formatDateTime"],
    ],
    "HogError": [
        """function HogError (type, message, payload) { return __newHogError(type, message, payload) }""",
        ["__newHogError"],
    ],
    "Error": [
        """function __x_Error (message, payload) { return __newHogError('Error', message, payload) }""",
        ["__newHogError"],
    ],
    "RetryError": [
        """function RetryError (message, payload) { return __newHogError('RetryError', message, payload) }""",
        ["__newHogError"],
    ],
    "NotImplementedError": [
        """function NotImplementedError (message, payload) { return __newHogError('NotImplementedError', message, payload) }""",
        ["__newHogError"],
    ],
    "typeof": [
        """function __x_typeof (value) {
    if (value === null || value === undefined) { return 'null'
    } else if (__isHogDateTime(value)) { return 'datetime'
    } else if (__isHogDate(value)) { return 'date'
    } else if (__isHogError(value)) { return 'error'
    } else if (typeof value === 'function') { return 'function'
    } else if (Array.isArray(value)) { if (value.__isHogTuple) { return 'tuple' } return 'array'
    } else if (typeof value === 'object') { return 'object'
    } else if (typeof value === 'number') { return Number.isInteger(value) ? 'integer' : 'float'
    } else if (typeof value === 'string') { return 'string'
    } else if (typeof value === 'boolean') { return 'boolean' }
    return 'unknown'
}
""",
        ["__isHogDateTime", "__isHogDate", "__isHogError"],
    ],
    "__DateTimeToString": [
        r"""function __DateTimeToString(dt) {
    if (__isHogDateTime(dt)) {
        const date = new Date(dt.dt * 1000);
        const timeZone = dt.zone || 'UTC';
        const milliseconds = Math.floor(dt.dt * 1000 % 1000);
        const options = { timeZone, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const formatter = new Intl.DateTimeFormat('en-US', options);
        const parts = formatter.formatToParts(date);
        let year, month, day, hour, minute, second;
        for (const part of parts) {
            switch (part.type) {
                case 'year': year = part.value; break;
                case 'month': month = part.value; break;
                case 'day': day = part.value; break;
                case 'hour': hour = part.value; break;
                case 'minute': minute = part.value; break;
                case 'second': second = part.value; break;
                default: break;
            }
        }
        const getOffset = (date, timeZone) => {
            const tzDate = new Date(date.toLocaleString('en-US', { timeZone }));
            const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));
            const offset = (tzDate - utcDate) / 60000; // in minutes
            const sign = offset >= 0 ? '+' : '-';
            const absOffset = Math.abs(offset);
            const hours = Math.floor(absOffset / 60);
            const minutes = absOffset % 60;
            return `${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        };
        let offset = 'Z';
        if (timeZone !== 'UTC') {
            offset = getOffset(date, timeZone);
        }
        let isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
        isoString += `.${milliseconds.toString().padStart(3, '0')}`;
        isoString += offset;
        return isoString;
    }
}
    """,
        [],
    ],
    "__STLToString": [
        r"""function __STLToString(arg) {
    if (arg && __isHogDate(arg)) { return `${arg.year}-${arg.month.toString().padStart(2, '0')}-${arg.day.toString().padStart(2, '0')}`; }
    else if (arg && __isHogDateTime(arg)) { return __DateTimeToString(arg); }
    return __printHogStringOutput(arg); }""",
        ["__isHogDate", "__isHogDateTime", "__printHogStringOutput", "__DateTimeToString"],
    ],
    "__isHogDate": [
        """function __isHogDate(obj) { return obj && obj.__hogDate__ === true }""",
        [],
    ],
    "__isHogDateTime": [
        """function __isHogDateTime(obj) { return obj && obj.__hogDateTime__ === true }""",
        [],
    ],
    "__toHogDate": [
        """function __toHogDate(year, month, day) { return { __hogDate__: true, year: year, month: month, day: day, } }""",
        [],
    ],
    "__toHogDateTime": [
        """function __toHogDateTime(timestamp, zone) {
    if (__isHogDate(timestamp)) {
        const date = new Date(Date.UTC(timestamp.year, timestamp.month - 1, timestamp.day));
        const dt = date.getTime() / 1000;
        return { __hogDateTime__: true, dt: dt, zone: zone || 'UTC' };
    }
    return { __hogDateTime__: true, dt: timestamp, zone: zone || 'UTC' }; }""",
        ["__isHogDate"],
    ],
    "__now": [
        """function __now(zone) { return __toHogDateTime(Date.now() / 1000, zone) }""",
        ["__toHogDateTime"],
    ],
    "__toUnixTimestamp": [
        """function __toUnixTimestamp(input, zone) {
    if (__isHogDateTime(input)) { return input.dt; }
    if (__isHogDate(input)) { return __toHogDateTime(input).dt; }
    const date = new Date(input);
    if (isNaN(date.getTime())) { throw new Error('Invalid date input'); }
    return Math.floor(date.getTime() / 1000);}""",
        ["__isHogDateTime", "__isHogDate", "__toHogDateTime"],
    ],
    "__fromUnixTimestamp": [
        """function __fromUnixTimestamp(input) { return __toHogDateTime(input) }""",
        ["__toHogDateTime"],
    ],
    "__toUnixTimestampMilli": [
        """function __toUnixTimestampMilli(input, zone) { return __toUnixTimestamp(input, zone) * 1000 }""",
        ["__toUnixTimestamp"],
    ],
    "__fromUnixTimestampMilli": [
        """function __fromUnixTimestampMilli(input) { return __toHogDateTime(input / 1000) }""",
        ["__toHogDateTime"],
    ],
    "__toTimeZone": [
        """function __toTimeZone(input, zone) { if (!__isHogDateTime(input)) { throw new Error('Expected a DateTime') }; return { ...input, zone }}""",
        ["__isHogDateTime"],
    ],
    "__toDate": [
        """function __toDate(input) { let date;
    if (typeof input === 'number') { date = new Date(input * 1000); } else { date = new Date(input); }
    if (isNaN(date.getTime())) { throw new Error('Invalid date input'); }
    return { __hogDate__: true, year: date.getUTCFullYear(), month: date.getUTCMonth() + 1, day: date.getUTCDate() }; }""",
        [],
    ],
    "__toDateTime": [
        """function __toDateTime(input, zone) { let dt;
    if (typeof input === 'number') { dt = input; }
    else { const date = new Date(input); if (isNaN(date.getTime())) { throw new Error('Invalid date input'); } dt = date.getTime() / 1000; }
    return { __hogDateTime__: true, dt: dt, zone: zone || 'UTC' }; }""",
        [],
    ],
    "__formatDateTime": [
        """function __formatDateTime(input, format, zone) {
    if (!__isHogDateTime(input)) { throw new Error('Expected a DateTime'); }
    if (!format) { throw new Error('formatDateTime requires at least 2 arguments'); }
    const timestamp = input.dt * 1000;
    let date = new Date(timestamp);
    if (!zone) { zone = 'UTC'; }
    const padZero = (num, len = 2) => String(num).padStart(len, '0');
    const padSpace = (num, len = 2) => String(num).padStart(len, ' ');
    const getDateComponent = (type, options = {}) => {
        const formatter = new Intl.DateTimeFormat('en-US', { ...options, timeZone: zone });
        const parts = formatter.formatToParts(date);
        const part = parts.find(p => p.type === type);
        return part ? part.value : '';
    };
    const getNumericComponent = (type, options = {}) => {
        const value = getDateComponent(type, options);
        return parseInt(value, 10);
    };
    const getWeekNumber = (d) => {
        const dateInZone = new Date(d.toLocaleString('en-US', { timeZone: zone }));
        const target = new Date(Date.UTC(dateInZone.getFullYear(), dateInZone.getMonth(), dateInZone.getDate()));
        const dayNr = (target.getUTCDay() + 6) % 7;
        target.setUTCDate(target.getUTCDate() - dayNr + 3);
        const firstThursday = new Date(Date.UTC(target.getUTCFullYear(), 0, 4));
        const weekNumber = 1 + Math.round(((target - firstThursday) / 86400000 - 3 + ((firstThursday.getUTCDay() + 6) % 7)) / 7);
        return weekNumber;
    };
    const getDayOfYear = (d) => {
        const startOfYear = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        const dateInZone = new Date(d.toLocaleString('en-US', { timeZone: zone }));
        const diff = dateInZone - startOfYear;
        return Math.floor(diff / 86400000) + 1;
    };
    // Token mapping with corrections
    const tokens = {
        '%a': () => getDateComponent('weekday', { weekday: 'short' }),
        '%b': () => getDateComponent('month', { month: 'short' }),
        '%c': () => padZero(getNumericComponent('month', { month: '2-digit' })),
        '%C': () => getDateComponent('year', { year: '2-digit' }),
        '%d': () => padZero(getNumericComponent('day', { day: '2-digit' })),
        '%D': () => {
            const month = padZero(getNumericComponent('month', { month: '2-digit' }));
            const day = padZero(getNumericComponent('day', { day: '2-digit' }));
            const year = getDateComponent('year', { year: '2-digit' });
            return `${month}/${day}/${year}`;
        },
        '%e': () => padSpace(getNumericComponent('day', { day: 'numeric' })),
        '%F': () => {
            const year = getNumericComponent('year', { year: 'numeric' });
            const month = padZero(getNumericComponent('month', { month: '2-digit' }));
            const day = padZero(getNumericComponent('day', { day: '2-digit' }));
            return `${year}-${month}-${day}`;
        },
        '%g': () => getDateComponent('year', { year: '2-digit' }),
        '%G': () => getNumericComponent('year', { year: 'numeric' }),
        '%h': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%H': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false })),
        '%i': () => padZero(getNumericComponent('minute', { minute: '2-digit' })),
        '%I': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%j': () => padZero(getDayOfYear(date), 3),
        '%k': () => padSpace(getNumericComponent('hour', { hour: 'numeric', hour12: false })),
        '%l': () => padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true })),
        '%m': () => padZero(getNumericComponent('month', { month: '2-digit' })),
        '%M': () => getDateComponent('month', { month: 'long' }),
        '%n': () => '\\n',
        '%p': () => getDateComponent('dayPeriod', { hour: 'numeric', hour12: true }),
        '%r': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: true }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            const second = padZero(getNumericComponent('second', { second: '2-digit' }));
            const period = getDateComponent('dayPeriod', { hour: 'numeric', hour12: true });
            return `${hour}:${minute} ${period}`;
        },
        '%R': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            return `${hour}:${minute}`;
        },
        '%s': () => padZero(getNumericComponent('second', { second: '2-digit' })),
        '%S': () => padZero(getNumericComponent('second', { second: '2-digit' })),
        '%t': () => '\\t',
        '%T': () => {
            const hour = padZero(getNumericComponent('hour', { hour: '2-digit', hour12: false }));
            const minute = padZero(getNumericComponent('minute', { minute: '2-digit' }));
            const second = padZero(getNumericComponent('second', { second: '2-digit' }));
            return `${hour}:${minute}:${second}`;
        },
        '%u': () => {
            let day = getDateComponent('weekday', { weekday: 'short' });
            const dayMap = { 'Mon': '1', 'Tue': '2', 'Wed': '3', 'Thu': '4', 'Fri': '5', 'Sat': '6', 'Sun': '7' };
            return dayMap[day];
        },
        '%V': () => padZero(getWeekNumber(date)),
        '%w': () => {
            let day = getDateComponent('weekday', { weekday: 'short' });
            const dayMap = { 'Sun': '0', 'Mon': '1', 'Tue': '2', 'Wed': '3', 'Thu': '4', 'Fri': '5', 'Sat': '6' };
            return dayMap[day];
        },
        '%W': () => getDateComponent('weekday', { weekday: 'long' }),
        '%y': () => getDateComponent('year', { year: '2-digit' }),
        '%Y': () => getNumericComponent('year', { year: 'numeric' }),
        '%z': () => {
            if (zone === 'UTC') {
                return '+0000';
            } else {
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: zone,
                    timeZoneName: 'shortOffset',
                });
                const parts = formatter.formatToParts(date);
                const offsetPart = parts.find(part => part.type === 'timeZoneName');
                if (offsetPart && offsetPart.value) {
                    const offsetValue = offsetPart.value;
                    const match = offsetValue.match(/GMT([+-]\\d{1,2})(?::(\\d{2}))?/);
                    if (match) {
                        const sign = match[1][0];
                        const hours = padZero(Math.abs(parseInt(match[1], 10)));
                        const minutes = padZero(match[2] ? parseInt(match[2], 10) : 0);
                        return `${sign}${hours}${minutes}`;
                    }
                }
                return '';
            }
        },
        '%%': () => '%',
    };

    // Replace tokens in the format string
    let result = '';
    let i = 0;
    while (i < format.length) {
        if (format[i] === '%') {
            const token = format.substring(i, i + 2);
            if (tokens[token]) {
                result += tokens[token]();
                i += 2;
            } else {
                // If token not found, include '%' and move to next character
                result += format[i];
                i += 1;
            }
        } else {
            result += format[i];
            i += 1;
        }
    }

    return result;
}
""",
        ["__isHogDateTime"],
    ],
    "__printHogStringOutput": [
        """function __printHogStringOutput(obj) { if (typeof obj === 'string') { return obj } return __printHogValue(obj) } """,
        ["__printHogValue"],
    ],
    "__printHogValue": [
        """
function __printHogValue(obj, marked = new Set()) {
    if (typeof obj === 'object' && obj !== null && obj !== undefined) {
        if (marked.has(obj) && !__isHogDateTime(obj) && !__isHogDate(obj) && !__isHogError(obj)) { return 'null'; }
        marked.add(obj);
        try {
            if (Array.isArray(obj)) {
                if (obj.__isHogTuple) { return obj.length < 2 ? `tuple(${obj.map((o) => __printHogValue(o, marked)).join(', ')})` : `(${obj.map((o) => __printHogValue(o, marked)).join(', ')})`; }
                return `[${obj.map((o) => __printHogValue(o, marked)).join(', ')}]`;
            }
            if (__isHogDateTime(obj)) { const millis = String(obj.dt); return `DateTime(${millis}${millis.includes('.') ? '' : '.0'}, ${__escapeString(obj.zone)})`; }
            if (__isHogDate(obj)) return `Date(${obj.year}, ${obj.month}, ${obj.day})`;
            if (__isHogError(obj)) { return `${String(obj.type)}(${__escapeString(obj.message)}${obj.payload ? `, ${__printHogValue(obj.payload, marked)}` : ''})`; }
            if (obj instanceof Map) { return `{${Array.from(obj.entries()).map(([key, value]) => `${__printHogValue(key, marked)}: ${__printHogValue(value, marked)}`).join(', ')}}`; }
            return `{${Object.entries(obj).map(([key, value]) => `${__printHogValue(key, marked)}: ${__printHogValue(value, marked)}`).join(', ')}}`;
        } finally {
            marked.delete(obj);
        }
    } else if (typeof obj === 'boolean') return obj ? 'true' : 'false';
    else if (obj === null || obj === undefined) return 'null';
    else if (typeof obj === 'string') return __escapeString(obj);
            if (typeof obj === 'function') return `fn<${__escapeIdentifier(obj.name || 'lambda')}(${obj.length})>`;
    return obj.toString();
}
""",
        [
            "__isHogDateTime",
            "__isHogDate",
            "__isHogError",
            "__escapeString",
            "__escapeIdentifier",
        ],
    ],
    "__escapeString": [
        """
function __escapeString(value) {
    const singlequoteEscapeCharsMap = { '\\b': '\\\\b', '\\f': '\\\\f', '\\r': '\\\\r', '\\n': '\\\\n', '\\t': '\\\\t', '\\0': '\\\\0', '\\v': '\\\\v', '\\\\': '\\\\\\\\', "'": "\\\\'" }
    return `'${value.split('').map((c) => singlequoteEscapeCharsMap[c] || c).join('')}'`;
}
""",
        [],
    ],
    "__escapeIdentifier": [
        """
function __escapeIdentifier(identifier) {
    const backquoteEscapeCharsMap = { '\\b': '\\\\b', '\\f': '\\\\f', '\\r': '\\\\r', '\\n': '\\\\n', '\\t': '\\\\t', '\\0': '\\\\0', '\\v': '\\\\v', '\\\\': '\\\\\\\\', '`': '\\\\`' }
    if (typeof identifier === 'number') return identifier.toString();
    if (/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(identifier)) return identifier;
    return `\\`${identifier.split('').map((c) => backquoteEscapeCharsMap[c] || c).join('')}\\``;
}
""",
        [],
    ],
    "__newHogError": [
        """
function __newHogError(type, message, payload) {
    let error = new Error(message || 'An error occurred');
    error.__hogError__ = true
    error.type = type
    error.payload = payload
    return error
}
""",
        [],
    ],
    "__isHogError": [
        """function __isHogError(obj) {return obj && obj.__hogError__ === true}""",
        [],
    ],
    "__getNestedValue": [
        """
function __getNestedValue(obj, path, allowNull = false) {
    let current = obj
    for (const key of path) {
        if (current == null) {
            return null
        }
        if (current instanceof Map) {
            current = current.get(key)
        } else if (typeof current === 'object' && current !== null) {
            current = current[key]
        } else {
            return null
        }
    }
    if (current === null && !allowNull) {
        return null
    }
    return current
}
""",
        [],
    ],
    "__like": [
        """
function __like(str, pattern, caseInsensitive = false) {
    if (caseInsensitive) {
        str = str.toLowerCase()
        pattern = pattern.toLowerCase()
    }
    pattern = String(pattern)
        .replaceAll(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')
        .replaceAll('%', '.*')
        .replaceAll('_', '.')
    return new RegExp(pattern).test(str)
}
""",
        [],
    ],
    "__getProperty": [
        """
function __getProperty(objectOrArray, key, nullish) {
    if ((nullish && !objectOrArray) || key === 0) { return null }
    if (Array.isArray(objectOrArray)) {
        return key > 0 ? objectOrArray[key - 1] : objectOrArray[objectOrArray.length + key]
    } else {
        return objectOrArray[key]
    }
}
""",
        [],
    ],
    "__setProperty": [
        """
function __setProperty(objectOrArray, key, value) {
    if (Array.isArray(objectOrArray)) {
        if (key > 0) {
            objectOrArray[key - 1] = value
        } else {
            objectOrArray[objectOrArray.length + key] = value
        }
    } else {
        objectOrArray[key] = value
    }
    return objectOrArray
}
""",
        [],
    ],
    "__lambda": [
        """function __lambda (fn) { return fn }""",
        [],
    ],
}


def import_stl_functions(requested_functions):
    """
    Given a list of requested function names, returns a string containing the code
    for these functions and all their dependencies, in an order suitable for evaluation.
    """

    # Set to keep track of all required functions
    required_functions = set()
    visited = set()

    # Recursive function to find all dependencies
    def dfs(func_name):
        if func_name in visited:
            return
        visited.add(func_name)
        if func_name not in STL_FUNCTIONS:
            raise ValueError(f"Function '{func_name}' is not defined.")
        _, dependencies = STL_FUNCTIONS[func_name]
        for dep in sorted(dependencies):
            dfs(dep)
        required_functions.add(func_name)

    # Start DFS from each requested function
    for func in requested_functions:
        dfs(func)

    # Build the dependency graph
    dependency_graph = {}
    for func in sorted(required_functions):
        _, dependencies = STL_FUNCTIONS[func]
        dependency_graph[func] = dependencies

    # Perform topological sort
    def topological_sort(graph):
        visited = set()
        temp_mark = set()
        result = []

        def visit(node):
            if node in visited:
                return
            if node in temp_mark:
                raise ValueError(f"Circular dependency detected involving {node}")
            temp_mark.add(node)
            for neighbor in sorted(graph.get(node, [])):
                visit(neighbor)
            temp_mark.remove(node)
            visited.add(node)
            result.append(node)

        for node in sorted(graph):
            visit(node)
        return result[::-1]  # reverse the list to get correct order

    sorted_functions = topological_sort(dependency_graph)

    # Build the final code
    code_pieces = []
    for func in sorted_functions:
        code, _ = STL_FUNCTIONS[func]
        code_pieces.append(str(code).strip())

    return "\n".join(code_pieces)
