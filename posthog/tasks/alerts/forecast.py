import uuid
from typing import cast

from django.conf import settings

import structlog

from posthog.schema import ForecastAlertConfig, IntervalType, TrendsQuery

from posthog.api.services.query import ExecutionMode
from posthog.caching.calculate_results import calculate_for_query_based_insight
from posthog.models import AlertConfiguration, Insight
from posthog.models.alert import ForecastResult
from posthog.tasks.alerts.utils import AlertEvaluationResult

logger = structlog.get_logger(__name__)

# Minimum number of historical data points needed for forecasting
MIN_HISTORICAL_POINTS = 10


def check_forecast_alert(alert: AlertConfiguration, insight: Insight, query: TrendsQuery) -> AlertEvaluationResult:
    """
    Evaluates a forecast-based alert by comparing the actual value against the forecast bounds.

    The alert fires if the actual value falls outside the confidence interval
    (lower_bound, upper_bound) generated by the Chronos forecast model.

    If no forecast exists, one is generated on-demand using the Chronos model.
    """
    config = ForecastAlertConfig.model_validate(alert.config)

    forecast = (
        ForecastResult.objects.filter(
            alert_configuration=alert,
            series_index=config.series_index,
        )
        .order_by("-forecast_timestamp")
        .first()
    )

    if not forecast:
        logger.info(
            "No forecast available, generating on-demand via Temporal",
            alert_id=str(alert.id),
            series_index=config.series_index,
        )
        forecast = _generate_forecast_via_temporal(alert, insight, config)

        if not forecast:
            return AlertEvaluationResult(
                value=None,
                breaches=["Unable to generate forecast. Insufficient historical data or model unavailable."],
            )

    execution_mode = ExecutionMode.RECENT_CACHE_CALCULATE_BLOCKING_IF_STALE
    if query.interval == IntervalType.HOUR:
        execution_mode = ExecutionMode.CALCULATE_BLOCKING_ALWAYS

    filters_override = _date_range_override_for_current_value(query)

    calculation_result = calculate_for_query_based_insight(
        insight,
        team=alert.team,
        execution_mode=execution_mode,
        user=None,
        filters_override=filters_override,
    )

    if not calculation_result.result:
        raise RuntimeError(f"No results found for insight with alert id = {alert.id}")

    results = cast(list[dict], calculation_result.result)

    if config.series_index >= len(results):
        raise ValueError(f"Series index {config.series_index} is out of range for insight with {len(results)} series")

    series = results[config.series_index]
    data = series.get("data", [])

    if not data:
        return AlertEvaluationResult(
            value=None,
            breaches=["No data available for the specified series"],
        )

    actual_value = data[-1] if data else 0.0
    if actual_value is None:
        actual_value = 0.0
    actual_value = float(actual_value)

    breaches = []
    if actual_value < forecast.lower_bound:
        breaches.append(
            f"Value {actual_value:.2f} is below forecast lower bound {forecast.lower_bound:.2f} "
            f"(expected range: {forecast.lower_bound:.2f} - {forecast.upper_bound:.2f} at "
            f"{forecast.confidence_level*100:.0f}% confidence)"
        )
    elif actual_value > forecast.upper_bound:
        breaches.append(
            f"Value {actual_value:.2f} is above forecast upper bound {forecast.upper_bound:.2f} "
            f"(expected range: {forecast.lower_bound:.2f} - {forecast.upper_bound:.2f} at "
            f"{forecast.confidence_level*100:.0f}% confidence)"
        )

    logger.info(
        "Forecast alert evaluation",
        alert_id=str(alert.id),
        actual_value=actual_value,
        predicted_value=forecast.predicted_value,
        lower_bound=forecast.lower_bound,
        upper_bound=forecast.upper_bound,
        breaches_count=len(breaches),
    )

    return AlertEvaluationResult(value=actual_value, breaches=breaches if breaches else None)


def check_forecast_alert_multi_series(
    alert: AlertConfiguration, insight: Insight, query: TrendsQuery
) -> AlertEvaluationResult:
    """
    Evaluates a forecast-based alert for multiple series (breakdowns).

    Checks up to 10 series and fires if ANY series falls outside its forecast bounds.
    """
    forecasts = list(
        ForecastResult.objects.filter(
            alert_configuration=alert,
        )
        .order_by("series_index", "-forecast_timestamp")
        .distinct("series_index")[:10]
    )

    if not forecasts:
        return AlertEvaluationResult(
            value=None,
            breaches=["No forecasts available yet. Forecasts will be generated on next refresh cycle."],
        )

    execution_mode = ExecutionMode.RECENT_CACHE_CALCULATE_BLOCKING_IF_STALE
    if query.interval == IntervalType.HOUR:
        execution_mode = ExecutionMode.CALCULATE_BLOCKING_ALWAYS

    filters_override = _date_range_override_for_current_value(query)

    calculation_result = calculate_for_query_based_insight(
        insight,
        team=alert.team,
        execution_mode=execution_mode,
        user=None,
        filters_override=filters_override,
    )

    if not calculation_result.result:
        raise RuntimeError(f"No results found for insight with alert id = {alert.id}")

    results = cast(list[dict], calculation_result.result)

    all_breaches = []
    checked_value = None

    for forecast in forecasts:
        if forecast.series_index >= len(results):
            continue

        series = results[forecast.series_index]
        data = series.get("data", [])
        breakdown_value = series.get("breakdown_value", "")

        if not data:
            continue

        actual_value = float(data[-1]) if data[-1] is not None else 0.0
        if checked_value is None:
            checked_value = actual_value

        series_label = f"[{breakdown_value}]" if breakdown_value else f"series {forecast.series_index}"

        if actual_value < forecast.lower_bound:
            all_breaches.append(
                f"{series_label}: Value {actual_value:.2f} is below forecast lower bound {forecast.lower_bound:.2f}"
            )
        elif actual_value > forecast.upper_bound:
            all_breaches.append(
                f"{series_label}: Value {actual_value:.2f} is above forecast upper bound {forecast.upper_bound:.2f}"
            )

    return AlertEvaluationResult(value=checked_value, breaches=all_breaches if all_breaches else None)


def _date_range_override_for_current_value(query: TrendsQuery) -> dict:
    """
    Creates date range override to get the most recent value for comparison.
    """
    match query.interval:
        case IntervalType.HOUR:
            return {"date_from": "-2h", "date_to": None}
        case IntervalType.DAY:
            return {"date_from": "-2d", "date_to": None}
        case IntervalType.WEEK:
            return {"date_from": "-2w", "date_to": None}
        case IntervalType.MONTH:
            return {"date_from": "-2m", "date_to": None}
        case _:
            return {"date_from": "-2d", "date_to": None}


def _generate_forecast_via_temporal(
    alert: AlertConfiguration,
    insight: Insight,
    config: ForecastAlertConfig,
) -> ForecastResult | None:
    """
    Generate a forecast on-demand by triggering the Temporal workflow.

    The Chronos model runs on Temporal workers, so we need to trigger the
    forecast-generation workflow and wait for it to complete.
    """
    import asyncio

    from temporalio.common import RetryPolicy

    from posthog.temporal.common.client import sync_connect
    from posthog.temporal.forecast.inputs import DEFAULT_LOOKBACK_WINDOW, ForecastWorkflowInputs

    workflow_id = f"forecast-generation:on-demand:{alert.id}:{uuid.uuid4()}"

    inputs = ForecastWorkflowInputs(
        team_id=alert.team_id,
        alert_id=str(alert.id),
        insight_id=insight.id,
        series_indices=[config.series_index],
        confidence_level=config.confidence_level,
        forecast_horizon=1,
        min_historical_points=MIN_HISTORICAL_POINTS,
        lookback_window=config.lookback_window or DEFAULT_LOOKBACK_WINDOW,
    )

    logger.info(
        "Triggering forecast generation workflow",
        alert_id=str(alert.id),
        workflow_id=workflow_id,
        series_index=config.series_index,
    )

    try:
        client = sync_connect()
        result = asyncio.run(
            client.execute_workflow(
                "forecast-generation",
                inputs,
                id=workflow_id,
                task_queue=settings.FORECAST_INFERENCE_TASK_QUEUE,
                retry_policy=RetryPolicy(maximum_attempts=2),
            )
        )

        if not result.success:
            logger.warning(
                "Forecast generation workflow failed",
                alert_id=str(alert.id),
                error=result.error,
            )
            return None

        logger.info(
            "Forecast generation workflow completed",
            alert_id=str(alert.id),
            forecast_count=result.forecast_count,
        )

        forecast = (
            ForecastResult.objects.filter(
                alert_configuration=alert,
                series_index=config.series_index,
            )
            .order_by("-forecast_timestamp")
            .first()
        )

        return forecast

    except Exception as e:
        logger.exception(
            "Error triggering forecast generation workflow",
            alert_id=str(alert.id),
            error=str(e),
        )
        return None
