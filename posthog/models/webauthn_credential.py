from django.db import models

from posthog.models.utils import UUIDModel


class WebAuthnCredentialManager(models.Manager):
    def get_verified_for_user(self, user_id: int):
        """
        Returns all verified credentials for a user.
        """
        return self.filter(user_id=user_id, verified=True)

    def get_verified_for_email(self, email: str):
        """
        Returns all verified credentials for a user by email (single query).
        """
        return self.filter(user__email__iexact=email, user__is_active=True, verified=True)


class WebauthnCredential(UUIDModel):
    """
    A single webauthn credential (passkey) for a user. Works using private-public key cryptography. Users can have multiple credentials.

    In essence: we send challenge to authenticator, authenticator signs using its private key, we verify using the public key.

    Read more: https://webauthn.io
    """

    objects: WebAuthnCredentialManager = WebAuthnCredentialManager()

    user = models.ForeignKey(
        "User",
        on_delete=models.CASCADE,
        related_name="webauthn_credentials",
    )
    credential_id = models.BinaryField(
        help_text="ID generated by the user's authenticator during credential creation. Stored as bytes."
    )
    label = models.CharField(max_length=200, help_text="The user-facing label assigned to this credential.")
    public_key = models.BinaryField(
        help_text="The public key used to verify attestations from the user's authenticator. Stored as bytes."
    )
    algorithm = models.IntegerField(
        help_text="The COSE algorithm identifier used for public-key verification (e.g., -7 for ES256, -257 for RS256)."
    )

    # we track the counter but don't do anything with it since passkeys are sorta meant to be cloned across devices. here for compatibility reasons
    counter = models.IntegerField(
        default=0,
        help_text="Tracks the counter of the credential. Traditionally used to detect cloned authenticators, however for our use case we expect to see some inconsistencies here because of the behavior of different passkey managers.",
    )

    transports = models.JSONField(
        default=list,
        help_text="The transport methods that the authenticator uses to communicate with the browser (e.g., ['internal', 'hybrid']).",
    )

    verified = models.BooleanField(
        default=False,
        help_text="Whether the credential has been verified by the user after registration. Only verified credentials can be used for login.",
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = (("user", "credential_id"),)
