// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none"
// @generated from file kafka_producer.proto (package kafka_producer, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import type {
    BinaryReadOptions,
    FieldList,
    JsonReadOptions,
    JsonValue,
    PartialMessage,
    PlainMessage,
} from '@bufbuild/protobuf'
import { Message, proto3, protoInt64 } from '@bufbuild/protobuf'

/**
 * @generated from message kafka_producer.ProduceRequest
 */
export class ProduceRequest extends Message<ProduceRequest> {
    /**
     * @generated from field: bytes value = 1;
     */
    value = new Uint8Array(0)

    /**
     * @generated from field: optional bytes key = 2;
     */
    key?: Uint8Array

    /**
     * @generated from field: string topic = 3;
     */
    topic = ''

    /**
     * @generated from field: map<string, string> headers = 4;
     */
    headers: { [key: string]: string } = {}

    constructor(data?: PartialMessage<ProduceRequest>) {
        super()
        proto3.util.initPartial(data, this)
    }

    static readonly runtime: typeof proto3 = proto3
    static readonly typeName = 'kafka_producer.ProduceRequest'
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'value', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: 'key', kind: 'scalar', T: 12 /* ScalarType.BYTES */, opt: true },
        { no: 3, name: 'topic', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 4,
            name: 'headers',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
    ])

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProduceRequest {
        return new ProduceRequest().fromBinary(bytes, options)
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProduceRequest {
        return new ProduceRequest().fromJson(jsonValue, options)
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProduceRequest {
        return new ProduceRequest().fromJsonString(jsonString, options)
    }

    static equals(
        a: ProduceRequest | PlainMessage<ProduceRequest> | undefined,
        b: ProduceRequest | PlainMessage<ProduceRequest> | undefined
    ): boolean {
        return proto3.util.equals(ProduceRequest, a, b)
    }
}

/**
 * @generated from message kafka_producer.ProduceResponse
 */
export class ProduceResponse extends Message<ProduceResponse> {
    /**
     * @generated from field: int64 offset = 1;
     */
    offset = protoInt64.zero

    constructor(data?: PartialMessage<ProduceResponse>) {
        super()
        proto3.util.initPartial(data, this)
    }

    static readonly runtime: typeof proto3 = proto3
    static readonly typeName = 'kafka_producer.ProduceResponse'
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'offset', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ])

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProduceResponse {
        return new ProduceResponse().fromBinary(bytes, options)
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProduceResponse {
        return new ProduceResponse().fromJson(jsonValue, options)
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProduceResponse {
        return new ProduceResponse().fromJsonString(jsonString, options)
    }

    static equals(
        a: ProduceResponse | PlainMessage<ProduceResponse> | undefined,
        b: ProduceResponse | PlainMessage<ProduceResponse> | undefined
    ): boolean {
        return proto3.util.equals(ProduceResponse, a, b)
    }
}
