{
    "count": 45,
    "next": null,
    "previous": null,
    "results": [
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "Post to Slack on feature enrollment",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "blocks": {
                            "default": [
                                {
                                    "text": {
                                        "text": "*{person.name}* {event.properties.$feature_enrollment ? 'enrolled in' : 'un-enrolled from'} the early access feature for '{event.properties.$feature_flag}'",
                                        "type": "mrkdwn"
                                    },
                                    "type": "section"
                                },
                                {
                                    "type": "actions",
                                    "elements": [
                                        {
                                            "url": "{person.url}",
                                            "text": {
                                                "text": "View Person in PostHog",
                                                "type": "plain_text"
                                            },
                                            "type": "button"
                                        }
                                    ]
                                }
                            ]
                        },
                        "text": {
                            "default": "*{person.name}* {event.properties.$feature_enrollment ? 'enrolled in' : 'un-enrolled from'} the early access feature for '{event.properties.$feature_flag}'"
                        }
                    },
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "Post to Slack on survey response",
                    "description": "Posts a message to Slack when a user responds to a survey",
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "blocks": {
                            "default": [
                                {
                                    "text": {
                                        "text": "*{person.name}* responded to survey *{event.properties.$survey_name}*",
                                        "type": "mrkdwn"
                                    },
                                    "type": "section"
                                },
                                {
                                    "type": "actions",
                                    "elements": [
                                        {
                                            "url": "{project.url}/surveys/{event.properties.$survey_id}",
                                            "text": {
                                                "text": "View Survey",
                                                "type": "plain_text"
                                            },
                                            "type": "button"
                                        },
                                        {
                                            "url": "{person.url}",
                                            "text": {
                                                "text": "View Person",
                                                "type": "plain_text"
                                            },
                                            "type": "button"
                                        }
                                    ]
                                }
                            ]
                        },
                        "text": {
                            "default": "*{person.name}* responded to survey *{event.properties.$survey_name}*"
                        }
                    },
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "Post to Slack on team activity",
                    "description": "",
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "blocks": {
                            "default": [
                                {
                                    "text": {
                                        "text": "*{person.properties.email}* {event.properties.activity} {event.properties.scope} {event.properties.item_id} ",
                                        "type": "mrkdwn"
                                    },
                                    "type": "section"
                                }
                            ]
                        },
                        "text": {
                            "default": "*{person.properties.email}* {event.properties.activity} {event.properties.scope} {event.properties.item_id}"
                        }
                    },
                    "type": "internal_destination"
                }
            ],
            "status": "stable",
            "free": true,
            "type": "destination",
            "id": "template-slack",
            "name": "Slack",
            "hog": "let res := fetch('https://slack.com/api/chat.postMessage', {\n  'body': {\n    'channel': inputs.channel,\n    'icon_emoji': inputs.icon_emoji,\n    'username': inputs.username,\n    'blocks': inputs.blocks,\n    'text': inputs.text\n  },\n  'method': 'POST',\n  'headers': {\n    'Authorization': f'Bearer {inputs.slack_workspace.access_token}',\n    'Content-Type': 'application/json'\n  }\n});\n\nif (res.status != 200 or res.body.ok == false) {\n  throw Error(f'Failed to post message to Slack: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "slack_workspace",
                    "type": "integration",
                    "integration": "slack",
                    "label": "Slack workspace",
                    "requiredScopes": "channels:read groups:read chat:write chat:write.customize",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "channel",
                    "type": "integration_field",
                    "integration_key": "slack_workspace",
                    "integration_field": "slack_channel",
                    "label": "Channel to post to",
                    "description": "Select the channel to post to (e.g. #general). The PostHog app must be installed in the workspace.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "icon_emoji",
                    "type": "string",
                    "label": "Emoji icon",
                    "default": ":hedgehog:",
                    "required": false,
                    "secret": false
                },
                {
                    "key": "username",
                    "type": "string",
                    "label": "Bot name",
                    "default": "PostHog",
                    "required": false,
                    "secret": false
                },
                {
                    "key": "blocks",
                    "type": "json",
                    "label": "Blocks",
                    "description": "(see https://api.slack.com/block-kit/building)",
                    "default": [
                        {
                            "text": {
                                "text": "*{person.name}* triggered event: '{event.event}'",
                                "type": "mrkdwn"
                            },
                            "type": "section"
                        },
                        {
                            "type": "actions",
                            "elements": [
                                {
                                    "url": "{person.url}",
                                    "text": {
                                        "text": "View Person in PostHog",
                                        "type": "plain_text"
                                    },
                                    "type": "button"
                                },
                                {
                                    "url": "{source.url}",
                                    "text": {
                                        "text": "Message source",
                                        "type": "plain_text"
                                    },
                                    "type": "button"
                                }
                            ]
                        }
                    ],
                    "secret": false,
                    "required": false
                },
                {
                    "key": "text",
                    "type": "string",
                    "label": "Plain text message",
                    "description": "Optional fallback message if blocks are not provided or supported",
                    "default": "*{person.name}* triggered event: '{event.event}'",
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Customer Success"],
            "description": "Sends a message to a slack channel",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/slack.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "HTTP Webhook on feature enrollment",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "HTTP Webhook on survey response",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "HTTP Webhook on team activity",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": "internal_destination"
                }
            ],
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-webhook",
            "name": "HTTP Webhook",
            "hog": "let payload := {\n  'headers': inputs.headers,\n  'body': inputs.body,\n  'method': inputs.method\n}\n\nif (inputs.debug) {\n  print('Request', inputs.url, payload)\n}\n\nlet res := fetch(inputs.url, payload);\n\nif (inputs.debug) {\n  print('Response', res.status, res.body);\n}",
            "inputs_schema": [
                {
                    "key": "url",
                    "type": "string",
                    "label": "Webhook URL",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "method",
                    "type": "choice",
                    "label": "Method",
                    "secret": false,
                    "choices": [
                        {
                            "label": "POST",
                            "value": "POST"
                        },
                        {
                            "label": "PUT",
                            "value": "PUT"
                        },
                        {
                            "label": "PATCH",
                            "value": "PATCH"
                        },
                        {
                            "label": "GET",
                            "value": "GET"
                        },
                        {
                            "label": "DELETE",
                            "value": "DELETE"
                        }
                    ],
                    "default": "POST",
                    "required": false
                },
                {
                    "key": "body",
                    "type": "json",
                    "label": "JSON Body",
                    "default": {
                        "event": "{event}",
                        "person": "{person}"
                    },
                    "secret": false,
                    "required": false
                },
                {
                    "key": "headers",
                    "type": "dictionary",
                    "label": "Headers",
                    "secret": false,
                    "required": false,
                    "default": {
                        "Content-Type": "application/json"
                    }
                },
                {
                    "key": "debug",
                    "type": "boolean",
                    "label": "Log responses",
                    "description": "Logs the response of http calls for debugging.",
                    "secret": false,
                    "required": false,
                    "default": false
                }
            ],
            "category": ["Custom"],
            "description": "Sends a webhook templated by the incoming event data",
            "filters": null,
            "masking": null,
            "icon_url": "/static/posthog-icon.svg"
        },
        {
            "mapping_templates": [
                {
                    "name": "Webhook",
                    "include_by_default": true,
                    "filters": {
                        "events": [
                            {
                                "id": "$pageview",
                                "name": "Pageview",
                                "type": "events"
                            }
                        ]
                    },
                    "inputs": null,
                    "inputs_schema": [
                        {
                            "key": "body",
                            "type": "json",
                            "label": "JSON Body",
                            "default": {
                                "event": "{event}",
                                "person": "{person}"
                            },
                            "secret": false,
                            "required": false
                        },
                        {
                            "key": "additional_headers",
                            "type": "dictionary",
                            "label": "Additional headers",
                            "secret": false,
                            "required": false,
                            "default": {}
                        }
                    ]
                }
            ],
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "HTTP Webhook on feature enrollment",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "HTTP Webhook on survey response",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "HTTP Webhook on team activity",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": "internal_destination"
                }
            ],
            "status": "alpha",
            "free": false,
            "type": "destination",
            "id": "template-webhook-mappings",
            "name": "HTTP Webhook (mappings based)",
            "hog": "let headers := {}\n\nfor (let key, value in inputs.headers) {\n    headers[key] := value\n}\nif (inputs.additional_headers) {\n  for (let key, value in inputs.additional_headers) {\n    headers[key] := value\n  }\n}\n\nlet payload := {\n  'headers': headers,\n  'body': inputs.body,\n  'method': inputs.method\n}\n\nif (inputs.debug) {\n  print('Request', inputs.url, payload)\n}\n\nlet res := fetch(inputs.url, payload);\n\nif (inputs.debug) {\n  print('Response', res.status, res.body);\n}",
            "inputs_schema": [
                {
                    "key": "url",
                    "type": "string",
                    "label": "Webhook URL",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "method",
                    "type": "choice",
                    "label": "Method",
                    "secret": false,
                    "choices": [
                        {
                            "label": "POST",
                            "value": "POST"
                        },
                        {
                            "label": "PUT",
                            "value": "PUT"
                        },
                        {
                            "label": "PATCH",
                            "value": "PATCH"
                        },
                        {
                            "label": "GET",
                            "value": "GET"
                        },
                        {
                            "label": "DELETE",
                            "value": "DELETE"
                        }
                    ],
                    "default": "POST",
                    "required": false
                },
                {
                    "key": "headers",
                    "type": "dictionary",
                    "label": "Headers",
                    "secret": false,
                    "required": false,
                    "default": {
                        "Content-Type": "application/json"
                    }
                },
                {
                    "key": "debug",
                    "type": "boolean",
                    "label": "Log responses",
                    "description": "Logs the response of http calls for debugging.",
                    "secret": false,
                    "required": false,
                    "default": false
                }
            ],
            "category": ["Custom"],
            "description": "Sends a webhook templated by the incoming event data",
            "filters": null,
            "masking": null,
            "icon_url": "/static/posthog-icon.svg"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-activecampaign",
            "name": "ActiveCampaign",
            "hog": "if (empty(inputs.email)) {\n    print('`email` input is empty. Not creating a contact.')\n    return\n}\n\nlet contact := {\n    'email': inputs.email,\n    'fieldValues': [],\n}\n\nif (not empty(inputs.firstName)) contact.firstName := inputs.firstName\nif (not empty(inputs.lastName)) contact.lastName := inputs.lastName\nif (not empty(inputs.phone)) contact.phone := inputs.phone\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value)) {\n        contact.fieldValues := arrayPushBack(contact.fieldValues, {'field': key, 'value': value})\n    }\n}\n\nlet res := fetch(f'https://{inputs.accountName}.api-us1.com/api/3/contact/sync', {\n    'method': 'POST',\n    'headers': {\n        'content-type': 'application/json',\n        'Api-Token': inputs.apiKey\n    },\n    'body': {\n        'contact': contact\n    }\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from {inputs.accountName}.api-us1.com (status {res.status}): {res.body}')\n} else {\n    print('Contact has been created or updated successfully!')\n}",
            "inputs_schema": [
                {
                    "key": "accountName",
                    "type": "string",
                    "label": "Account name",
                    "description": "Usually in the form of \u003CaccountName\u003E.activehosted.com. You can use this page to figure our your account name: https://www.activecampaign.com/login/lookup.php",
                    "default": "",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Your ActiveCampaign API Key",
                    "description": "See the docs here: https://help.activecampaign.com/hc/en-us/articles/207317590-Getting-started-with-the-API#h_01HJ6REM2YQW19KYPB189726ST",
                    "default": "",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "firstName",
                    "type": "string",
                    "label": "First name of the user",
                    "description": "Where to find the first name for the contact to be created.",
                    "default": "{person.properties.firstName}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "lastName",
                    "type": "string",
                    "label": "Last name of the user",
                    "description": "Where to find the last name for the contact to be created.",
                    "default": "{person.properties.lastName}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "phone",
                    "type": "string",
                    "label": "Phone number of the user",
                    "description": "Where to find the phone number for the contact to be created.",
                    "default": "{person.properties.phone}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Additional person fields",
                    "description": "Map any values to ActiveCampaign person fields. (fieldId:value)",
                    "default": {
                        "1": "{person.properties.company}",
                        "2": "{person.properties.website}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Email Marketing"],
            "description": "Creates a new contact in ActiveCampaign whenever an event is triggered.",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/activecampaign.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "alpha",
            "free": false,
            "type": "destination",
            "id": "template-airtable",
            "name": "Airtable",
            "hog": "let url := f'https://api.airtable.com/v0/{inputs.base_id}/{inputs.table_name}'\n\nlet payload := {\n  'headers': {\n    'Content-Type': 'application/json',\n    'Authorization': f'Bearer {inputs.access_token}'\n  },\n  'body': {\n    'fields': inputs.fields,\n    'typecast': true\n  },\n  'method': 'POST'\n}\n\nif (inputs.debug) {\n  print('Request', url, payload)\n}\n\nlet res := fetch(url, payload);\n\nif (inputs.debug) {\n  print('Response', res.status, res.body);\n}\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.airtable.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "access_token",
                    "type": "string",
                    "label": "Airtable access token",
                    "secret": true,
                    "required": true,
                    "description": "Create this at https://airtable.com/create/tokens"
                },
                {
                    "key": "base_id",
                    "type": "string",
                    "label": "Airtable base ID",
                    "secret": false,
                    "required": true,
                    "description": "Find this at https://airtable.com/developers/web/api/introduction"
                },
                {
                    "key": "table_name",
                    "type": "string",
                    "label": "Table name",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "fields",
                    "type": "json",
                    "label": "Fields",
                    "default": {
                        "Timestamp": "{event.timestamp}",
                        "Person Name": "{person.name}"
                    },
                    "secret": false,
                    "required": true,
                    "description": "Map field names from Airtable to properties from events and person records."
                },
                {
                    "key": "debug",
                    "type": "boolean",
                    "label": "Log responses",
                    "description": "Logs the response of http calls for debugging.",
                    "secret": false,
                    "required": false,
                    "default": false
                }
            ],
            "category": ["Custom"],
            "description": "Creates Airtable records",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/airtable.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-attio",
            "name": "Attio",
            "hog": "let body := {\n    'data': {\n        'values': {\n            'email_addresses': [\n                {\n                    'email_address': inputs.email\n                }\n            ]\n        }\n    }\n}\n\nfor (let key, value in inputs.personAttributes) {\n    if (not empty(value)) {\n        body.data.values[key] := value\n    }\n}\n\nlet res := fetch(f'https://api.attio.com/v2/objects/people/records?matching_attribute=email_addresses', {\n    'method': 'PUT',\n    'headers': {\n        'Authorization': f'Bearer {inputs.apiKey}',\n        'Content-Type': 'application/json',\n    },\n    'body': body\n})\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.attio.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Access token",
                    "description": "Check out this page to get your API key: https://attio.com/help/reference/integrations-automations/generating-an-api-key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "personAttributes",
                    "type": "dictionary",
                    "label": "Additional Person attributes",
                    "description": "This persons keys should be the slugs or IDs of the attributes you wish to update. For information on potential custom attributes, refer to the attribute type docs: https://developers.attio.com/docs/attribute-types",
                    "default": {
                        "name": "{person.properties.name}",
                        "job_title": "{person.properties.job_title}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Advertisement"],
            "description": "Create and update contacts in Attio",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/attio.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-avo",
            "name": "Avo",
            "hog": "if (empty(inputs.apiKey) or empty(inputs.environment)) {\n    print('API Key and environment has to be set. Skipping...')\n    return\n}\n\nlet avoEvent := {\n    'apiKey': inputs.apiKey,\n    'env': inputs.environment,\n    'appName': inputs.appName,\n    'sessionId': event.properties.$session_id ?? generateUUIDv4(),\n    'createdAt': toString(toDateTime(toUnixTimestamp(now()))),\n    'avoFunction': false,\n    'eventId': null,\n    'eventHash': null,\n    'appVersion': '1.0.0',\n    'libVersion': '1.0.0',\n    'libPlatform': 'node',\n    'trackingId': '',\n    'samplingRate': 1,\n    'type': 'event',\n    'eventName': event.event,\n    'messageId': event.uuid,\n    'eventProperties': []\n}\n\nfun getPropValueType(propValue) {\n    let propType := typeof(propValue)\n    if (propValue == null) {\n        return 'null'\n    } else if (propType == 'string') {\n        return 'string'\n    } else if (propType == 'integer') {\n        return 'int'\n    } else if (propType == 'float') {\n        return 'float'\n    } else if (propType == 'boolean') {\n        return 'boolean'\n    } else if (propType == 'object') {\n        return 'object'\n    } else if (propType == 'array') {\n        return 'list'\n    } else {\n        return propType\n    }\n}\n\nfor (let key, value in event.properties) {\n    let excludeProperties := arrayMap(x -\u003E trim(x), splitByString(',', inputs.excludeProperties))\n    let includeProperties := arrayMap(x -\u003E trim(x), splitByString(',', inputs.includeProperties))\n    let isExcluded := has(excludeProperties, key)\n    let isIncluded := includeProperties[1] == '' or has(includeProperties, key)\n\n    if (not (key like '$%' or isExcluded or not isIncluded)) {\n        avoEvent.eventProperties := arrayPushBack(avoEvent.eventProperties, { 'propertyName': key, 'propertyType': getPropValueType(value) })\n    }\n}\n\nfetch('https://api.avo.app/inspector/posthog/v1/track', {\n    'method': 'POST',\n    'headers': {\n        'env': inputs.environment,\n        'api-key': inputs.apiKey,\n        'content-type': 'application/json',\n        'accept': 'application/json',\n    },\n    'body': [avoEvent]\n})",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Avo API Key",
                    "description": "Avo source API key",
                    "default": "",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "environment",
                    "type": "string",
                    "label": "Environment",
                    "description": "Environment name",
                    "default": "dev",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "appName",
                    "type": "string",
                    "label": "App name",
                    "description": "App name",
                    "default": "PostHog",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "excludeProperties",
                    "type": "string",
                    "label": "Properties to exclude",
                    "description": "Comma-separated list of event properties that will not be sent to Avo.",
                    "default": "",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "includeProperties",
                    "type": "string",
                    "label": "Properties to include",
                    "description": "Comma separated list of event properties to send to Avo (will send all if left empty).",
                    "default": "",
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Analytics"],
            "description": "Send events to Avo",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/avo.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-aws-kinesis",
            "name": "AWS Kinesis",
            "hog": "fun getPayload() {\n  let region := inputs.aws_region\n  let service := 'kinesis'\n  let amzDate := formatDateTime(now(), '%Y%m%dT%H%i%sZ')\n  let date := formatDateTime(now(), '%Y%m%d')\n\n  let payload := jsonStringify({\n    'StreamName': inputs.aws_kinesis_stream_name,\n    'PartitionKey': inputs.aws_kinesis_partition_key ?? generateUUIDv4(),\n    'Data': base64Encode(jsonStringify(inputs.payload)),\n  })\n\n  let requestHeaders := {\n    'Content-Type': 'application/x-amz-json-1.1',\n    'X-Amz-Target': 'Kinesis_20131202.PutRecord',\n    'X-Amz-Date': amzDate,\n    'Host': f'kinesis.{region}.amazonaws.com',\n  }\n\n  let canonicalHeaderParts := []\n  for (let key, value in requestHeaders) {\n    let val := replaceAll(trim(value), '\\\\s+', ' ')\n    canonicalHeaderParts := arrayPushBack(canonicalHeaderParts, f'{lower(key)}:{val}')\n  }\n  let canonicalHeaders := arrayStringConcat(arraySort(canonicalHeaderParts), '\\n') || '\\n'\n\n  let signedHeaderParts := []\n  for (let key, value in requestHeaders) {\n    signedHeaderParts := arrayPushBack(signedHeaderParts, lower(key))\n  }\n  let signedHeaders := arrayStringConcat(arraySort(signedHeaderParts), ';')\n\n  let canonicalRequest := arrayStringConcat([\n    'POST',\n    '/',\n    '',\n    canonicalHeaders,\n    signedHeaders,\n    sha256Hex(payload),\n  ], '\\n')\n\n  let credentialScope := f'{date}/{region}/{service}/aws4_request'\n  let stringToSign := arrayStringConcat([\n    'AWS4-HMAC-SHA256',\n    amzDate,\n    credentialScope,\n    sha256Hex(canonicalRequest),\n  ], '\\n')\n\n  let signature := sha256HmacChainHex([\n    f'AWS4{inputs.aws_secret_access_key}', date, region, service, 'aws4_request', stringToSign\n  ])\n\n  let authorizationHeader :=\n      f'AWS4-HMAC-SHA256 Credential={inputs.aws_access_key_id}/{credentialScope}, ' ||\n      f'SignedHeaders={signedHeaders}, ' ||\n      f'Signature={signature}'\n\n  requestHeaders['Authorization'] := authorizationHeader\n\n  return {\n    'headers': requestHeaders,\n    'body': payload,\n    'method': 'POST'\n  }\n}\n\nlet res := fetch(f'https://kinesis.{inputs.aws_region}.amazonaws.com', getPayload())\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n  print('Event sent successfully!')\n} else {\n  throw Error(f'Error from {inputs.aws_region}.amazonaws.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "aws_access_key_id",
                    "type": "string",
                    "label": "AWS Access Key ID",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "aws_secret_access_key",
                    "type": "string",
                    "label": "AWS Secret Access Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "aws_region",
                    "type": "string",
                    "label": "AWS Region",
                    "secret": false,
                    "required": true,
                    "default": "us-east-1"
                },
                {
                    "key": "aws_kinesis_stream_name",
                    "type": "string",
                    "label": "Kinesis Stream Name",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "aws_kinesis_partition_key",
                    "type": "string",
                    "label": "Kinesis Partition Key",
                    "description": "If not provided, a random UUID will be generated.",
                    "default": "{event.uuid}",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "payload",
                    "type": "json",
                    "label": "Message Payload",
                    "default": {
                        "event": "{event}",
                        "person": "{person}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Analytics"],
            "description": "Put data to an AWS Kinesis stream",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/aws-kinesis.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-twilio",
            "name": "Twilio",
            "hog": "let encodedTo := encodeURLComponent(inputs.phoneNumber)\nlet encodedFrom := encodeURLComponent(inputs.fromPhoneNumber)\nlet encodedSmsBody := encodeURLComponent(f'{inputs.smsBody} - Event: {event.event} at {toDate(event.timestamp)}')\nlet base64EncodedAuth := base64Encode(f'{inputs.accountSid}:{inputs.authToken}')\n\nlet res := fetch(\n    f'https://api.twilio.com/2010-04-01/Accounts/{inputs.accountSid}/Messages.json',\n    {\n        'method': 'POST',\n        'headers': {\n            'Authorization': f'Basic {base64EncodedAuth}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        'body': f'To={encodedTo}&From={encodedFrom}&Body={encodedSmsBody}'\n    }\n)\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n    print('SMS sent successfully via Twilio!')\n} else {\n    throw Error('Error sending SMS', res)\n}",
            "inputs_schema": [
                {
                    "key": "accountSid",
                    "type": "string",
                    "label": "Account SID",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "authToken",
                    "type": "string",
                    "label": "Auth Token",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "fromPhoneNumber",
                    "type": "string",
                    "label": "From Phone Number",
                    "description": "Your Twilio phone number (e.g. +12292109687)",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "phoneNumber",
                    "type": "string",
                    "label": "Recipient Phone Number",
                    "description": "The phone number to send SMS to (e.g. +491633950489)",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "smsBody",
                    "type": "string",
                    "label": "SMS Body Template",
                    "description": "Limited to 1600 characters - exceeding this will cause failures.",
                    "default": "Event Notification: {event.event} occurred.",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Custom"],
            "description": "Send SMS via Twilio when an event occurs.",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/twilio.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-braze",
            "name": "Braze",
            "hog": "let getPayload := () -\u003E [{\n  'attributes': inputs.attributes,\n  'events': [inputs.event]\n}]\n\nlet res := fetch(f'{inputs.brazeEndpoint}/users/track', {\n  'method': 'POST',\n  'headers': {\n    'Authorization': f'Bearer {inputs.apiKey}',\n    'Content-Type': 'application/json'\n  },\n  'body': getPayload()\n})\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n  print('Event sent successfully!')\n} else {\n  throw Error(f'Error sending event: {res.status} {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "brazeEndpoint",
                    "type": "choice",
                    "label": "Braze REST Endpoint",
                    "description": "The endpoint identifier where your Braze instance is located, see the docs here: https://www.braze.com/docs/api/basics",
                    "choices": [
                        {
                            "label": "US-01",
                            "value": "https://rest.iad-01.braze.com"
                        },
                        {
                            "label": "US-02",
                            "value": "https://rest.iad-02.braze.com"
                        },
                        {
                            "label": "US-03",
                            "value": "https://rest.iad-03.braze.com"
                        },
                        {
                            "label": "US-04",
                            "value": "https://rest.iad-04.braze.com"
                        },
                        {
                            "label": "US-05",
                            "value": "https://rest.iad-05.braze.com"
                        },
                        {
                            "label": "US-06",
                            "value": "https://rest.iad-06.braze.com"
                        },
                        {
                            "label": "US-08",
                            "value": "https://rest.iad-08.braze.com"
                        },
                        {
                            "label": "EU-01",
                            "value": "https://rest.fra-01.braze.eu"
                        },
                        {
                            "label": "EU-02",
                            "value": "https://rest.fra-02.braze.eu"
                        }
                    ],
                    "default": "",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Your Braze API Key",
                    "description": "See the docs here: https://www.braze.com/docs/api/api_key/",
                    "default": "",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "json",
                    "label": "Attributes to set",
                    "default": {
                        "email": "{person.properties.email}"
                    },
                    "secret": false,
                    "required": true
                },
                {
                    "key": "event",
                    "type": "json",
                    "label": "Event payload",
                    "default": {
                        "properties": "{event.properties}",
                        "external_id": "{event.distinct_id}",
                        "name": "{event.event}",
                        "time": "{event.timestamp}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Customer Success"],
            "description": "Send events to Braze",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/braze.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-brevo",
            "name": "Brevo",
            "hog": "if (empty(inputs.email)) {\n    print('No email set. Skipping...')\n    return\n}\n\nlet body := {\n    'email': inputs.email,\n    'updateEnabled': true,\n    'attributes': {}\n}\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value)) {\n        body.attributes[key] := value\n    }\n}\n\nlet res := fetch(f'https://api.brevo.com/v3/contacts', {\n    'method': 'POST',\n    'headers': {\n        'api-key': inputs.apiKey,\n        'Content-Type': 'application/json',\n    },\n    'body': body\n})\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.brevo.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Brevo API Key",
                    "description": "Check out this page on how to get your API key: https://help.brevo.com/hc/en-us/articles/209467485-Create-and-manage-your-API-keys",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attributes",
                    "description": "For information on potential attributes, refer to the following page: https://help.brevo.com/hc/en-us/articles/10617359589906-Create-and-manage-contact-attributes",
                    "default": {
                        "EMAIL": "{person.properties.email}",
                        "FIRSTNAME": "{person.properties.firstname}",
                        "LASTNAME": "{person.properties.lastname}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Email Marketing"],
            "description": "Update contacts in Brevo",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/brevo.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-clearbit",
            "name": "Clearbit",
            "hog": "let api_key := inputs.api_key\nlet email := inputs.email\n\nif (empty(email) or event.event == '$set' or person.properties.clearbit_enriched) {\n    return false\n}\n\nlet response := fetch(f'https://person-stream.clearbit.com/v2/combined/find?email={email}', {\n    'method': 'GET',\n    'headers': {\n        'Authorization': f'Bearer {api_key}'\n    }\n})\nif (response.status == 200 and not empty(response.body.person)) {\n    print('Clearbit data found - sending event to PostHog')\n    postHogCapture({\n        'event': '$set',\n        'distinct_id': event.distinct_id,\n        'properties': {\n            '$lib': 'hog_function',\n            '$hog_function_source': source.url,\n            '$set_once': {\n                'person': response.body.person,\n                'company': response.body.company,\n                'clearbit_enriched': true\n            }\n        }\n    })\n} else {\n    print('No Clearbit data found')\n}",
            "inputs_schema": [
                {
                    "key": "api_key",
                    "type": "string",
                    "label": "Clearbit API Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the user to be checked with Clearbit",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Analytics"],
            "description": "Loads data from the Clearbit API and tracks an additional event with the enriched data if found. Once enriched, the person will not be enriched again.",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/clearbit.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-customerio",
            "name": "Customer.io",
            "hog": "let action := inputs.action\nlet name := event.event\n\n\nif (empty(inputs.identifier_value) or empty(inputs.identifier_key)) {\n    print('No identifier set. Skipping as identifier is required.')\n    return\n}\n\nlet identifiers := {\n    inputs.identifier_key: inputs.identifier_value\n}\n\nif (action == 'automatic') {\n    if (event.event in ('$identify', '$set')) {\n        action := 'identify'\n        name := null\n    } else if (event.event == '$pageview') {\n        action := 'page'\n        name := event.properties.$current_url\n    } else if (event.event == '$screen') {\n        action := 'screen'\n        name := event.properties.$screen_name\n    } else {\n        action := 'event'\n    }\n}\n\nlet attributes := inputs.include_all_properties ? action == 'identify' ? person.properties : event.properties : {}\nif (inputs.include_all_properties and action != 'identify' and not empty(event.elements_chain)) {\n    attributes['$elements_chain'] := event.elements_chain\n}\nlet timestamp := toInt(toUnixTimestamp(toDateTime(event.timestamp)))\n\nfor (let key, value in inputs.attributes) {\n    attributes[key] := value\n}\n\nlet res := fetch(f'https://{inputs.host}/api/v2/entity', {\n    'method': 'POST',\n    'headers': {\n        'User-Agent': 'PostHog Customer.io App',\n        'Authorization': f'Basic {base64Encode(f'{inputs.site_id}:{inputs.token}')}',\n        'Content-Type': 'application/json'\n    },\n    'body': {\n        'type': 'person',\n        'action': action,\n        'name': name,\n        'identifiers': identifiers,\n        'attributes': attributes,\n        'timestamp': timestamp\n    }\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from customer.io api: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "site_id",
                    "type": "string",
                    "label": "Customer.io site ID",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "token",
                    "type": "string",
                    "label": "Customer.io API Key",
                    "description": "You can find your API key in your Customer.io account settings (https://fly.customer.io/settings/api_credentials)",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "host",
                    "type": "choice",
                    "choices": [
                        {
                            "label": "US (track.customer.io)",
                            "value": "track.customer.io"
                        },
                        {
                            "label": "EU (track-eu.customer.io)",
                            "value": "track-eu.customer.io"
                        }
                    ],
                    "label": "Customer.io region",
                    "description": "Use the EU variant if your Customer.io account is based in the EU region",
                    "default": "track.customer.io",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "identifier_key",
                    "type": "choice",
                    "label": "Identifier key",
                    "description": "The kind of identifier to be used. See here for more information: https://customer.io/docs/api/track/#operation/entity",
                    "default": "email",
                    "choices": [
                        {
                            "label": "Email",
                            "value": "email"
                        },
                        {
                            "label": "ID",
                            "value": "id"
                        },
                        {
                            "label": "Customer.io ID",
                            "value": "cio_id"
                        }
                    ],
                    "secret": false,
                    "required": true
                },
                {
                    "key": "identifier_value",
                    "type": "string",
                    "label": "Identifier value",
                    "description": "The value to be used for the identifier. If the value is empty nothing will be sent. See here for more information: https://customer.io/docs/api/track/#operation/entity",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "action",
                    "type": "choice",
                    "label": "Action",
                    "description": "Choose the action to be tracked. Automatic will convert $identify, $pageview and $screen to identify, page and screen automatically - otherwise defaulting to event",
                    "default": "automatic",
                    "choices": [
                        {
                            "label": "Automatic",
                            "value": "automatic"
                        },
                        {
                            "label": "Identify",
                            "value": "identify"
                        },
                        {
                            "label": "Event",
                            "value": "event"
                        },
                        {
                            "label": "Page",
                            "value": "page"
                        },
                        {
                            "label": "Screen",
                            "value": "screen"
                        },
                        {
                            "label": "Delete",
                            "value": "delete"
                        }
                    ],
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below. For identify events the Person properties will be used.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attribute mapping",
                    "description": "Map of Customer.io attributes and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "email": "{person.properties.email}",
                        "lastname": "{person.properties.lastname}",
                        "firstname": "{person.properties.firstname}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Identify or track events against customers in Customer.io",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$pageview",
                        "name": "$pageview",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/customerio.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "Post to Discord on feature enrollment",
                    "description": "Posts a message to Discord when a user enrolls or un-enrolls in an early access feature",
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "content": {
                            "default": "**{person.name}** {event.properties.$feature_enrollment ? 'enrolled in' : 'un-enrolled from'} the early access feature for '{event.properties.$feature_flag}'"
                        }
                    },
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "Post to Discord on survey response",
                    "description": "Posts a message to Discord when a user responds to a survey",
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "content": {
                            "default": "**{person.name}** responded to survey **{event.properties.$survey_name}**"
                        }
                    },
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "Post to Discord on team activity",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "content": {
                            "default": "**{person.name}** {event.properties.activity} {event.properties.scope} {event.properties.item_id}"
                        }
                    },
                    "type": "internal_destination"
                }
            ],
            "status": "stable",
            "free": true,
            "type": "destination",
            "id": "template-discord",
            "name": "Discord",
            "hog": "if (not match(inputs.webhookUrl, '^https://discord.com/api/webhooks/.*')) {\n    throw Error('Invalid URL. The URL should match the format: https://discord.com/api/webhooks/...')\n}\n\nlet res := fetch(inputs.webhookUrl, {\n    'body': {\n        'content': inputs.content\n    },\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json'\n    }\n});\n\nif (res.status \u003E= 400) {\n    throw Error(f'Failed to post message to Discord: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "webhookUrl",
                    "type": "string",
                    "label": "Webhook URL",
                    "description": "See this page on how to generate a Webhook URL: https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "content",
                    "type": "string",
                    "label": "Content",
                    "description": "(see https://support.discord.com/hc/en-us/articles/210298617-Markdown-Text-101-Chat-Formatting-Bold-Italic-Underline)",
                    "default": "**{person.name}** triggered event: '{event.event}'",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Customer Success"],
            "description": "Sends a message to a discord channel",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/discord.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-engage-so",
            "name": "Engage.so",
            "hog": "fetch('https://api.engage.so/posthog', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Basic {base64Encode(f'{inputs.public_key}:{inputs.private_key}')}',\n        'Content-Type': 'application/json'\n    },\n    'body': event\n})",
            "inputs_schema": [
                {
                    "key": "public_key",
                    "type": "string",
                    "label": "Public key",
                    "description": "Get your public key from your Engage dashboard (Settings -\u003E Account)",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "private_key",
                    "type": "string",
                    "label": "Private key",
                    "description": "Get your private key from your Engage dashboard (Settings -\u003E Account)",
                    "secret": true,
                    "required": true
                }
            ],
            "category": ["Email Marketing"],
            "description": "Send events to Engage.so",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    },
                    {
                        "id": "$groupidentify",
                        "name": "$groupidentify",
                        "type": "events",
                        "order": 2
                    },
                    {
                        "id": "$unset",
                        "name": "$unset",
                        "type": "events",
                        "order": 3
                    },
                    {
                        "id": "$create_alias",
                        "name": "$create_alias",
                        "type": "events",
                        "order": 4
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/engage.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-gleap",
            "name": "Gleap",
            "hog": "let action := inputs.action\nlet name := event.event\n\nif (empty(inputs.userId)) {\n    print('No User ID set. Skipping...')\n    return\n}\n\nlet attributes := inputs.include_all_properties ? person.properties : {}\n\nattributes['userId'] := inputs.userId\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value)) {\n        attributes[key] := value\n    }\n}\n\nlet res := fetch(f'https://api.gleap.io/admin/identify', {\n    'method': 'POST',\n    'headers': {\n        'User-Agent': 'PostHog Gleap.io App',\n        'Api-Token': inputs.apiKey,\n        'Content-Type': 'application/json'\n    },\n    'body': attributes\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from gleap.io (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Gleap.io API Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "userId",
                    "type": "string",
                    "label": "User ID",
                    "description": "You can choose to fill this from an `email` property or an `id` property. If the value is empty nothing will be sent. See here for more information: https://docs.gleap.io/server/rest-api",
                    "default": "{person.id}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all person properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attribute mapping",
                    "description": "Map of Gleap.io attributes and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "email": "{person.properties.email}",
                        "name": "{person.properties.name}",
                        "phone": "{person.properties.phone}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Customer Success"],
            "description": "Updates a contact in Gleap",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/gleap.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "alpha",
            "free": false,
            "type": "destination",
            "id": "template-google-ads",
            "name": "Google Ads Conversions",
            "hog": "if (empty(inputs.gclid)) {\n    print('Empty `gclid`. Skipping...')\n    return\n}\n\nlet body := {\n    'conversions': [\n        {\n            'gclid': inputs.gclid,\n            'conversion_action': f'customers/{replaceAll(inputs.customerId, '-', '')}/conversionActions/{inputs.conversionActionId}',\n            'conversion_date_time': inputs.conversionDateTime\n        }\n    ],\n    'partialFailure': true\n}\n\nif (not empty(inputs.conversionValue)) {\n    body.conversions[1].conversion_value := inputs.conversionValue\n}\nif (not empty(inputs.currencyCode)) {\n    body.conversions[1].currency_code := inputs.currencyCode\n}\nif (not empty(inputs.orderId)) {\n    body.conversions[1].order_id := inputs.orderId\n}\n\nlet res := fetch(f'https://googleads.googleapis.com/v18/customers/{replaceAll(inputs.customerId, '-', '')}:uploadClickConversions', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Bearer {inputs.oauth.access_token}',\n        'Content-Type': 'application/json'\n    },\n    'body': body\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from googleads.googleapis.com (status {res.status}): {res.body}')\n} else if (not empty(res.body.partialFailureError)) {\n    throw Error(f'Error from googleads.googleapis.com (status {res.status}): {res.body.partialFailureError.message}')\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "google-ads",
                    "label": "Google Ads account",
                    "requiredScopes": "https://www.googleapis.com/auth/adwords https://www.googleapis.com/auth/userinfo.email",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "customerId",
                    "type": "integration_field",
                    "integration_key": "oauth",
                    "integration_field": "google_ads_customer_id",
                    "label": "Customer ID",
                    "description": "ID of your Google Ads Account. This should be 10-digits and in XXX-XXX-XXXX format.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionActionId",
                    "type": "integration_field",
                    "integration_key": "oauth",
                    "integration_field": "google_ads_conversion_action",
                    "requires_field": "customerId",
                    "label": "Conversion action",
                    "description": "The Conversion action associated with this conversion.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "gclid",
                    "type": "string",
                    "label": "Google Click ID (gclid)",
                    "description": "The Google click ID (gclid) associated with this conversion.",
                    "default": "{person.properties.gclid ?? person.properties.$initial_gclid}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionDateTime",
                    "type": "string",
                    "label": "Conversion Date Time",
                    "description": "The date time at which the conversion occurred. Must be after the click time. The timezone must be specified. The format is \"yyyy-mm-dd hh:mm:ss+|-hh:mm\", e.g. \"2019-01-01 12:32:45-08:00\".",
                    "default": "{formatDateTime(toDateTime(event.timestamp), '%Y-%m-%d %H:%i:%S')}+00:00",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionValue",
                    "type": "string",
                    "label": "Conversion value",
                    "description": "The value of the conversion for the advertiser.",
                    "default": "",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "currencyCode",
                    "type": "string",
                    "label": "Currency code",
                    "description": "Currency associated with the conversion value. This is the ISO 4217 3-character currency code. For example: USD, EUR.",
                    "default": "",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "orderId",
                    "type": "string",
                    "label": "Order ID",
                    "description": "The order ID associated with the conversion. An order id can only be used for one conversion per conversion action.",
                    "default": "",
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Advertisement"],
            "description": "Send conversion events to Google Ads",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/google-ads.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-google-cloud-storage",
            "name": "Google Cloud Storage",
            "hog": "let res := fetch(f'https://storage.googleapis.com/upload/storage/v1/b/{encodeURLComponent(inputs.bucketName)}/o?uploadType=media&name={encodeURLComponent(inputs.filename)}', {\n  'method': 'POST',\n  'headers': {\n    'Authorization': f'Bearer {inputs.auth.access_token}',\n    'Content-Type': 'application/json'\n  },\n  'body': inputs.payload\n})\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n  print('Event sent successfully!')\n} else {\n  throw Error('Error sending event', res)\n}",
            "inputs_schema": [
                {
                    "key": "auth",
                    "type": "integration",
                    "integration": "google-cloud-storage",
                    "label": "Google Cloud service account",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "bucketName",
                    "type": "string",
                    "label": "Bucket name",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "filename",
                    "type": "string",
                    "label": "Filename",
                    "default": "{toDate(event.timestamp)}/{event.timestamp}-{event.uuid}.json",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "payload",
                    "type": "string",
                    "label": "File contents",
                    "default": "{jsonStringify({ 'event': event, 'person': person })}",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Custom"],
            "description": "Send data to GCS. This creates a file per event.",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/google-cloud-storage.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-google-pubsub",
            "name": "Google Pub/Sub",
            "hog": "let headers := () -\u003E {\n  'Authorization': f'Bearer {inputs.auth.access_token}',\n  'Content-Type': 'application/json'\n}\nlet message := () -\u003E {\n  'messageId': event.uuid,\n  'data': base64Encode(jsonStringify(inputs.payload)),\n  'attributes': inputs.attributes\n}\nlet res := fetch(f'https://pubsub.googleapis.com/v1/{inputs.topicId}:publish', {\n  'method': 'POST',\n  'headers': headers(),\n  'body': jsonStringify({ 'messages': [message()] })\n})\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n  print('Event sent successfully!')\n} else {\n  throw Error('Error sending event', res)\n}",
            "inputs_schema": [
                {
                    "key": "auth",
                    "type": "integration",
                    "integration": "google-pubsub",
                    "label": "Google Cloud service account",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "topicId",
                    "type": "string",
                    "label": "Topic name",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "payload",
                    "type": "json",
                    "label": "Message Payload",
                    "default": {
                        "event": "{event}",
                        "person": "{person}"
                    },
                    "secret": false,
                    "required": false
                },
                {
                    "key": "attributes",
                    "type": "json",
                    "label": "Attributes",
                    "default": {},
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Custom"],
            "description": "Send data to a Google Pub/Sub topic",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/google-cloud.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-hubspot",
            "name": "Hubspot",
            "hog": "let properties := {\n    'email': inputs.email\n}\nfor (let key, value in inputs.properties) {\n    if (typeof(value) in ('object', 'array', 'tuple')) {\n        properties[key] := jsonStringify(value)\n    } else {\n        properties[key] := value\n    }\n}\n\nif (empty(properties.email)) {\n    print('`email` input is empty. Not creating a contact.')\n    return\n}\n\nlet headers := {\n    'Authorization': f'Bearer {inputs.oauth.access_token}',\n    'Content-Type': 'application/json'\n}\nlet body := {\n    'inputs': [\n        {\n            'properties': properties,\n            'id': properties.email,\n            'idProperty': 'email'\n        }\n    ]\n}\n\nlet res := fetch('https://api.hubapi.com/crm/v3/objects/contacts/batch/upsert', {\n    'method': 'POST',\n    'headers': headers,\n    'body': body\n})\n\nif (res.status == 200) {\n    print(f'Contact {properties.email} updated successfully!')\n} else {\n    throw Error(f'Error updating contact {properties.email} (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "hubspot",
                    "label": "Hubspot connection",
                    "requiredScopes": "crm.objects.contacts.write crm.objects.contacts.read",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Property mapping",
                    "description": "Map any event properties to Hubspot properties.",
                    "default": {
                        "firstname": "{person.properties.firstname}",
                        "lastname": "{person.properties.lastname}",
                        "company": "{person.properties.company}",
                        "phone": "{person.properties.phone}",
                        "website": "{person.properties.website}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["CRM", "Customer Success"],
            "description": "Creates a new contact in Hubspot whenever an event is triggered.",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/hubspot.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-hubspot-event",
            "name": "Hubspot",
            "hog": "if (empty(inputs.email)) {\n    print('`email` input is empty. Not sending event.')\n    return\n}\n\nif (not match(inputs.eventName, '^([a-z])([a-z0-9_-])+$')) {\n    throw Error(f'Event name must start with a letter and can only contain lowercase letters, numbers, underscores, and hyphens. Not sending event: {inputs.eventName}')\n    return\n}\n\nlet properties := {}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        if (typeof(value) in ('object', 'array', 'tuple')) {\n            properties[key] := jsonStringify(value)\n        } else {\n            properties[key] := value\n        }\n    }\n}\n\nif (inputs.include_all_properties) {\n    for (let key, value in event.properties) {\n        if (not empty(value) and not key like '$%') {\n            if (typeof(value) in ('object', 'array', 'tuple')) {\n                properties[key] := jsonStringify(value)\n            } else {\n                properties[key] := value\n            }\n        }\n    }\n}\n\nlet eventSchema := fetch(f'https://api.hubapi.com/events/v3/event-definitions/{inputs.eventName}/?includeProperties=true', {\n    'method': 'GET',\n    'headers': {\n        'Authorization': f'Bearer {inputs.oauth.access_token}',\n        'Content-Type': 'application/json'\n    },\n})\n\nfun getPropValueType(propValue) {\n    let propType := typeof(propValue)\n    if (propType == 'string') {\n        if (match(propValue, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}Z$')) {\n            return 'datetime'\n        }\n        return 'string'\n    } else if (propType == 'integer') {\n        return 'number'\n    } else if (propType == 'float') {\n        return 'number'\n    } else if (propType == 'boolean') {\n        return 'enumeration'\n    } else if (propType == 'object') {\n        return 'string'\n    } else {\n        return null\n    }\n}\n\nfun getPropValueTypeDefinition(name, propValue) {\n    let propType := typeof(propValue)\n    if (propType == 'string' or propType == 'object' or propType == 'array' or propType == 'tuple') {\n        if (match(propValue, '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}Z$')) {\n            return {\n                'name': name,\n                'label': name,\n                'type': 'datetime',\n                'description': f'{name} - (created by PostHog)'\n            }\n        }\n        return {\n            'name': name,\n            'label': name,\n            'type': 'string',\n            'description': f'{name} - (created by PostHog)'\n        }\n    } else if (propType == 'integer' or propType == 'float') {\n        return {\n            'name': name,\n            'label': name,\n            'type': 'number',\n            'description': f'{name} - (created by PostHog)'\n        }\n    } else if (propType == 'boolean') {\n        return {\n            'name': name,\n            'label': name,\n            'type': 'enumeration',\n            'description': f'{name} - (created by PostHog)',\n            'options': [\n                {\n                    'label': 'true',\n                    'value': true,\n                    'hidden': false,\n                    'description': 'True',\n                    'displayOrder': 1\n                },\n                {\n                    'label': 'false',\n                    'value': false,\n                    'hidden': false,\n                    'description': 'False',\n                    'displayOrder': 2\n                }\n            ]\n        }\n    } else {\n        print('unsupported type for key', name)\n        return null\n    }\n}\n\nlet fullyQualifiedName := ''\n\nif (eventSchema.status \u003E= 400) {\n    let body := {\n        'label': inputs.eventName,\n        'name': inputs.eventName,\n        'description': f'{inputs.eventName} - (created by PostHog)',\n        'primaryObject': 'CONTACT',\n        'propertyDefinitions': []\n    }\n\n    for (let key, value in properties) {\n        body.propertyDefinitions := arrayPushBack(body.propertyDefinitions, getPropValueTypeDefinition(key, value))\n    }\n\n    let res := fetch('https://api.hubapi.com/events/v3/event-definitions', {\n        'method': 'POST',\n        'headers': {\n            'Authorization': f'Bearer {inputs.oauth.access_token}',\n            'Content-Type': 'application/json'\n        },\n        'body': body\n    })\n\n    if (res.status \u003E= 400) {\n        throw Error(f'Error from api.hubapi.com api: {res.status}: {res.body}');\n    } else {\n        fullyQualifiedName := res.body.fullyQualifiedName\n    }\n} else {\n    fullyQualifiedName := eventSchema.body.fullyQualifiedName\n    let missingProperties := []\n    let wrongTypeProperties := []\n    for (let key, value in properties) {\n        if (not arrayExists(property -\u003E property.name == key, eventSchema.body.properties)) {\n            missingProperties := arrayPushBack(missingProperties, { 'key': key, 'value': value })\n        } else if (not arrayExists(property -\u003E property.name == key and property.type == getPropValueType(value), eventSchema.body.properties)) {\n            wrongTypeProperties := arrayPushBack(wrongTypeProperties, { 'key': key, 'value': value })\n        }\n    }\n\n    if (not empty(missingProperties)) {\n        for (let i, obj in missingProperties) {\n            let res := fetch(f'https://api.hubapi.com/events/v3/event-definitions/{inputs.eventName}/property', {\n                'method': 'POST',\n                'headers': {\n                    'Authorization': f'Bearer {inputs.oauth.access_token}',\n                    'Content-Type': 'application/json'\n                },\n                'body': getPropValueTypeDefinition(obj.key, obj.value)\n            })\n\n            if (res.status \u003E= 400) {\n                throw Error(f'Error from api.hubapi.com api: {res.status}: {res.body}');\n            }\n        }\n    }\n\n    if (not empty(wrongTypeProperties)) {\n        throw Error(f'Property type mismatch for the following properties: {wrongTypeProperties}. Not sending event.')\n    }\n}\n\nlet res := fetch('https://api.hubapi.com/events/v3/send', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Bearer {inputs.oauth.access_token}',\n        'Content-Type': 'application/json'\n    },\n    'body': {\n        'eventName': fullyQualifiedName,\n        'email': inputs.email,\n        'occurredAt': event.timestamp,\n        'properties': properties\n    }\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.hubapi.com api: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "hubspot",
                    "label": "Hubspot connection",
                    "requiredScopes": "analytics.behavioral_events.send behavioral_events.event_definitions.read_write",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventName",
                    "type": "string",
                    "label": "Event Name",
                    "description": "Hubspot only allows events that start with a letter and can only contain lowercase letters, numbers, underscores, and hyphens.",
                    "default": "{replaceAll(replaceAll(trim(lower(event.event)), '$', ''), ' ', '_')}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all event properties",
                    "description": "If set, all event properties will be included. Individual properties can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Property mapping",
                    "description": "Map any event properties to Hubspot properties.",
                    "default": {
                        "price": "{event.properties.price}",
                        "currency": "USD"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["CRM", "Customer Success"],
            "description": "Send events to Hubspot.",
            "filters": {
                "events": [
                    {
                        "id": "checkout",
                        "name": "checkout",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/hubspot.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-Intercom",
            "name": "Intercom",
            "hog": "if (empty(inputs.email)) {\n    print('`email` input is empty. Skipping.')\n    return\n}\n\nlet res := fetch(f'https://{inputs.host}/events', {\n  'method': 'POST',\n  'headers': {\n    'Authorization': f'Bearer {inputs.access_token}',\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  },\n  'body': {\n    'event_name': event.event,\n    'created_at': toInt(toUnixTimestamp(toDateTime(event.timestamp))),\n    'email': inputs.email,\n    'id': event.distinct_id,\n  }\n})\n\nif (res.status \u003E= 200 and res.status \u003C 300) {\n    print('Event sent successfully!')\n    return\n}\n\nif (res.status == 404) {\n    throw Error('No existing contact found for email')\n    return\n}\n\nthrow Error(f'Error from intercom api (status {res.status}): {res.body}')",
            "inputs_schema": [
                {
                    "key": "access_token",
                    "type": "string",
                    "label": "Intercom access token",
                    "description": "Create an Intercom app (https://developers.intercom.com/docs/build-an-integration/learn-more/authentication), then go to Configure \u003E Authentication to find your token.",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "host",
                    "type": "choice",
                    "choices": [
                        {
                            "label": "US (api.intercom.io)",
                            "value": "api.intercom.io"
                        },
                        {
                            "label": "EU (api.eu.intercom.com)",
                            "value": "api.eu.intercom.com"
                        }
                    ],
                    "label": "Data region",
                    "description": "Use the EU variant if your Intercom account is based in the EU region",
                    "default": "api.intercom.io",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Customer Success"],
            "description": "Send events and contact information to Intercom",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/intercom.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-june",
            "name": "June.so",
            "hog": "let type := 'track'\n\nif (event.event in ('$identify', '$set')) {\n    type := 'identify'\n} else if (event.event in ('$pageview', '$screen')) {\n    type := 'page'\n}\n\nlet context := {\n    'app': {},\n    'campaign': {},\n    'device': {},\n    'os': {},\n    'referrer': {},\n    'screen': {}\n}\n\nif (not empty(event.properties.$app_build)) context.app.build := event.properties.$app_build\nif (not empty(event.properties.$app_version)) context.app.version := event.properties.$app_version\nif (not empty(event.properties.$app_name)) context.app.name := event.properties.$app_name\nif (not empty(event.properties.utm_campaign)) context.campaign.name := event.properties.utm_campaign\nif (not empty(event.properties.utm_content)) context.campaign.content := event.properties.utm_content\nif (not empty(event.properties.utm_medium)) context.campaign.medium := event.properties.utm_medium\nif (not empty(event.properties.utm_source)) context.campaign.source := event.properties.utm_source\nif (not empty(event.properties.utm_term)) context.campaign.term := event.properties.utm_term\nif (not empty(event.properties.$device_id)) context.device.id := event.properties.$device_id\nif (not empty(event.properties.$device_manufacturer)) context.device.manufacturer := event.properties.$device_manufacturer\nif (not empty(event.properties.$device_model)) context.device.model := event.properties.$device_model\nif (not empty(event.properties.$os_name)) context.device.name := event.properties.$os_name\nif (not empty(event.properties.$os_version)) context.device.version := event.properties.$os_version\nif (not empty(event.properties.$device_type)) context.device.type := event.properties.$device_type\nif (not empty(event.properties.$ip)) context.ip := event.properties.$ip\nif (not empty(event.properties.$browser_language)) context.locale := event.properties.$browser_language\nif (not empty(event.properties.$os)) context.os.name := event.properties.$os\nif (not empty(event.properties.$os_version)) context.os.version := event.properties.$os_version\nif (not empty(event.properties.$referrer)) context.referrer.url := event.properties.$referrer\nif (not empty(event.properties.$screen_height)) context.screen.height := event.properties.$screen_height\nif (not empty(event.properties.$screen_width)) context.screen.width := event.properties.$screen_width\nif (not empty(event.properties.$geoip_time_zone)) context.timezone := event.properties.$geoip_time_zone\nif (not empty(event.properties.$raw_user_agent)) context.userAgent := event.properties.$raw_user_agent\n\nlet properties := {}\n\nif (not empty(event.properties.$current_url)) properties.url := event.properties.$current_url\nif (not empty(event.properties.$pathname)) properties.path := event.properties.$pathname\nif (not empty(event.properties.title)) properties.title := event.properties.title\nif (not empty(event.properties.$referrer)) properties.referrer := event.properties.$referrer\nif (not empty(event.properties.$current_url)) {\n    if (not empty(splitByString('?', event.properties.$current_url)[2])) {\n        properties.search := f'?{splitByString('?', event.properties.$current_url)[2]}'\n    }\n}\n\nlet traits := {}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        traits[key] := value\n    }\n}\n\nif (inputs.include_all_properties) {\n    for (let key, value in (type == 'identify' ? person.properties : event.properties)) {\n        if (not empty(value) and not key like '$%') {\n            traits[key] := value\n        }\n    }\n}\n\nlet body := {\n    'properties': properties,\n    'traits': traits,\n    'timestamp': event.timestamp,\n    'context': context,\n    'messageId': event.uuid\n}\n\nif (type == 'track') body.event := event.event\nif (event.properties.$is_identified) {\n    body.userId := event.distinct_id\n    if (not empty(event.properties.$anon_distinct_id)) body.anonymousId := event.properties.$anon_distinct_id\n} else {\n    body.anonymousId := event.distinct_id\n}\n\nlet res := fetch(f'https://api.june.so/sdk/{type}', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Basic {inputs.apiKey}',\n        'Content-Type': 'application/json'\n    },\n    'body': body\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.june.so (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "June.so Write API key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all event properties will be included as traits. Individual traits can be overridden below. For identify events the Person properties will be used.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Trait mapping",
                    "description": "Map of June.so traits and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "email": "{person.properties.email}",
                        "name": "{person.properties.name}",
                        "phone": "{person.properties.phone}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Analytics"],
            "description": "Send events to June.so ",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": false
            },
            "masking": null,
            "icon_url": "/static/services/june.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-klaviyo-event",
            "name": "Klaviyo",
            "hog": "if (empty(inputs.externalId) and empty(inputs.email)) {\n    print('Email or External ID has to be set. Skipping...')\n    return\n}\n\nlet body := {\n    'data': {\n        'type': 'event',\n        'attributes': {\n            'properties': {},\n            'metric': {\n                'data': {\n                    'type': 'metric',\n                    'attributes': {\n                        'name': event.event\n                    }\n                }\n            },\n            'profile': {\n                'data': {\n                    'type': 'profile',\n                    'attributes': {}\n                }\n            }\n        }\n    }\n}\n\nif (not empty(inputs.email)) body.data.attributes.profile.data.attributes.email := inputs.email\nif (not empty(inputs.externalId)) body.data.attributes.profile.data.attributes.external_id := inputs.externalId\n\nif (inputs.include_all_properties) {\n    for (let key, value in event.properties) {\n        if (not empty(value) and not key like '$%') {\n            body.data.attributes.properties[key] := value\n        }\n    }\n}\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value)) {\n        body.data.attributes.properties[key] := value\n    }\n}\n\nlet res := fetch('https://a.klaviyo.com/api/events', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Klaviyo-API-Key {inputs.apiKey}',\n        'revision': '2024-10-15',\n        'Content-Type': 'application/json'\n    },\n    'body': body\n})\n\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from a.klaviyo.com api: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Klaviyo Private API Key",
                    "description": "You can create a Private API Key in the account settings (https://www.klaviyo.com/settings/account/api-keys)",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "User Email",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "externalId",
                    "type": "string",
                    "label": "External ID",
                    "description": "A unique identifier used to associate Klaviyo profiles with profiles in an external system",
                    "default": "{person.id}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all event properties as event attributes",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attributes",
                    "description": "Map of event attributes and their values.",
                    "default": {
                        "price": "{event.properties.price}",
                        "currency": "{event.properties.currency}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Send events to Klaviyo",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/klaviyo.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-klaviyo-user",
            "name": "Klaviyo",
            "hog": "if (empty(inputs.externalId) and empty(inputs.email)) {\n    print('Email or External ID has to be set. Skipping...')\n    return\n}\n\nlet body := {\n    'data': {\n        'type': 'profile',\n        'attributes': {\n            'location': {},\n            'properties': {},\n        }\n    }\n}\n\nif (not empty(person.properties.$geoip_latitude)) body.data.attributes.location.latitude := person.properties.$geoip_latitude\nif (not empty(person.properties.$geoip_longitude)) body.data.attributes.location.longitude := person.properties.$geoip_longitude\nif (not empty(person.properties.$geoip_city_name)) body.data.attributes.location.city := person.properties.$geoip_city_name\nif (not empty(person.properties.$geoip_country_name)) body.data.attributes.location.country := person.properties.$geoip_country_name\nif (not empty(person.properties.$geoip_continent_code)) body.data.attributes.location.region := person.properties.$geoip_continent_code\nif (not empty(person.properties.$geoip_postal_code)) body.data.attributes.location.zip := person.properties.$geoip_postal_code\nif (not empty(person.properties.$geoip_time_zone)) body.data.attributes.location.timezone := person.properties.$geoip_time_zone\n\nif (not empty(inputs.email)) body.data.attributes.email := inputs.email\nif (not empty(inputs.externalId)) body.data.attributes.external_id := inputs.externalId\n\nif (inputs.include_all_properties) {\n    for (let key, value in person.properties) {\n        if (not empty(value) and not key like '$%') {\n            body.data.attributes.properties[key] := value\n        }\n    }\n}\n\nfor (let key, value in inputs.customProperties) {\n    if (not empty(value)) {\n        body.data.attributes.properties[key] := value\n    }\n}\n\nlet res := fetch('https://a.klaviyo.com/api/profiles', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Klaviyo-API-Key {inputs.apiKey}',\n        'revision': '2024-10-15',\n        'Content-Type': 'application/json'\n    },\n    'body': body\n})\n\nif (res.status == 409 and not empty(res.body.errors.1.meta.duplicate_profile_id)) {\n    let id := res.body.errors.1.meta.duplicate_profile_id\n    body.data.id := id\n\n    let res2 := fetch(f'https://a.klaviyo.com/api/profiles/{id}', {\n        'method': 'PATCH',\n        'headers': {\n            'Authorization': f'Klaviyo-API-Key {inputs.apiKey}',\n            'revision': '2024-10-15',\n            'Content-Type': 'application/json'\n        },\n        'body': body\n    })\n    if (res2.status \u003E= 400) {\n        throw Error(f'Error from a.klaviyo.com api: {res2.status}: {res2.body}');\n    }\n} else if (res.status \u003E= 400) {\n    throw Error(f'Error from a.klaviyo.com api: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Klaviyo Private API Key",
                    "description": "You can create a Private API Key in the account settings (https://www.klaviyo.com/settings/account/api-keys)",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "User Email",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "externalId",
                    "type": "string",
                    "label": "External ID",
                    "description": "A unique identifier used to associate Klaviyo profiles with profiles in an external system",
                    "default": "{person.id}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all person properties as custom properties",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below. For identify events the Person properties will be used.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "customProperties",
                    "type": "dictionary",
                    "label": "Custom properties",
                    "description": "Map of Custom properties and their values.",
                    "default": {
                        "first_name": "{person.properties.firstname}",
                        "last_name": "{person.properties.lastname}",
                        "title": "{person.properties.title}",
                        "organization": "{person.properties.organization}",
                        "phone_number": "{person.properties.phone}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Updates a contact in Klaviyo",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/klaviyo.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-knock",
            "name": "Knock",
            "hog": "if (empty(inputs.userId)) {\n    print('No User ID set. Skipping...')\n    return\n}\n\nlet body := {\n    'type': 'track',\n    'event': event.event,\n    'userId': inputs.userId,\n    'properties': inputs.include_all_properties ? event.properties : {},\n    'messageId': event.uuid,\n    'timestamp': event.timestamp\n}\nif (inputs.include_all_properties and not empty(event.elements_chain)) {\n    body['properties']['$elements_chain'] := event.elements_chain\n}\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value)) {\n        body['properties'][key] := value\n    }\n}\n\nlet res := fetch(inputs.webhookUrl, {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json'\n    },\n    'body': body\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from knock.app (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "webhookUrl",
                    "type": "string",
                    "label": "Knock.app webhook destination URL",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "userId",
                    "type": "string",
                    "label": "User ID",
                    "description": "You can choose to fill this from an `email` property or an `id` property. If the value is empty nothing will be sent. See here for more information: https://docs.gleap.io/server/rest-api",
                    "default": "{person.id}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attribute mapping",
                    "description": "Map of Knock.app attributes and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "price": "{event.properties.price}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["SMS & Push Notifications"],
            "description": "Send events to Knock",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/knock.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "alpha",
            "free": false,
            "type": "destination",
            "id": "template-linkedin-ads",
            "name": "LinkedIn Ads Conversions",
            "hog": "let body := {\n    'conversion': f'urn:lla:llaPartnerConversion:{inputs.conversionRuleId}',\n    'conversionHappenedAt': inputs.conversionDateTime,\n    'user': {\n        'userIds': [],\n        'userInfo': {}\n     },\n    'eventId' : inputs.eventId\n}\n\nif (not empty(inputs.conversionValue) or not empty(inputs.currencyCode)) {\n    body.conversionValue := {}\n}\nif (not empty(inputs.currencyCode)) {\n    body.conversionValue.currencyCode := inputs.currencyCode\n}\nif (not empty(inputs.conversionValue)) {\n    body.conversionValue.amount := inputs.conversionValue\n}\n\nfor (let key, value in inputs.userInfo) {\n    if (not empty(value)) {\n        body.user.userInfo[key] := value\n    }\n}\n\nfor (let key, value in inputs.userIds) {\n    if (not empty(value)) {\n        body.user.userIds := arrayPushBack(body.user.userIds, {'idType': key, 'idValue': value})\n    }\n}\n\nlet res := fetch('https://api.linkedin.com/rest/conversionEvents', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Bearer {inputs.oauth.access_token}',\n        'Content-Type': 'application/json',\n        'LinkedIn-Version': '202409'\n    },\n    'body': body\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from api.linkedin.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "linkedin-ads",
                    "label": "LinkedIn Ads account",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "accountId",
                    "type": "integration_field",
                    "integration_key": "oauth",
                    "integration_field": "linkedin_ads_account_id",
                    "label": "Account ID",
                    "description": "ID of your LinkedIn Ads Account. This should be 9-digits and in XXXXXXXXX format.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionRuleId",
                    "type": "integration_field",
                    "integration_key": "oauth",
                    "integration_field": "linkedin_ads_conversion_rule_id",
                    "requires_field": "accountId",
                    "label": "Conversion rule",
                    "description": "The Conversion rule associated with this conversion.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionDateTime",
                    "type": "string",
                    "label": "Conversion Date Time",
                    "description": "The timestamp at which the conversion occurred in milliseconds. Must be after the click time.",
                    "default": "{toUnixTimestampMilli(event.timestamp)}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "conversionValue",
                    "type": "string",
                    "label": "Conversion value",
                    "description": "The value of the conversion for the advertiser in decimal string. (e.g. 100.05).",
                    "default": "",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "currencyCode",
                    "type": "string",
                    "label": "Currency code",
                    "description": "Currency associated with the conversion value. This is the ISO 4217 3-character currency code. For example: USD, EUR.",
                    "default": "",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "eventId",
                    "type": "string",
                    "label": "Event ID",
                    "description": "ID of the event that triggered the conversion.",
                    "default": "{event.uuid}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "userIds",
                    "type": "dictionary",
                    "label": "User ids",
                    "description": "A map that contains user ids. See this page for options: https://learn.microsoft.com/en-us/linkedin/marketing/integrations/ads-reporting/conversions-api?view=li-lms-2024-03&tabs=curl#idtype",
                    "default": {
                        "SHA256_EMAIL": "{sha256Hex(person.properties.email)}",
                        "LINKEDIN_FIRST_PARTY_ADS_TRACKING_UUID": "{person.properties.li_fat_id ?? person.properties.$initial_li_fat_id}"
                    },
                    "secret": false,
                    "required": true
                },
                {
                    "key": "userInfo",
                    "type": "dictionary",
                    "label": "User information",
                    "description": "A map that contains user information data. See this page for options: https://learn.microsoft.com/en-us/linkedin/marketing/integrations/ads-reporting/conversions-api?view=li-lms-2024-03&tabs=curl#userinfo",
                    "default": {
                        "firstName": "{person.properties.first_name}",
                        "lastName": "{person.properties.last_name}",
                        "title": "{person.properties.title}",
                        "companyName": "{person.properties.company}",
                        "countryCode": "{person.properties.$geoip_country_code}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Advertisement"],
            "description": "Send conversion events to LinkedIn Ads",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/linkedin.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-loops",
            "name": "Loops",
            "hog": "if (empty(inputs.email)) {\n    print('No email set. Skipping...')\n    return\n}\n\nlet payload := {\n    'email': inputs.email,\n    'userId': person.id,\n}\n\nif (inputs.include_all_properties) {\n    for (let key, value in person.properties) {\n        if (not empty(value) and not key like '$%') {\n            payload[key] := value\n        }\n    }\n}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        payload[key] := value\n    }\n}\n\nlet res := fetch('https://app.loops.so/api/v1/contacts/update', {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json',\n        'Authorization': f'Bearer {inputs.apiKey}',\n    },\n    'body': payload\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from app.loops.so (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Loops API Key",
                    "description": "Loops API Key",
                    "default": "",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email of the user.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all person properties will be included. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Property mapping",
                    "description": "Map of Loops.so properties and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "firstName": "{person.properties.firstname}",
                        "lastName": "{person.properties.lastname}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Update contacts in Loops.so",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/loops.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-loops-event",
            "name": "Loops",
            "hog": "if (empty(inputs.email)) {\n    print('No email set. Skipping...')\n    return\n}\n\nlet payload := {\n    'email': inputs.email,\n    'userId': person.id,\n    'eventName': event.event,\n    'eventProperties': {}\n}\n\nif (inputs.include_all_properties) {\n    for (let key, value in event.properties) {\n        if (not empty(value) and not key like '$%') {\n            payload.eventProperties[key] := value\n        }\n    }\n}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        payload.eventProperties[key] := value\n    }\n}\n\nlet res := fetch('https://app.loops.so/api/v1/events/send', {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json',\n        'Authorization': f'Bearer {inputs.apiKey}',\n    },\n    'body': payload\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from app.loops.so (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Loops API Key",
                    "description": "Loops API Key",
                    "default": "",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email of the user.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties as attributes",
                    "description": "If set, all event properties will be included. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Property mapping",
                    "description": "Map of Loops.so properties and their values. You can use the filters section to filter out unwanted events.",
                    "default": {
                        "pathname": "{event.properties.$pathname}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Send events to Loops.so",
            "filters": {
                "events": [
                    {
                        "id": "$pageview",
                        "name": "$pageview",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/loops.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-mailchimp",
            "name": "Mailchimp",
            "hog": "if (empty(inputs.email)) {\n    print('No email set. Skipping...')\n    return\n}\n\nlet properties := {}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        properties[key] := value\n    }\n}\n\nif (inputs.include_all_properties) {\n    for (let key, value in event.properties) {\n        if (not empty(value) and not key like '$%') {\n            properties[key] := value\n        }\n    }\n}\n\nlet userStatus := fetch(f'https://{inputs.dataCenterId}.api.mailchimp.com/3.0/lists/{inputs.audienceId}/members/{md5Hex(inputs.email)}', {\n    'method': 'GET',\n    'headers': {\n        'Authorization': f'Bearer {inputs.apiKey}',\n        'Content-Type': 'application/json'\n    }\n})\n\nif (userStatus.status == 404 or userStatus.status == 200) {\n    let res := fetch(f'https://{inputs.dataCenterId}.api.mailchimp.com/3.0/lists/{inputs.audienceId}/members/{md5Hex(inputs.email)}', {\n        'method': 'PUT',\n        'headers': {\n            'Authorization': f'Bearer {inputs.apiKey}',\n            'Content-Type': 'application/json'\n        },\n        'body': {\n            'email_address': inputs.email,\n            'status_if_new': inputs.doubleOptIn ? 'pending' : 'subscribed',\n            'merge_fields': properties\n        }\n    })\n    if (res.status \u003E= 400) {\n        throw Error(f'Error from api.mailchimp.com (status {userStatus.status}): {userStatus.body}')\n    }\n} else if (userStatus.status \u003E= 400) {\n    throw Error(f'Error from api.mailchimp.com (status {userStatus.status}): {userStatus.body}')\n}",
            "inputs_schema": [
                {
                    "key": "apiKey",
                    "type": "string",
                    "label": "Mailchimp API Key",
                    "description": "See the docs here: https://mailchimp.com/help/about-api-keys/",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "audienceId",
                    "type": "string",
                    "label": "Mailchimp audience ID",
                    "description": "See the docs here: https://mailchimp.com/help/find-audience-id/",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "dataCenterId",
                    "type": "string",
                    "label": "Mailchimp data center ID",
                    "description": "You can find your Datacenter ID in the Mailchimp url in your browser when you're logged in. It's the 'us1' in 'https://us1.admin.mailchimp.com/lists/'",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the contact to be created. You can use the filters section to filter out unwanted emails or internal users.",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "doubleOptIn",
                    "type": "boolean",
                    "label": "Enable double opt-in",
                    "description": "If enabled, Mailchimp sends a confirmation email to that user, and that email is tagged with a pending subscriber status. The subscriber status automatically changes to subscribed once the user confirms the email.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all event properties",
                    "description": "If set, all person properties will be included. Individual properties can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Merge field",
                    "description": "Map of Mailchimp merge fields and their values. You can use the filters section to filter out unwanted events. Check out this page for more details: https://mailchimp.com/developer/marketing/docs/merge-fields/#add-merge-data-to-contacts",
                    "default": {
                        "FNAME": "{person.properties.firstname}",
                        "LNAME": "{person.properties.lastname}",
                        "COMPANY": "{person.properties.company}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Updates a contact in Mailchimp and subscribes new ones.",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/mailchimp.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-mailgun-send-email",
            "name": "Mailgun",
            "hog": "if (empty(inputs.template.to)) {\n    return false\n}\n\nfun multiPartFormEncode(data) {\n    let boundary := f'---011000010111000001101001'\n    let bodyBoundary := f'--{boundary}\\r\\n'\n    let body := bodyBoundary\n\n    for (let key, value in data) {\n        if (not empty(value)) {\n            body := f'{body}Content-Disposition: form-data; name=\"{key}\"\\r\\n\\r\\n{value}\\r\\n{bodyBoundary}'\n        }\n    }\n\n    return {\n        'body': body,\n        'contentType': f'multipart/form-data; boundary={boundary}'\n    }\n}\n\nlet form := multiPartFormEncode({\n    'from': inputs.template.from,\n    'to': inputs.template.to,\n    'subject': inputs.template.subject,\n    'text': inputs.template.text,\n    'html': inputs.template.html\n})\n\nlet res := fetch(f'https://{inputs.host}/v3/{inputs.domain_name}/messages', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Basic {base64Encode(f'api:{inputs.api_key}')}',\n        'Content-Type': form.contentType\n    },\n    'body': form.body\n})\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from mailgun api (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "domain_name",
                    "type": "string",
                    "label": "Mailgun Domain Name",
                    "description": "The domain name of the Mailgun account",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "api_key",
                    "type": "string",
                    "label": "Mailgun API Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "host",
                    "type": "choice",
                    "choices": [
                        {
                            "label": "US (api.mailgun.net)",
                            "value": "api.mailgun.net"
                        },
                        {
                            "label": "EU (api.eu.mailgun.net)",
                            "value": "api.eu.mailgun.net"
                        }
                    ],
                    "label": "Region",
                    "default": "api.eu.mailgun.net",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "template",
                    "type": "email",
                    "label": "Email template",
                    "default": {
                        "to": "{person.properties.email}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Email Marketing"],
            "description": "Send emails using the Mailgun HTTP API",
            "filters": {
                "events": [
                    {
                        "id": "",
                        "name": "\u003Cemail trigger event\u003E",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/mailgun.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-mailjet-create-contact",
            "name": "Mailjet",
            "hog": "if (empty(inputs.email)) {\n    return false\n}\n\nfetch(f'https://api.mailjet.com/v3/REST/contact/', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Basic {base64Encode(f'{inputs.api_key}:{inputs.secret_key}')}',\n        'Content-Type': 'application/json'\n    },\n    'body': {\n        'Email': inputs.email,\n        'Name': inputs.name,\n        'IsExcludedFromCampaigns': inputs.is_excluded_from_campaigns\n    }\n})",
            "inputs_schema": [
                {
                    "key": "api_key",
                    "type": "string",
                    "label": "Mailjet API Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "secret_key",
                    "type": "string",
                    "label": "Mailjet Secret Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the user to be checked with Mailjet",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "name",
                    "type": "string",
                    "label": "Name",
                    "description": "Name of the contact",
                    "default": "{person.properties.first_name} {person.properties.last_name}",
                    "secret": false,
                    "required": false
                },
                {
                    "key": "is_excluded_from_campaigns",
                    "type": "boolean",
                    "label": "Is excluded from campaigns",
                    "description": "Whether the contact should be excluded from campaigns",
                    "default": false,
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Add contacts to Mailjet",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/mailjet.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-mailjet-update-contact-list",
            "name": "Mailjet",
            "hog": "if (empty(inputs.email)) {\n    return false\n}\n\nfetch(f'https://api.mailjet.com/v3/REST/contact/{inputs.email}/managecontactlists', {\n    'method': 'POST',\n    'headers': {\n        'Authorization': f'Basic {base64Encode(f'{inputs.api_key}:{inputs.secret_key}')}',\n        'Content-Type': 'application/json'\n    },\n    'body': {\n        'ContactsLists':[\n            {\n                'Action': inputs.action,\n                'ListID': inputs.contact_list_id\n            },\n        ]\n    }\n})",
            "inputs_schema": [
                {
                    "key": "api_key",
                    "type": "string",
                    "label": "Mailjet API Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "secret_key",
                    "type": "string",
                    "label": "Mailjet Secret Key",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "Email of the user",
                    "description": "Where to find the email for the user to be checked with Mailjet",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "contact_list_id",
                    "type": "string",
                    "label": "Contact list ID",
                    "description": "ID of the contact list",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "action",
                    "type": "choice",
                    "label": "Action",
                    "secret": false,
                    "default": "addnoforce",
                    "required": true,
                    "choices": [
                        {
                            "label": "Add",
                            "value": "addnoforce"
                        },
                        {
                            "label": "Add (force)",
                            "value": "addforce"
                        },
                        {
                            "label": "Remove",
                            "value": "remove"
                        },
                        {
                            "label": "Unsubscribe",
                            "value": "unsub"
                        }
                    ]
                }
            ],
            "category": ["Email Marketing"],
            "description": "Update a Mailjet contact list",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/mailjet.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-make",
            "name": "Make",
            "hog": "if (not match(inputs.webhookUrl, '^https://hook.[^/]+.make.com/?.*')) {\n    throw Error('Invalid URL. The URL should match the format: https://hook.\u003Cregion\u003E.make.com/\u003ChookUrl\u003E')\n}\n\nlet res := fetch(inputs.webhookUrl, {\n    'body': inputs.body,\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json'\n    }\n});\n\nif (res.status \u003E= 400) {\n    throw Error(f'Error from make.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "webhookUrl",
                    "type": "string",
                    "label": "Webhook URL",
                    "description": "See this page on how to generate a Webhook URL: https://www.make.com/en/help/tools/webhooks",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "body",
                    "type": "json",
                    "label": "JSON Body",
                    "default": {
                        "data": {
                            "eventUuid": "{event.uuid}",
                            "event": "{event.event}",
                            "teamId": "{project.id}",
                            "distinctId": "{event.distinct_id}",
                            "properties": "{event.properties}",
                            "elementsChain": "{event.elementsChain}",
                            "timestamp": "{event.timestamp}",
                            "person": {
                                "uuid": "{person.id}",
                                "properties": "{person.properties}"
                            }
                        }
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Custom"],
            "description": "Triggers a webhook based scenario",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/make.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-meta-ads",
            "name": "Meta Ads Conversions",
            "hog": "let body := {\n    'data': [\n        {\n            'event_name': inputs.eventName,\n            'event_time': inputs.eventTime,\n            'action_source': inputs.actionSource,\n            'user_data': {},\n            'custom_data': {}\n        }\n    ],\n    'access_token': inputs.accessToken\n}\n\nfor (let key, value in inputs.userData) {\n    if (not empty(value)) {\n        body.data.1.user_data[key] := value\n    }\n}\n\nfor (let key, value in inputs.customData) {\n    if (not empty(value)) {\n        body.data.1.custom_data[key] := value\n    }\n}\n\nlet res := fetch(f'https://graph.facebook.com/v21.0/{inputs.pixelId}/events', {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json',\n    },\n    'body': body\n})\nif (res.status \u003E= 400) {\n    throw Error(f'Error from graph.facebook.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "accessToken",
                    "type": "string",
                    "label": "Access token",
                    "description": "Check out this page on how to obtain such a token: https://developers.facebook.com/docs/marketing-api/conversions-api/get-started",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "pixelId",
                    "type": "string",
                    "label": "Pixel ID",
                    "description": "You must obtain a Pixel ID to use the Conversions API. If youve already set up a Pixel for your website, we recommend that you use the same Pixel ID for your browser and server events.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventName",
                    "type": "string",
                    "label": "Event name",
                    "description": "A standard event or custom event name.",
                    "default": "{event.event}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventTime",
                    "type": "string",
                    "label": "Event time",
                    "description": "A Unix timestamp in seconds indicating when the actual event occurred. You must send this date in GMT time zone.",
                    "default": "{toInt(toUnixTimestamp(event.timestamp))}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "actionSource",
                    "label": "Action source",
                    "type": "choice",
                    "choices": [
                        {
                            "label": "Email - Conversion happened over email.",
                            "value": "email"
                        },
                        {
                            "label": "Website - Conversion was made on your website.",
                            "value": "website"
                        },
                        {
                            "label": "App - Conversion was made on your mobile app.",
                            "value": "app"
                        },
                        {
                            "label": "Phone call - Conversion was made over the phone.",
                            "value": "phone_call"
                        },
                        {
                            "label": "Chat - Conversion was made via a messaging app, SMS, or online messaging feature.",
                            "value": "chat"
                        },
                        {
                            "label": "Physical store - Conversion was made in person at your physical store.",
                            "value": "physical_store"
                        },
                        {
                            "label": "System generated - Conversion happened automatically, for example, a subscription renewal thats set to auto-pay each month.",
                            "value": "system_generated"
                        },
                        {
                            "label": "Business messaging - Conversion was made from ads that click to Messenger, Instagram or WhatsApp.",
                            "value": "business_messaging"
                        },
                        {
                            "label": "Other - Conversion happened in a way that is not listed.",
                            "value": "other"
                        }
                    ],
                    "description": "This field allows you to specify where your conversions occurred. Knowing where your events took place helps ensure your ads go to the right people.",
                    "default": "website",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "userData",
                    "type": "dictionary",
                    "label": "User data",
                    "description": "A map that contains customer information data. See this page for options: https://developers.facebook.com/docs/marketing-api/conversions-api/parameters/customer-information-parameters",
                    "default": {
                        "em": "{sha256Hex(person.properties.email)}",
                        "fn": "{sha256Hex(person.properties.first_name)}",
                        "ln": "{sha256Hex(person.properties.last_name)}"
                    },
                    "secret": false,
                    "required": true
                },
                {
                    "key": "customData",
                    "type": "dictionary",
                    "label": "Custom data",
                    "description": "A map that contains custom data. See this page for options: https://developers.facebook.com/docs/marketing-api/conversions-api/parameters/custom-data",
                    "default": {
                        "currency": "USD",
                        "price": "{event.properties.price}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Advertisement"],
            "description": "Send conversion events to Meta Ads",
            "filters": {
                "events": [],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/meta-ads.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "Post to Microsoft Teams on feature enrollment",
                    "description": "Posts a message to Microsoft Teams when a user enrolls or un-enrolls in an early access feature",
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "text": {
                            "default": "**{person.name}** {event.properties.$feature_enrollment ? 'enrolled in' : 'un-enrolled from'} the early access feature for '{event.properties.$feature_flag}'"
                        }
                    },
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "Post to Microsoft Teams on survey response",
                    "description": "Posts a message to Microsoft Teams when a user responds to a survey",
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "text": {
                            "default": "**{person.name}** responded to survey **{event.properties.$survey_name}**"
                        }
                    },
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "Post to Microsoft Teams on team activity",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": {
                        "text": {
                            "default": "**{person.name}** {event.properties.activity} {event.properties.scope} {event.properties.item_id}"
                        }
                    },
                    "type": "internal_destination"
                }
            ],
            "status": "stable",
            "free": true,
            "type": "destination",
            "id": "template-microsoft-teams",
            "name": "Microsoft Teams",
            "hog": "if (not match(inputs.webhookUrl, '^https://[^/]+.logic.azure.com:443/workflows/[^/]+/triggers/manual/paths/invoke?.*')) {\n    throw Error('Invalid URL. The URL should match the format: https://\u003Cregion\u003E.logic.azure.com:443/workflows/\u003CworkflowId\u003E/triggers/manual/paths/invoke?...')\n}\n\nlet res := fetch(inputs.webhookUrl, {\n    'body': {\n        'type': 'message',\n        'attachments': [\n            {\n                'contentType': 'application/vnd.microsoft.card.adaptive',\n                'contentUrl': null,\n                'content': {\n                    '$schema': 'http://adaptivecards.io/schemas/adaptive-card.json',\n                    'type': 'AdaptiveCard',\n                    'version': '1.2',\n                    'body': [\n                        {\n                            'type': 'TextBlock',\n                            'text': inputs.text,\n                            'wrap': true\n                        }\n                    ]\n                }\n            }\n        ]\n    },\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json'\n    }\n});\n\nif (res.status \u003E= 400) {\n    throw Error(f'Failed to post message to Microsoft Teams: {res.status}: {res.body}');\n}",
            "inputs_schema": [
                {
                    "key": "webhookUrl",
                    "type": "string",
                    "label": "Webhook URL",
                    "description": "See this page on how to generate a Webhook URL: https://support.microsoft.com/en-us/office/create-incoming-webhooks-with-workflows-for-microsoft-teams-8ae491c7-0394-4861-ba59-055e33f75498",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "text",
                    "type": "string",
                    "label": "Text",
                    "description": "(see https://learn.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook?tabs=newteams%2Cdotnet#example)",
                    "default": "**{person.name}** triggered event: '{event.event}'",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Customer Success"],
            "description": "Sends a message to a Microsoft Teams channel",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/microsoft-teams.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-posthog-replicator",
            "name": "PostHog",
            "hog": "let host := inputs.host\nlet token := inputs.token\nlet include_all_properties := inputs.include_all_properties\nlet propertyOverrides := inputs.properties\nlet properties := include_all_properties ? event.properties : {}\n\nfor (let key, value in propertyOverrides) {\n    properties[key] := value\n}\n\nfetch(f'{host}/e', {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json'\n    },\n    'body': {\n        'token': token,\n        'event': event.event,\n        'timestamp': event.timestamp,\n        'distinct_id': event.distinct_id,\n        'elements_chain': event.elements_chain,\n        'properties': properties\n    }\n})",
            "inputs_schema": [
                {
                    "key": "host",
                    "type": "string",
                    "label": "PostHog host",
                    "description": "For cloud accounts this is either https://us.i.posthog.com or https://eu.i.posthog.com",
                    "default": "https://us.i.posthog.com",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "token",
                    "type": "string",
                    "label": "PostHog API key",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_properties",
                    "type": "boolean",
                    "label": "Include all properties by default",
                    "description": "If set, all event properties will be included in the payload. Individual properties can be overridden below.",
                    "default": true,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Property overrides",
                    "description": "Provided values will override the event properties.",
                    "default": {},
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Custom", "Analytics"],
            "description": "Send a copy of the incoming data in realtime to another PostHog instance",
            "filters": null,
            "masking": null,
            "icon_url": "/static/posthog-icon.svg"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-rudderstack",
            "name": "RudderStack",
            "hog": "fun getPayload() {\n    let rudderPayload := {\n        'context': {\n            'app': {\n                'name': 'PostHogPlugin',\n            },\n            'os': {},\n            'page': {},\n            'screen': {},\n            'library': {},\n        },\n        'channel': 's2s',\n        'type': 'track',\n        'properties': {},\n    }\n\n    if (not empty(event.properties.$os)) rudderPayload.context.os.name := event.properties.$os\n    if (not empty(event.properties.$browser)) rudderPayload.context.browser := event.properties.$browser\n    if (not empty(event.properties.$browser_version)) rudderPayload.context.browser_version := event.properties.$browser_version\n    if (not empty(event.properties.$host)) rudderPayload.context.page.host := event.properties.$host\n    if (not empty(event.properties.$current_url)) rudderPayload.context.page.url := event.properties.$current_url\n    if (not empty(event.properties.$path)) rudderPayload.context.page.path := event.properties.$path\n    if (not empty(event.properties.$referrer)) rudderPayload.context.page.referrer := event.properties.$referrer\n    if (not empty(event.properties.$initial_referrer)) rudderPayload.context.page.initial_referrer := event.properties.$initial_referrer\n    if (not empty(event.properties.$referring_domain)) rudderPayload.context.page.referring_domain := event.properties.$referring_domain\n    if (not empty(event.properties.$initial_referring_domain)) rudderPayload.context.page.initial_referring_domain := event.properties.$initial_referring_domain\n    if (not empty(event.properties.$screen_height)) rudderPayload.context.screen.height := event.properties.$screen_height\n    if (not empty(event.properties.$screen_width)) rudderPayload.context.screen.width := event.properties.$screen_width\n    if (not empty(event.properties.$lib)) rudderPayload.context.library.name := event.properties.$lib\n    if (not empty(event.properties.$lib_version)) rudderPayload.context.library.version := event.properties.$lib_version\n    if (not empty(event.$ip)) rudderPayload.context.ip := event.$ip\n    if (not empty(event.properties.$active_feature_flags)) rudderPayload.context.active_feature_flags := event.properties.$active_feature_flags\n    if (not empty(event.properties.token)) rudderPayload.context.token := event.properties.token\n    if (not empty(event.uuid)) rudderPayload.messageId := event.uuid\n    if (not empty(event.timestamp)) rudderPayload.originalTimestamp := event.timestamp\n    if (not empty(inputs.identifier)) rudderPayload.userId := inputs.identifier\n    if (not empty(event.properties.$anon_distinct_id ?? event.properties.$device_id ?? event.properties.distinct_id)) rudderPayload.anonymousId := event.properties.$anon_distinct_id ?? event.properties.$device_id ?? event.properties.distinct_id\n\n    if (event.event in ('$identify', '$set')) {\n        rudderPayload.type := 'identify'\n        if (not empty(event.properties.$set)) rudderPayload.context.trait := event.properties.$set\n        if (not empty(event.properties.$set)) rudderPayload.traits := event.properties.$set\n    } else if (event.event == '$create_alias') {\n        rudderPayload.type := 'alias'\n        if (not empty(event.properties.alias)) rudderPayload.userId := event.properties.alias\n        if (not empty(event.distinct_id)) rudderPayload.previousId := event.distinct_id\n    } else if (event.event == '$pageview') {\n        rudderPayload.type := 'page'\n        if (not empty(event.properties.name)) rudderPayload.name := event.properties.name\n        if (not empty(event.properties.$host)) rudderPayload.properties.host := event.properties.$host\n        if (not empty(event.properties.$current_url)) rudderPayload.properties.url := event.properties.$current_url\n        if (not empty(event.properties.$pathname)) rudderPayload.properties.path := event.properties.$pathname\n        if (not empty(event.properties.$referrer)) rudderPayload.properties.referrer := event.properties.$referrer\n        if (not empty(event.properties.$initial_referrer)) rudderPayload.properties.initial_referrer := event.properties.$initial_referrer\n        if (not empty(event.properties.$referring_domain)) rudderPayload.properties.referring_domain := event.properties.$referring_domain\n        if (not empty(event.properties.$initial_referring_domain)) rudderPayload.properties.initial_referring_domain := event.properties.$initial_referring_domain\n    } else if (event.event == '$autocapture') {\n        rudderPayload.type := 'track'\n        if (not empty(event.properties.$event_type)) rudderPayload.event := event.properties.$event_type\n    } else {\n        rudderPayload.type := 'track'\n        if (not empty(event.event)) rudderPayload.event := event.event\n    }\n\n    for (let key, value in event.properties) {\n        if (value != null and not key like '$%') {\n            rudderPayload.properties[key] := value\n        }\n    }\n\n    return {\n        'method': 'POST',\n        'headers': {\n            'Content-Type': 'application/json',\n            'Authorization': f'Basic {base64Encode(f'{inputs.token}:')}',\n        },\n        'body': {\n            'batch': [rudderPayload],\n            'sentAt': now()\n        }\n    }\n}\n\nfetch(f'{replaceAll(inputs.host, '/v1/batch', '')}/v1/batch', getPayload())",
            "inputs_schema": [
                {
                    "key": "host",
                    "type": "string",
                    "label": "Rudderstack host",
                    "description": "The Rudderstack destination instance",
                    "default": "https://hosted.rudderlabs.com",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "token",
                    "type": "string",
                    "label": "Write API key",
                    "description": "RudderStack Source Writekey",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "identifier",
                    "type": "string",
                    "label": "Identifier",
                    "default": "{person.id}",
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Custom"],
            "description": "Send data to RudderStack",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/rudderstack.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-salesforce-create",
            "name": "Salesforce",
            "hog": "let getPayload := () -\u003E {\n  let properties := {}\n  if (inputs.include_all_event_properties) {\n    if (not empty(event.elements_chain)) {\n      properties['$elements_chain'] := event.elements_chain\n    }\n    for (let key, value in event.properties) {\n      properties[key] := value\n    }\n  }\n  if (inputs.include_all_person_properties) {\n    for (let key, value in person.properties) {\n      properties[key] := value\n    }\n  }\n  for (let key, value in inputs.properties) {\n    properties[key] := value\n  }\n  return properties\n}\n\nlet res := fetch(f'{inputs.oauth.instance_url}/services/data/v61.0/sobjects/{inputs.path}', {\n  'body': getPayload(),\n  'method': 'POST',\n  'headers': {\n    'Authorization': f'Bearer {inputs.oauth.access_token}',\n    'Content-Type': 'application/json'\n  }\n});\n\nif (res.status \u003E= 400) {\n  print('Bad response:', res.status, res.body)\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "salesforce",
                    "label": "Salesforce account",
                    "requiredScopes": "refresh_token full",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "path",
                    "type": "string",
                    "label": "Object path",
                    "description": "The path to the object you want to create.",
                    "default": "Contact",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_event_properties",
                    "type": "boolean",
                    "label": "Include all event properties as attributes",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_person_properties",
                    "type": "boolean",
                    "label": "Include all person properties as attributes",
                    "description": "If set, all person properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "json",
                    "label": "Additional properties",
                    "description": "Additional properties for the Salesforce Object.",
                    "default": {
                        "email": "{person.properties.email}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["CRM", "Customer Success"],
            "description": "Create objects in Salesforce",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/salesforce.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-salesforce-update",
            "name": "Salesforce",
            "hog": "let getPayload := () -\u003E {\n  let properties := {}\n  if (inputs.include_all_event_properties) {\n    for (let key, value in event.properties) {\n      properties[key] := value\n    }\n  }\n  if (inputs.include_all_person_properties) {\n    for (let key, value in person.properties) {\n      properties[key] := value\n    }\n  }\n  for (let key, value in inputs.properties) {\n    properties[key] := value\n  }\n  return properties\n}\n\nlet res := fetch(f'{inputs.oauth.instance_url}/services/data/v61.0/sobjects/{inputs.path}', {\n  'body': getPayload(),\n  'method': 'PATCH',\n  'headers': {\n    'Authorization': f'Bearer {inputs.oauth.access_token}',\n    'Content-Type': 'application/json'\n  }\n});\n\nif (res.status \u003E= 400) {\n  print('Bad response:', res.status, res.body)\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "salesforce",
                    "label": "Salesforce account",
                    "requiredScopes": "refresh_token full",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "path",
                    "type": "string",
                    "label": "Object path",
                    "description": "The path to the object you want to create or update. This can be a standard object like 'Contact' for creating records or `Lead/Email/{person.properties.email}` for updating a lead by email. See https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/dome_upsert.htm for more information.",
                    "default": "Leads/Email/{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_event_properties",
                    "type": "boolean",
                    "label": "Include all event properties as attributes",
                    "description": "If set, all event properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "include_all_person_properties",
                    "type": "boolean",
                    "label": "Include all person properties as attributes",
                    "description": "If set, all person properties will be included as attributes. Individual attributes can be overridden below.",
                    "default": false,
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "json",
                    "label": "Additional properties",
                    "description": "Additional properties for the Salesforce Object.",
                    "default": {
                        "email": "{person.properties.email}",
                        "browser": "{event.properties.$browser}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["CRM", "Customer Success"],
            "description": "Update objects in Salesforce",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/salesforce.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-sendgrid",
            "name": "Sendgrid",
            "hog": "if (empty(inputs.email)) {\n    print('`email` input is empty. Not updating contacts.')\n    return\n}\n\nlet contact := {\n  'email': inputs.email,\n}\n\nfor (let key, value in inputs.properties) {\n    if (not empty(value)) {\n        contact[key] := value\n    }\n}\n\nlet headers :=  {\n    'Authorization': f'Bearer {inputs.api_key}',\n    'Content-Type': 'application/json'\n}\n\nif (not empty(inputs.custom_fields)) {\n    let response := fetch('https://api.sendgrid.com/v3/marketing/field_definitions', {\n        'method': 'GET',\n        'headers': headers\n    })\n    if (response.status != 200) {\n        throw Error(f'Could not fetch custom fields. Status: {response.status}')\n    }\n    contact['custom_fields'] := {}\n    for (let obj in response.body?.custom_fields ?? {}) {\n        let inputValue := inputs.custom_fields[obj.name]\n        if (not empty(inputValue)) {\n            contact['custom_fields'][obj.id] := inputValue\n        }\n    }\n}\n\nlet res := fetch('https://api.sendgrid.com/v3/marketing/contacts', {\n    'method': 'PUT',\n    'headers': headers,\n    'body': { 'contacts': [contact] }\n})\n\nif (res.status \u003E 300) {\n    throw Error(f'Error from api.sendgrid.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "api_key",
                    "type": "string",
                    "label": "Sendgrid API Key",
                    "description": "See https://app.sendgrid.com/settings/api_keys",
                    "secret": true,
                    "required": true
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "The email of the user",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "properties",
                    "type": "dictionary",
                    "label": "Reserved fields",
                    "description": "The following field names are allowed: address_line_1, address_line_2, alternate_emails, anonymous_id, city, country, email, external_id, facebook, first_name, last_name, phone_number_id, postal_code, state_province_region, unique_name, whatsapp.",
                    "default": {
                        "first_name": "{person.properties.first_name}",
                        "last_name": "{person.properties.last_name}",
                        "city": "{person.properties.city}",
                        "country": "{person.properties.country}",
                        "postal_code": "{person.properties.postal_code}"
                    },
                    "secret": false,
                    "required": true
                },
                {
                    "key": "custom_fields",
                    "type": "dictionary",
                    "label": "Custom fields",
                    "description": "Configure custom fields in SendGrid before using them here: https://mc.sendgrid.com/custom-fields",
                    "default": {},
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Email Marketing"],
            "description": "Update marketing contacts in Sendgrid",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/sendgrid.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-snapchat-ads",
            "name": "Snapchat Ads Conversions",
            "hog": "let body := {\n    'data': [\n        {\n            'event_name': inputs.eventType,\n            'action_source': inputs.actionSource,\n            'event_time': inputs.eventTime,\n            'event_source_url': inputs.eventSourceUrl,\n            'user_data': {},\n            'custom_data': {}\n        }\n    ]\n}\n\nfor (let key, value in inputs.userData) {\n    if (not empty(value)) {\n        body.data.1.user_data[key] := value\n    }\n}\n\nfor (let key, value in inputs.customData) {\n    if (not empty(value)) {\n        body.data.1.custom_data[key] := value\n    }\n}\n\nlet res := fetch(f'https://tr.snapchat.com/v3/{inputs.pixelId}/events?access_token={inputs.oauth.access_token}', {\n    'method': 'POST',\n    'headers': {\n        'Content-Type': 'application/json',\n    },\n    'body': body\n})\nif (res.status \u003E= 400) {\n    throw Error(f'Error from tr.snapchat.com (status {res.status}): {res.body}')\n}",
            "inputs_schema": [
                {
                    "key": "oauth",
                    "type": "integration",
                    "integration": "snapchat",
                    "label": "Snapchat account",
                    "requiredScopes": "snapchat-offline-conversions-api snapchat-marketing-api",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "pixelId",
                    "type": "string",
                    "label": "Pixel ID",
                    "description": "You must obtain a Pixel ID to use the Conversions API. If youve already set up a Pixel for your website, we recommend that you use the same Pixel ID for your browser and server events.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "userData",
                    "type": "dictionary",
                    "label": "User data",
                    "description": "A map that contains customer information data. See this page for options: https://developers.snap.com/api/marketing-api/Conversions-API/Parameters#user-data-parameters",
                    "default": {
                        "em": "{sha256Hex(person.properties.email)}",
                        "ph": "{sha256Hex(person.properties.phone)}",
                        "sc_click_id": "{person.properties.sccid ?? person.properties.$initial_sccid}"
                    },
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventType",
                    "type": "string",
                    "label": "Event Type",
                    "description": "Check out this page for possible event types: https://businesshelp.snapchat.com/s/article/pixel-direct-implementation",
                    "default": "{event.event == '$pageview' ? 'PAGE_VIEW': event.event == 'Order Completed' ? 'PURCHASE': event.event == 'Checkout Started' ? 'START_CHECKOUT': event.event == 'Product Added' ? 'ADD_CART': event.event == 'Payment Info Entered' ? 'ADD_BILLING': event.event == 'Promotion Clicked' ? 'AD_CLICK': event.event == 'Promotion Viewed' ? 'AD_VIEW': event.event == 'Product Added to Wishlist' ? 'ADD_TO_WISHLIST': event.event == 'Product Viewed' ? 'VIEW_CONTENT': event.event == 'Product List Viewed' ? 'VIEW_CONTENT': event.event == 'Products Searched' ? 'SEARCH': event.event}",
                    "required": true
                },
                {
                    "key": "eventId",
                    "type": "string",
                    "label": "Event ID",
                    "description": "This field represents a unique identifier chosen to represent an event",
                    "default": "{event.uuid}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventTime",
                    "type": "string",
                    "label": "Event time",
                    "description": "A Unix timestamp in seconds indicating when the actual event occurred. You must send this date in GMT time zone.",
                    "default": "{toUnixTimestampMilli(event.timestamp)}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "eventSourceUrl",
                    "type": "string",
                    "label": "Event source URL",
                    "description": "The URL of the web page where the event took place.",
                    "default": "{event.properties.$current_url}",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "actionSource",
                    "label": "Action source",
                    "type": "choice",
                    "choices": [
                        {
                            "label": "WEB - Conversion was made on your website.",
                            "value": "WEB"
                        },
                        {
                            "label": "MOBILE_APP - Conversion was made on your mobile app.",
                            "value": "MOBILE_APP"
                        },
                        {
                            "label": "OFFLINE - Conversion happened in a way that is not listed.",
                            "value": "OFFLINE"
                        }
                    ],
                    "description": "This field allows you to specify where your conversions occurred. Knowing where your events took place helps ensure your ads go to the right people.",
                    "default": "WEB",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "customData",
                    "type": "dictionary",
                    "label": "Custom data",
                    "description": "A map that contains custom data. See this page for options: https://developers.snap.com/api/marketing-api/Conversions-API/Parameters#custom-data-parameters",
                    "default": {
                        "value": "{toFloat(event.properties.price ?? event.properties.value ?? event.properties.revenue)}",
                        "currency": "{event.properties.currency}",
                        "content_ids": "{event.properties.item_ids}",
                        "content_category": "{event.properties.category}",
                        "search_string": "{event.properties.search_string ?? event.properties.query}",
                        "num_items": "{toInt(event.properties.number_items ?? event.properties.quantity)}",
                        "order_id": "{event.properties.orderId ?? event.properties.transactionId ?? event.properties.transaction_id}",
                        "event_id": "{event.uuid}"
                    },
                    "secret": false,
                    "required": true
                }
            ],
            "category": ["Advertisement"],
            "description": "Send conversion events to Snapchat Ads",
            "filters": {
                "events": [
                    {
                        "id": "$pageview",
                        "name": "Pageview",
                        "type": "events"
                    },
                    {
                        "id": "Order Completed",
                        "type": "events"
                    },
                    {
                        "id": "Checkout Started",
                        "type": "events"
                    },
                    {
                        "id": "Product Added",
                        "type": "events"
                    },
                    {
                        "id": "Payment Info Entered",
                        "type": "events"
                    },
                    {
                        "id": "Promotion Clicked",
                        "type": "events"
                    },
                    {
                        "id": "Promotion Viewed",
                        "type": "events"
                    },
                    {
                        "id": "Product Added to Wishlist",
                        "type": "events"
                    },
                    {
                        "id": "Product Viewed",
                        "type": "events"
                    },
                    {
                        "id": "Product List Viewed",
                        "type": "events"
                    },
                    {
                        "id": "Products Searched",
                        "type": "events"
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/snapchat.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "stable",
            "free": true,
            "type": "destination",
            "id": "template-zapier",
            "name": "Zapier",
            "hog": "let res := fetch(f'https://hooks.zapier.com/{inputs.hook}', {\n  'method': 'POST',\n  'body': inputs.body\n});\n\nif (inputs.debug) {\n  print('Response', res.status, res.body);\n}",
            "inputs_schema": [
                {
                    "key": "hook",
                    "type": "string",
                    "label": "Zapier hook path",
                    "description": "The path of the Zapier webhook. You can create your own or use our native Zapier integration https://zapier.com/apps/posthog/integrations",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "body",
                    "type": "json",
                    "label": "JSON Body",
                    "default": {
                        "hook": {
                            "id": "{source.url}",
                            "event": "{event}",
                            "target": "https://hooks.zapier.com"
                        },
                        "data": {
                            "eventUuid": "{event.uuid}",
                            "event": "{event.event}",
                            "teamId": "{project.id}",
                            "distinctId": "{event.distinct_id}",
                            "properties": "{event.properties}",
                            "elementsChain": "{event.elementsChain}",
                            "timestamp": "{event.timestamp}",
                            "person": {
                                "uuid": "{person.id}",
                                "properties": "{person.properties}"
                            }
                        }
                    },
                    "secret": false,
                    "required": false
                },
                {
                    "key": "debug",
                    "type": "boolean",
                    "label": "Log responses",
                    "description": "Logs the response of http calls for debugging.",
                    "secret": false,
                    "required": false,
                    "default": false
                }
            ],
            "category": ["Custom"],
            "description": "Trigger Zaps in Zapier based on PostHog events.",
            "filters": null,
            "masking": null,
            "icon_url": "/static/services/zapier.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": null,
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-zendesk",
            "name": "Zendesk",
            "hog": "if (empty(inputs.email) or empty(inputs.name)) {\n    print('`email` or `name` input is empty. Not creating a contact.')\n    return\n}\n\nlet body := {\n    'user': {\n        'email': inputs.email,\n        'name': inputs.name,\n        'skip_verify_email': true,\n        'user_fields': {}\n    }\n}\n\nfor (let key, value in inputs.attributes) {\n    if (not empty(value) and key != 'email' and key != 'name') {\n        body.user.user_fields[key] := value\n    }\n}\n\nfetch(f'https://{inputs.subdomain}.zendesk.com/api/v2/users/create_or_update', {\n  'headers': {\n    'Authorization': f'Basic {base64Encode(f'{inputs.admin_email}/token:{inputs.token}')}',\n    'Content-Type': 'application/json'\n  },\n  'body': body,\n  'method': 'POST'\n});",
            "inputs_schema": [
                {
                    "key": "subdomain",
                    "type": "string",
                    "label": "Zendesk subdomain",
                    "description": "Generally, Your Zendesk URL has two parts: a subdomain name you chose when you set up your account, followed by zendesk.com (for example: mycompany.zendesk.com). Please share the subdomain name with us so we can set up your account.",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "admin_email",
                    "type": "string",
                    "label": "API user email",
                    "secret": true,
                    "required": true,
                    "description": "Enter the email of an admin in Zendesk. Activity using the API key will be attributed to this user."
                },
                {
                    "key": "token",
                    "type": "string",
                    "label": "API token",
                    "secret": true,
                    "required": true,
                    "hint": "Enter your Zendesk API Token"
                },
                {
                    "key": "email",
                    "type": "string",
                    "label": "User email",
                    "default": "{person.properties.email}",
                    "secret": false,
                    "required": true,
                    "hint": "The email of the user you want to create or update."
                },
                {
                    "key": "name",
                    "type": "string",
                    "label": "User name",
                    "default": "{person.properties.name}",
                    "secret": false,
                    "required": true,
                    "hint": "The name of the user you want to create or update."
                },
                {
                    "key": "attributes",
                    "type": "dictionary",
                    "label": "Attribute mapping",
                    "description": "Map of Zendesk user fields and their values. You'll need to create User fields in Zendesk for these to work.",
                    "default": {
                        "phone": "{person.properties.phone}",
                        "plan": "{person.properties.plan}"
                    },
                    "secret": false,
                    "required": false
                }
            ],
            "category": ["Customer Success"],
            "description": "Update contacts in Zendesk",
            "filters": {
                "events": [
                    {
                        "id": "$identify",
                        "name": "$identify",
                        "type": "events",
                        "order": 0
                    },
                    {
                        "id": "$set",
                        "name": "$set",
                        "type": "events",
                        "order": 1
                    }
                ],
                "actions": [],
                "filter_test_accounts": true
            },
            "masking": null,
            "icon_url": "/static/services/zendesk.png"
        },
        {
            "mapping_templates": null,
            "mappings": null,
            "sub_templates": [
                {
                    "id": "early-access-feature-enrollment",
                    "name": "HTTP Webhook on feature enrollment",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$feature_enrollment_update",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "survey-response",
                    "name": "HTTP Webhook on survey response",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "survey sent",
                                "type": "events",
                                "properties": [
                                    {
                                        "key": "$survey_response",
                                        "type": "event",
                                        "value": "is_set",
                                        "operator": "is_set"
                                    }
                                ]
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": null
                },
                {
                    "id": "activity-log",
                    "name": "HTTP Webhook on team activity",
                    "description": null,
                    "filters": {
                        "events": [
                            {
                                "id": "$activity_log_entry_created",
                                "type": "events"
                            }
                        ]
                    },
                    "masking": null,
                    "input_schema_overrides": null,
                    "type": "internal_destination"
                }
            ],
            "status": "beta",
            "free": false,
            "type": "destination",
            "id": "template-webhook",
            "name": "HTTP Webhook",
            "hog": "let payload := {\n  'headers': inputs.headers,\n  'body': inputs.body,\n  'method': inputs.method\n}\n\nif (inputs.debug) {\n  print('Request', inputs.url, payload)\n}\n\nlet res := fetch(inputs.url, payload);\n\nif (inputs.debug) {\n  print('Response', res.status, res.body);\n}",
            "inputs_schema": [
                {
                    "key": "url",
                    "type": "string",
                    "label": "Webhook URL",
                    "secret": false,
                    "required": true
                },
                {
                    "key": "method",
                    "type": "choice",
                    "label": "Method",
                    "secret": false,
                    "choices": [
                        {
                            "label": "POST",
                            "value": "POST"
                        },
                        {
                            "label": "PUT",
                            "value": "PUT"
                        },
                        {
                            "label": "PATCH",
                            "value": "PATCH"
                        },
                        {
                            "label": "GET",
                            "value": "GET"
                        },
                        {
                            "label": "DELETE",
                            "value": "DELETE"
                        }
                    ],
                    "default": "POST",
                    "required": false
                },
                {
                    "key": "body",
                    "type": "json",
                    "label": "JSON Body",
                    "default": {
                        "event": "{event}",
                        "person": "{person}"
                    },
                    "secret": false,
                    "required": false
                },
                {
                    "key": "headers",
                    "type": "dictionary",
                    "label": "Headers",
                    "secret": false,
                    "required": false,
                    "default": {
                        "Content-Type": "application/json"
                    }
                },
                {
                    "key": "debug",
                    "type": "boolean",
                    "label": "Log responses",
                    "description": "Logs the response of http calls for debugging.",
                    "secret": false,
                    "required": false,
                    "default": false
                }
            ],
            "category": ["Custom"],
            "description": "Sends a webhook templated by the incoming event data",
            "filters": null,
            "masking": null,
            "icon_url": "/static/posthog-icon.svg"
        }
    ]
}
