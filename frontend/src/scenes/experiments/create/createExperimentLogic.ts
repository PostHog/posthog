import { actions, connect, kea, listeners, path, props, reducers, selectors } from 'kea'
import { forms } from 'kea-forms'
import { router } from 'kea-router'

import api from 'lib/api'
import { MAX_EXPERIMENT_VARIANTS } from 'lib/constants'
import { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'
import { featureFlagLogic } from 'lib/logic/featureFlagLogic'
import { eventUsageLogic } from 'lib/utils/eventUsageLogic'
import { ProductIntentContext } from 'lib/utils/product-intents'
import { featureFlagsLogic } from 'scenes/feature-flags/featureFlagsLogic'
import { teamLogic } from 'scenes/teamLogic'
import { urls } from 'scenes/urls'

import { refreshTreeItem } from '~/layout/panel-layout/ProjectTree/projectTreeLogic'
import type { ExperimentExposureCriteria } from '~/queries/schema/schema-general'
import type { Experiment, FeatureFlagFilters, FeatureFlagType, FilterType, MultivariateFlagVariant } from '~/types'
import { ProductKey } from '~/types'

import { NEW_EXPERIMENT } from '../constants'
import type { createExperimentLogicType } from './createExperimentLogicType'

const generateFeatureFlagKey = (name: string, existingKeys: Set<string>): string => {
    const baseKey = name
        .toLowerCase()
        .replace(/[^a-z0-9-_]+/g, '-')
        .replace(/-+$/, '')
        .replace(/^-+/, '')

    let key = baseKey
    let counter = 1

    while (existingKeys.has(key)) {
        key = `${baseKey}-${counter}`
        counter++
    }
    return key
}

export const createExperimentLogic = kea<createExperimentLogicType>([
    props(() => ({})),
    path(['scenes', 'experiments', 'create', 'createExperimentLogic']),
    connect(() => ({
        values: [featureFlagLogic, ['featureFlags']],
        actions: [
            eventUsageLogic,
            ['reportExperimentCreated'],
            featureFlagsLogic,
            ['updateFlag'],
            teamLogic,
            ['addProductIntent'],
        ],
    })),
    forms(() => ({
        experiment: {
            options: { showErrorsOnTouch: true },
            defaults: { ...NEW_EXPERIMENT } as Experiment,
            errors: ({ name, description }: Experiment) => ({
                name: !name ? 'Name is required' : undefined,
                description: !description ? 'Hypothesis is required' : undefined,
            }),
        },
    })),
    actions(() => ({
        setExperiment: (experiment: Experiment) => ({ experiment }),
        createExperiment: () => ({}),
        createExperimentSuccess: true,
        // Variant actions
        addVariant: true,
        removeVariant: (index: number) => ({ index }),
        updateVariant: (index: number, variant: Partial<MultivariateFlagVariant>) => ({ index, variant }),
        distributeVariantsEqually: true,
        // Feature flag actions
        generateFeatureFlagKey: true,
        validateFeatureFlagKey: (key: string) => ({ key }),
        updateFeatureFlagKey: (key: string) => ({ key }),
        setFeatureFlagAutoGenerated: (isAutoGenerated: boolean) => ({ isAutoGenerated }),
        // Exposure criteria actions
        setExposureCriteria: (criteria: Partial<ExperimentExposureCriteria>) => ({ criteria }),
        // Targeting actions
        setTargeting: (targeting: FilterType) => ({ targeting }),
        setFeatureFlagFilters: (filters: FeatureFlagFilters) => ({ filters }),
        // Flag source actions
        setFlagSourceMode: (mode: 'create' | 'link') => ({ mode }),
        setLinkedFeatureFlag: (flag: FeatureFlagType | null) => ({ flag }),
        // Metrics actions
        addPrimaryMetric: (metric: any) => ({ metric }),
        removePrimaryMetric: (metricUuid: string) => ({ metricUuid }),
        addSecondaryMetric: (metric: any) => ({ metric }),
        removeSecondaryMetric: (metricUuid: string) => ({ metricUuid }),
        updatePrimaryMetricOrdering: (orderedUuids: string[]) => ({ orderedUuids }),
        updateSecondaryMetricOrdering: (orderedUuids: string[]) => ({ orderedUuids }),
    })),
    reducers(() => ({
        experimentCreated: [
            false,
            {
                createExperimentSuccess: () => true,
                createExperiment: () => false,
            },
        ],
        isFeatureFlagAutoGenerated: [
            false,
            {
                setFeatureFlagAutoGenerated: (_, { isAutoGenerated }) => isAutoGenerated,
                updateFeatureFlagKey: () => {
                    // If key is being manually updated, it's no longer auto-generated
                    return false
                },
            },
        ],
        experiment: [
            { ...NEW_EXPERIMENT } as Experiment & { feature_flag_filters?: FeatureFlagFilters },
            {
                setExperiment: (_, { experiment }) => experiment,
                updateFeatureFlagKey: (state, { key }) => ({ ...state, feature_flag_key: key }),
            },
        ],
        flagSourceMode: [
            'create' as 'create' | 'link',
            {
                setFlagSourceMode: (_, { mode }) => mode,
            },
        ],
        linkedFeatureFlag: [
            null as FeatureFlagType | null,
            {
                setLinkedFeatureFlag: (_, { flag }) => flag,
                setFlagSourceMode: (state, { mode }) => (mode === 'create' ? null : state),
            },
        ],
    })),
    selectors(() => ({
        variants: [(s) => [s.experiment], (experiment) => experiment.parameters?.feature_flag_variants || []],
        variantRolloutSum: [
            (s) => [s.variants],
            (variants) => variants.reduce((total: number, { rollout_percentage }) => total + rollout_percentage, 0),
        ],
        areVariantRolloutsValid: [
            (s) => [s.variants, s.variantRolloutSum],
            (variants, variantRolloutSum) =>
                variants.every(({ rollout_percentage }) => rollout_percentage >= 0 && rollout_percentage <= 100) &&
                variantRolloutSum === 100,
        ],
        hasTargeting: [
            (s) => [s.experiment],
            (experiment) => {
                const filters = (experiment as any).feature_flag_filters
                return !!filters?.groups?.some(
                    (group: any) =>
                        group.properties?.length > 0 ||
                        (group.rollout_percentage !== null && group.rollout_percentage !== 100)
                )
            },
        ],
        // Metrics selectors
        primaryMetrics: [(s) => [s.experiment], (experiment) => experiment.metrics || []],
        secondaryMetrics: [(s) => [s.experiment], (experiment) => experiment.secondary_metrics || []],
        primaryMetricsCount: [(s) => [s.primaryMetrics], (metrics) => metrics.length],
        secondaryMetricsCount: [(s) => [s.secondaryMetrics], (metrics) => metrics.length],
        hasMetrics: [
            (s) => [s.primaryMetricsCount, s.secondaryMetricsCount],
            (primaryCount, secondaryCount) => primaryCount > 0 || secondaryCount > 0,
        ],
        hasPrimaryMetrics: [(s) => [s.primaryMetricsCount], (count) => count > 0],
    })),
    listeners(({ values, actions }) => ({
        setExperiment: () => {
            console.log('setExperiment', values.experiment)
        },
        setExperimentValue: () => {
            console.log('setExperimentValue', values.experiment)
        },
        createExperiment: async () => {
            // TODO: Add form validation here

            const response = (await api.create(`api/projects/@current/experiments`, values.experiment)) as Experiment

            if (response.id) {
                // Report analytics
                actions.reportExperimentCreated(response)
                actions.addProductIntent({
                    product_type: ProductKey.EXPERIMENTS,
                    intent_context: ProductIntentContext.EXPERIMENT_CREATED,
                })

                // Signal successful creation (triggers Hogfetti in component)
                actions.createExperimentSuccess()

                // Refresh tree navigation
                refreshTreeItem('experiment', String(response.id))
                if (response.feature_flag?.id) {
                    refreshTreeItem('feature_flag', String(response.feature_flag.id))
                }

                // Show success toast
                lemonToast.success('Experiment created successfully!', {
                    button: {
                        label: 'View it',
                        action: () => {
                            router.actions.push(urls.experiment(response.id))
                        },
                    },
                })

                // Navigate to experiment page
                router.actions.push(urls.experiment(response.id))
            }
        },
        addVariant: () => {
            const currentVariants = values.experiment.parameters?.feature_flag_variants || []
            if (currentVariants.length < MAX_EXPERIMENT_VARIANTS) {
                const newVariantIndex = currentVariants.length
                const newVariant: MultivariateFlagVariant = {
                    key: `test-${newVariantIndex}`,
                    rollout_percentage: Math.floor(100 / (currentVariants.length + 1)),
                }

                // Recalculate percentages
                const updatedVariants = [...currentVariants, newVariant].map((v) => ({
                    ...v,
                    rollout_percentage: Math.floor(100 / (currentVariants.length + 1)),
                }))

                actions.setExperiment({
                    ...values.experiment,
                    parameters: {
                        ...values.experiment.parameters,
                        feature_flag_variants: updatedVariants,
                    },
                })
            }
        },
        removeVariant: ({ index }) => {
            const currentVariants = values.experiment.parameters?.feature_flag_variants || []
            if (index > 1 && index < currentVariants.length) {
                const updatedVariants = currentVariants.filter((_, i) => i !== index)

                // Recalculate percentages
                const recalculatedVariants = updatedVariants.map((v) => ({
                    ...v,
                    rollout_percentage: Math.floor(100 / updatedVariants.length),
                }))

                actions.setExperiment({
                    ...values.experiment,
                    parameters: {
                        ...values.experiment.parameters,
                        feature_flag_variants: recalculatedVariants,
                    },
                })
            }
        },
        updateVariant: ({ index, variant }) => {
            const currentVariants = values.experiment.parameters?.feature_flag_variants || []
            const updatedVariants = [...currentVariants]
            updatedVariants[index] = { ...updatedVariants[index], ...variant }

            actions.setExperiment({
                ...values.experiment,
                parameters: {
                    ...values.experiment.parameters,
                    feature_flag_variants: updatedVariants,
                },
            })
        },
        generateFeatureFlagKey: async () => {
            if (!values.experiment.feature_flag_key && values.experiment.name) {
                try {
                    // Fetch existing feature flags to avoid key conflicts
                    const response = await api.get('api/projects/@current/feature_flags/')
                    const existingKeys = new Set<string>(
                        response.results
                            ?.map((flag: FeatureFlagType) => flag.key)
                            .filter((key: any): key is string => Boolean(key)) || []
                    )
                    const generatedKey = generateFeatureFlagKey(values.experiment.name, existingKeys)
                    actions.updateFeatureFlagKey(generatedKey)
                    actions.setFeatureFlagAutoGenerated(true)
                } catch {
                    // Fallback to basic generation if API fails
                    const generatedKey = generateFeatureFlagKey(values.experiment.name, new Set())
                    actions.updateFeatureFlagKey(generatedKey)
                    actions.setFeatureFlagAutoGenerated(true)
                }
            }
        },
        setExposureCriteria: ({ criteria }) => {
            actions.setExperiment({
                ...values.experiment,
                exposure_criteria: {
                    ...values.experiment.exposure_criteria,
                    ...criteria,
                },
            })
        },
        setTargeting: ({ targeting }) => {
            actions.setExperiment({
                ...values.experiment,
                filters: targeting,
            })
        },
        setFeatureFlagFilters: ({ filters }) => {
            actions.setExperiment({
                ...values.experiment,
                feature_flag_filters: filters,
            } as any)
        },
        setLinkedFeatureFlag: ({ flag }) => {
            if (flag) {
                // Sync flag data to experiment
                actions.setExperiment({
                    ...values.experiment,
                    feature_flag_key: flag.key,
                    parameters: {
                        ...values.experiment.parameters,
                        feature_flag_variants: flag.filters?.multivariate?.variants || [],
                    },
                })
            }
        },
        distributeVariantsEqually: () => {
            const currentVariants = values.experiment.parameters?.feature_flag_variants || []
            const numVariants = currentVariants.length
            if (numVariants > 0 && numVariants <= 100) {
                const percentageRounded = Math.round(100 / numVariants)
                const totalRounded = percentageRounded * numVariants
                const delta = totalRounded - 100
                const updatedVariants = currentVariants.map((variant, index) => ({
                    ...variant,
                    rollout_percentage: index === numVariants - 1 ? percentageRounded - delta : percentageRounded,
                }))

                actions.setExperiment({
                    ...values.experiment,
                    parameters: {
                        ...values.experiment.parameters,
                        feature_flag_variants: updatedVariants,
                    },
                })
            }
        },
        addPrimaryMetric: ({ metric }) => {
            const currentMetrics = values.experiment.metrics || []
            const currentOrdering = values.experiment.primary_metrics_ordered_uuids || []

            actions.setExperiment({
                ...values.experiment,
                metrics: [...currentMetrics, metric],
                primary_metrics_ordered_uuids: [...currentOrdering, metric.uuid],
            })
        },
        removePrimaryMetric: ({ metricUuid }) => {
            const currentMetrics = values.experiment.metrics || []
            const currentOrdering = values.experiment.primary_metrics_ordered_uuids || []

            actions.setExperiment({
                ...values.experiment,
                metrics: currentMetrics.filter((m: any) => m.uuid !== metricUuid),
                primary_metrics_ordered_uuids: currentOrdering.filter((uuid) => uuid !== metricUuid),
            })
        },
        addSecondaryMetric: ({ metric }) => {
            const currentMetrics = values.experiment.secondary_metrics || []
            const currentOrdering = values.experiment.secondary_metrics_ordered_uuids || []

            actions.setExperiment({
                ...values.experiment,
                secondary_metrics: [...currentMetrics, metric],
                secondary_metrics_ordered_uuids: [...currentOrdering, metric.uuid],
            })
        },
        removeSecondaryMetric: ({ metricUuid }) => {
            const currentMetrics = values.experiment.secondary_metrics || []
            const currentOrdering = values.experiment.secondary_metrics_ordered_uuids || []

            actions.setExperiment({
                ...values.experiment,
                secondary_metrics: currentMetrics.filter((m: any) => m.uuid !== metricUuid),
                secondary_metrics_ordered_uuids: currentOrdering.filter((uuid) => uuid !== metricUuid),
            })
        },
        updatePrimaryMetricOrdering: ({ orderedUuids }) => {
            actions.setExperiment({
                ...values.experiment,
                primary_metrics_ordered_uuids: orderedUuids,
            })
        },
        updateSecondaryMetricOrdering: ({ orderedUuids }) => {
            actions.setExperiment({
                ...values.experiment,
                secondary_metrics_ordered_uuids: orderedUuids,
            })
        },
    })),
])
