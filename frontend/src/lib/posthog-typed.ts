/**
 * GENERATED FILE - DO NOT EDIT
 *
 * This file was auto-generated by PostHog
 * Generated at: 2025-10-30T08:57:58.429459
 *
 * Provides captureTyped() for type-safe events and capture() for flexibility
 */
import originalPostHog from 'posthog-js'
import type { CaptureOptions, CaptureResult, PostHog as OriginalPostHog, Properties } from 'posthog-js'

// Define event schemas
interface EventSchemas {
    $autocapture: Record<string, any>
    $exception: Record<string, any>
    $feature_flag_called: Record<string, any>
    $groupidentify: Record<string, any>
    $identify: Record<string, any>
    $opt_in: Record<string, any>
    $pageleave: Record<string, any>
    $pageview: Record<string, any>
    $rageclick: Record<string, any>
    $set: Record<string, any>
    $web_vitals: Record<string, any>
    'activation sidebar task completed': Record<string, any>
    client_request_failure: Record<string, any>
    'dashboard insight refreshed': Record<string, any>
    'dashboard refreshed': Record<string, any>
    downloaded_file: {
        file_name?: string
        file_size_b: number
        file_type?: string
    }
    'event definitions page event nested properties load succeeded': Record<string, any>
    'event definitions page load succeeded': Record<string, any>
    'event property definitions page load succeeded': Record<string, any>
    'insight analyzed': Record<string, any>
    'insight created': Record<string, any>
    'insight refresh time': Record<string, any>
    'insight viewed': Record<string, any>
    invited_team_member: Record<string, any>
    logged_out: Record<string, any>
    memory_usage: Record<string, any>
    not_found_shown: Record<string, any>
    'onboarding_tasks team setting updated': Record<string, any>
    paid_bill: Record<string, any>
    'query completed': Record<string, any>
    'query executed': Record<string, any>
    'query failed': Record<string, any>
    'recording viewed with no playtime summary': Record<string, any>
    signed_up: Record<string, any>
    spinner_unloaded: Record<string, any>
    'time to see data': Record<string, any>
    upgraded_plan: Record<string, any>
    uploaded_file: {
        file_name?: string
        file_size_b: number
        file_type?: string
    }
    'user logged in': Record<string, any>
    'viewed dashboard': Record<string, any>
}

// Type alias for all valid event names
export type EventName = keyof EventSchemas

// Type helper to get properties for a specific event (includes additional properties)
export type EventProperties<K extends EventName> = EventSchemas[K] & Record<string, any>

// Helper type to check if a type requires properties (has required fields)
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type RequiresProperties<T> = {} extends T ? false : true

// Enhanced PostHog interface with typed capture
interface TypedPostHog extends Omit<OriginalPostHog, 'capture'> {
    /**
     * Type-safe capture for defined events
     *
     * Note: Additional properties beyond the schema are allowed
     *
     * @example
     * posthog.captureTyped('Product Added', {
     *   product_id: '123',
     *   name: 'Widget',
     *   price: 42,
     *   quantity: 1,
     *   custom_field: 'extra' // additional properties allowed
     * })
     *
     * @example
     * // For events with all optional properties, properties argument is optional
     * posthog.captureTyped('Logged in') // no properties needed
     */
    captureTyped<K extends EventName>(
        event_name: K,
        ...args: RequiresProperties<EventSchemas[K]> extends true
            ? [properties: EventProperties<K>, options?: CaptureOptions]
            : [properties?: EventProperties<K>, options?: CaptureOptions]
    ): CaptureResult | undefined

    /**
     * Flexible capture for any event (original behavior)
     *
     * Use captureTyped() when you want type safety for defined events.
     * Use capture() when you need flexibility (dynamic events, untyped events, etc.)
     *
     * @example
     * posthog.capture('Custom Event Name', { any: 'data' })
     */
    capture(event_name: string, properties?: Properties | null, options?: CaptureOptions): CaptureResult | undefined
}

// Create the implementation
const createTypedPostHog = (original: OriginalPostHog): TypedPostHog => {
    // Create the enhanced PostHog object
    const enhanced: TypedPostHog = Object.create(original)

    // Add captureTyped method
    enhanced.captureTyped = function <K extends EventName>(event_name: K, ...args: any[]): CaptureResult | undefined {
        const [properties, options] = args
        return original.capture(event_name, properties, options)
    }

    // Keep capture method for untyped/flexible event tracking
    enhanced.capture = function (
        event_name: string,
        properties?: Properties | null,
        options?: CaptureOptions
    ): CaptureResult | undefined {
        return original.capture(event_name, properties, options)
    }

    // Proxy to delegate all other properties/methods to the original
    return new Proxy(enhanced, {
        get(target, prop) {
            if (prop in target) {
                return (target as any)[prop]
            }
            return (original as any)[prop]
        },
        set(target, prop, value) {
            ;(original as any)[prop] = value
            return true
        },
    })
}

// Create and export the typed instance
const posthog = createTypedPostHog(originalPostHog as OriginalPostHog)

export default posthog
export { posthog }
export type { EventSchemas, TypedPostHog }

// Re-export everything else from posthog-js
export * from 'posthog-js'

/**
 * USAGE GUIDE
 * ===========
 *
 * For type-safe events (recommended):
 *   posthog.captureTyped('Product Added', { product_id: '123', name: 'Widget', price: 42, quantity: 1 })
 *
 * For untyped/dynamic events (when you need flexibility):
 *   posthog.capture('Custom Event', { any: 'data' })
 */
