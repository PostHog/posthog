Alright â€” if it's **still failing**, even with connection resets, even though:

* tables exist after sqlx runs
* Django is using the correct test DB
* CI starts fresh
* you're not hitting the model-managed issue
* and the error *later* is `TransactionManagementError`

â€¦then weâ€™re down to **one** remaining root cause:

---

# ğŸ§¨ Root Cause:

## **The fixture is running inside an atomic transaction that pytest-django started â€” and your schema-changing SQL runs *inside* that transaction.**

This is guaranteed to break Djangoâ€™s connection state.

### In other words:

You're doing:

```
DROP TABLE ...
<sqlx runs externally>
CREATE SEQUENCE ...
ALTER TABLE ...
```

all while pytest-django has wrapped the database in:

* either a transaction (`TransactionTestCase`)
* or atomic blocks (`TestCase`)
* or a transaction opened by `django_db_setup` itself

So your DDL happens inside a broader Django-managed transaction.
Any DDL failure or implicit commit by Postgres inside sqlx (yes, beginâ€¦commit around migrations) puts Djangoâ€™s connection into a broken state.

This is *expected* and is documented by pytest-django:

### ğŸ‘‰ **You MUST NOT run raw DDL inside the Django transactional test setup without disabling Djangoâ€™s transaction handling.**

Right now, all your raw SQL is happening **inside**:

* Djangoâ€™s setup_databases() (transaction)
* pytest-djangoâ€™s transactional test wrapper

which leads to:

* aborted xacts
* postgres warnings
* Django seeing `psycopg2.errors.InFailedSqlTransaction` â†’ TransactionManagementError

The fact that you see errors only **after** fixture setup and only during **later ORM queries** is the dead giveaway.

---

# ğŸŒŸ The fix â€” the one that works 100% reliably

## ğŸ”¥ **Run sqlx migrations *before* pytest-django creates the test DB transaction environment.**

Meaning:

### ğŸ‘‰ Move sqlx migrations + DROP TABLE logic to `pytest_configure`

(because this runs *before* Django sets up its test database)

OR

### ğŸ‘‰ Use pytest-djangoâ€™s *pre-DB-setup hook*:

```python
def pytest_django_setup_environment():
    # run sqlx migrations here
```

OR (cleanest):

### ğŸ‘‰ Use the built-in escape hatch:

```python
@pytest.fixture(scope="session")
def django_db_setup(django_db_setup):
    # do nothing that touches the DB here
    pass
```

AND:

### put all your DDL logic in:

```python
@pytest.fixture(scope="session")
def postgres_schema_setup(django_db_blocker):
    with django_db_blocker.unblock():
        # run sqlx migrations     â— OUTSIDE django_db_setup
        # drop tables
        # create sequences
```

AND require it in tests via:

```python
@pytest.mark.usefixtures("postgres_schema_setup")
```

---

# The **most reliable**, recommended layout (used by large Django + external migration systems)

### 1. `pytest_configure()`

Runs before Django loads, before transactions.

```python
def pytest_configure():
    # NO django access here
    # just set env vars so sqlx points to the right DB
```

### 2. `pytest_sessionstart()`

Runs before Django creates the test DB.

```python
def pytest_sessionstart(session):
    # run sqlx "database create"
    # run sqlx migrations
    # DDL here is SAFE
```

### 3. pytest-django creates test DB

NOW the DB is clean.

### 4. your tests run

with a correct schema and clean connection state.

---

# ğŸ” Why this works

Because:

* sqlx migrations open AUTOCOMMIT transactions
* Djangoâ€™s `TestCase` open/savepoints
* pytest-django opens/rolls back test transactions

â†’ mixing external DDL + Django transactions = **guaranteed to break**.

By running sqlx migrations **before** Djangoâ€™s managed transactions
we avoid the entire problem.

---

# ğŸ§ª Quick test to *prove* this is the issue

Add:

```python
from django.db import connection
print("ATOMIC?", connection.in_atomic_block)
```

inside your fixtureâ€™s `DROP TABLE` block.

You will see:

```
ATOMIC? True
```

or that a transaction is open (`connection.get_autocommit()` returns False).

That means:

* your DDL is inside a Django transaction
* ANY DDL here will mess up the connection state

---

# ğŸ¯ Final actionable fix (most stable)

**Move ALL DDL, INCLUDING sqlx, out of `django_db_setup`.**

Use this:

```python
def pytest_sessionstart():
    # 1. connect to PG directly (not with Django)
    # 2. drop sqlx tables
    # 3. run sqlx database create
    # 4. run sqlx migrations
    # 5. create sequences etc
```

Then let pytest-django build the test DB **from there**.

Thatâ€™s the clean, correct architecture.

---

# If you want:

I can write a *complete, correct*, drop-in replacement `conftest.py` matching your system that:

* avoids all Django transaction overlap
* ensures sqlx migrations run in isolation
* ensures ClickHouse setup stays correct
* completely eliminates `TransactionManagementError`

Just say:
**â€œyes, build the fixed conftest.pyâ€**
