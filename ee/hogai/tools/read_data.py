from typing import Literal, Self

from langchain_core.runnables import RunnableConfig
from pydantic import BaseModel

from posthog.schema import ArtifactMessage

from posthog.models import Team, User

from ee.hogai.artifacts.utils import unwrap_visualization_artifact_content
from ee.hogai.chat_agent.sql.mixins import HogQLDatabaseMixin
from ee.hogai.context.context import AssistantContextManager
from ee.hogai.tool import MaxTool
from ee.hogai.tool_errors import MaxToolFatalError
from ee.hogai.utils.prompt import format_prompt_string
from ee.hogai.utils.types.base import AssistantState, NodePath

from .read_billing_tool.tool import ReadBillingTool

READ_DATA_BILLING_PROMPT = """
# Billing information

Use this tool with the "billing_info" kind to retrieve the billing information if the user asks about their billing, subscription, product usage, spending, or cost reduction strategies.
You can use the information retrieved to check which PostHog products and add-ons the user has activated, how much they are spending, their usage history across all products in the last 30 days, as well as trials, spending limits, billing period, and more.
If the user wants to reduce their spending, always call this tool to get suggestions on how to do so.
If an insight shows zero data, it could mean either the query is looking at the wrong data or there was a temporary data collection issue. You can investigate potential dips in usage/captured data using the billing tool.
""".strip()

READ_DATA_ARTIFACTS_PROMPT = """
# Artifacts

Returns the list of artifacts generated in the current conversation, including the ones generated by subagent tasks. Supported artifacts:
- Data visualizations: any new visualization generated when creating an insight or running a SQL query. Does not include insights created by the user, which can be found using the search tool.
""".strip()

READ_DATA_PROMPT = """
Use this tool to read user data created in PostHog. This tool returns data that the user manually creates in PostHog.

# Data warehouse schema

Returns the SQL ClickHouse schema for the user's data warehouse.
You MUST use this tool when:
- Working with SQL.
- The request is about data warehouse, connected data sources, etc.

{{{artifacts_prompt}}}

{{{billing_prompt}}}
""".strip()

BILLING_INSUFFICIENT_ACCESS_PROMPT = """
The user does not have admin access to view detailed billing information. They would need to contact an organization admin for billing details.
Suggest the user to contact the admins.
""".strip()

ReadDataKind = Literal["datawarehouse_schema"]
ReadDataAdminAccessKind = Literal["datawarehouse_schema", "billing_info"]
ReadDataWithArtifactsKind = Literal["datawarehouse_schema", "artifacts"]
ReadDataAdminAccessWithArtifactsKind = Literal["datawarehouse_schema", "billing_info", "artifacts"]

KindUnion = ReadDataWithArtifactsKind | ReadDataAdminAccessWithArtifactsKind | ReadDataKind | ReadDataAdminAccessKind


class ReadDataWithArtifactToolArgs(BaseModel):
    kind: ReadDataWithArtifactsKind


class ReadDataAdminAccessWithArtifactToolArgs(BaseModel):
    kind: ReadDataAdminAccessWithArtifactsKind


class ReadDataToolArgs(BaseModel):
    kind: ReadDataKind


class ReadDataAdminAccessToolArgs(BaseModel):
    kind: ReadDataAdminAccessKind


class ReadDataTool(HogQLDatabaseMixin, MaxTool):
    name: Literal["read_data"] = "read_data"
    description: str = READ_DATA_PROMPT
    context_prompt_template: str = "Reads user data created in PostHog (data warehouse schema, billing information)"
    args_schema: type[BaseModel] = ReadDataToolArgs

    @classmethod
    async def create_tool_class(
        cls,
        *,
        team: Team,
        user: User,
        node_path: tuple[NodePath, ...] | None = None,
        state: AssistantState | None = None,
        config: RunnableConfig | None = None,
        context_manager: AssistantContextManager | None = None,
        can_read_artifacts: bool = False,
    ) -> Self:
        """
        Factory that creates a ReadDataTool with a dynamic args schema.

        Override this factory to add additional args schemas or descriptions.
        """
        if not context_manager:
            context_manager = AssistantContextManager(team, user, config)

        has_billing_access = await context_manager.check_user_has_billing_access()

        # Subagents don't have access to artifacts
        if can_read_artifacts:
            args: type[BaseModel] = (
                ReadDataAdminAccessWithArtifactToolArgs if has_billing_access else ReadDataWithArtifactToolArgs
            )
            artifacts_prompt = ""
        else:
            args = ReadDataAdminAccessToolArgs if has_billing_access else ReadDataToolArgs
            artifacts_prompt = READ_DATA_ARTIFACTS_PROMPT

        billing_prompt = READ_DATA_BILLING_PROMPT if has_billing_access else ""
        description = format_prompt_string(
            READ_DATA_PROMPT, artifacts_prompt=artifacts_prompt, billing_prompt=billing_prompt
        )

        return cls(
            team=team,
            user=user,
            state=state,
            node_path=node_path,
            config=config,
            args_schema=args,
            description=description,
            context_manager=context_manager,
        )

    async def _arun_impl(self, kind: KindUnion) -> tuple[str, None]:
        match kind:
            case "billing_info":
                has_access = await self._context_manager.check_user_has_billing_access()
                if not has_access:
                    raise MaxToolFatalError(BILLING_INSUFFICIENT_ACCESS_PROMPT)
                # used for routing
                billing_tool = ReadBillingTool(
                    team=self._team,
                    user=self._user,
                    state=self._state,
                    config=self._config,
                    context_manager=self._context_manager,
                )
                result = await billing_tool.execute()
                return result, None
            case "datawarehouse_schema":
                return await self._serialize_database_schema(), None
            case "artifacts":
                conversation_artifacts = await self._context_manager.artifacts.aget_conversation_artifact_messages()
                return self._format_artifacts(conversation_artifacts), None

    def _format_artifacts(self, artifact_message: list[ArtifactMessage]) -> str:
        formatted_artifacts = []
        for message in artifact_message:
            viz_content = unwrap_visualization_artifact_content(message)
            if viz_content:
                formatted_artifacts.append(
                    f"- id: {message.artifact_id}\n- name: {viz_content.name}\n- description: {viz_content.description}\n- query: {viz_content.query}"
                )
        if len(formatted_artifacts) == 0:
            return "No artifacts available"
        return "\n\n".join(formatted_artifacts)
