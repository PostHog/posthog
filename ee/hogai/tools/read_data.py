from typing import Literal, Self, Union
from uuid import uuid4

from langchain_core.runnables import RunnableConfig
from pydantic import BaseModel, Field, create_model

from posthog.schema import ArtifactContentType, AssistantToolCallMessage

from posthog.hogql.context import HogQLContext
from posthog.hogql.database.database import Database

from posthog.models import Team, User
from posthog.sync import database_sync_to_async

from ee.hogai.artifacts.utils import unwrap_visualization_artifact_content
from ee.hogai.chat_agent.query_executor.query_executor import execute_and_format_query
from ee.hogai.chat_agent.sql.mixins import HogQLDatabaseMixin
from ee.hogai.context.context import AssistantContextManager
from ee.hogai.tool import MaxTool, ToolMessagesArtifact
from ee.hogai.tool_errors import MaxToolFatalError, MaxToolRetryableError
from ee.hogai.tools.read_billing_tool.tool import ReadBillingTool
from ee.hogai.utils.prompt import format_prompt_string
from ee.hogai.utils.types.base import ArtifactRefMessage, AssistantState, NodePath

READ_DATA_BILLING_PROMPT = """
# Billing information

Use this tool with the "billing_info" kind to retrieve the billing information if the user asks about their billing, subscription, product usage, spending, or cost reduction strategies.
You can use the information retrieved to check which PostHog products and add-ons the user has activated, how much they are spending, their usage history across all products in the last 30 days, as well as trials, spending limits, billing period, and more.
If the user wants to reduce their spending, always call this tool to get suggestions on how to do so.
If an insight shows zero data, it could mean either the query is looking at the wrong data or there was a temporary data collection issue. You can investigate potential dips in usage/captured data using the billing tool.
""".strip()

READ_DATA_ARTIFACTS_PROMPT = """
# Artifacts

Returns the list of artifacts generated in the current conversation, including the ones generated by subagent tasks. Supported artifacts:
- Data visualizations: any new visualization generated when creating an insight or running a SQL query. Does not include insights created by the user, which can be found using the search tool.
""".strip()

READ_DATA_PROMPT = """
Use this tool to read user data created in PostHog. This tool returns data that the user manually creates in PostHog.

# Data warehouse schema

Read the SQL ClickHouse schema (tables, views, and columns) for the user's data.

## Available operations:
- `data_warehouse_schema`: Returns core PostHog tables (events, groups, persons, sessions) with their full schemas, plus a list of available data warehouse tables and views (names only). Use this first to see what data is available.
- `data_warehouse_table`: Returns the full schema for a specific data warehouse table or view. Use this after `data_warehouse_schema` to get details on specific tables you need.

You MUST use this tool when:
- Working with SQL.
- The request is about data warehouse, connected data sources, etc.

Workflow:
1. Start with `data_warehouse_schema` to see available tables
2. Use `data_warehouse_table` with a specific `table_name` to get schema details for warehouse tables you need

# Insight

Retrieves and optionally queries data for an existing insight by its ID.

## Use this when:
- You have an insight ID and want to retrieve the data for that insight or read the insight schema.
- The user wants to see or discuss a specific saved insight.
- You need to understand what an existing insight shows.

{{{artifacts_prompt}}}
{{{billing_prompt}}}
""".strip()

BILLING_INSUFFICIENT_ACCESS_PROMPT = """
The user does not have admin access to view detailed billing information. They would need to contact an organization admin for billing details.
Suggest the user to contact the admins.
""".strip()

READ_DATA_WAREHOUSE_SCHEMA_PROMPT = """
# Core PostHog tables
{{{posthog_tables}}}
{{#data_warehouse_tables}}

# Data warehouse tables
{{{data_warehouse_tables}}}
{{/data_warehouse_tables}}
{{#data_warehouse_views}}

# Data warehouse views
{{{data_warehouse_views}}}
{{/data_warehouse_views}}

<system_reminder>
Use the `read_data` tool with the `data_warehouse_table` kind to get column and relationship details for a specific table.
</system_reminder>
""".strip()

INSIGHT_NOT_FOUND_PROMPT = """
The insight with the ID "{short_id}" was not found or uses an unsupported query type. Please verify the insight ID is correct.
""".strip()

INSIGHT_RESULT_TEMPLATE = """
Name: {{{insight_name}}}
Insight ID: {{{insight_id}}}
{{#description}}
Description: {{{description}}}
{{/description}}

{{{results}}}
""".strip()

INSIGHT_SCHEMA_TEMPLATE = """
Name: {{{insight_name}}}
Insight ID: {{{insight_id}}}
{{#description}}
Description: {{{description}}}
{{/description}}

Query definition:
```json
{{{query_schema}}}
```
""".strip()


class ReadDataWarehouseSchema(BaseModel):
    """Returns core PostHog tables (events, groups, persons, sessions) with their full schemas, plus a list of available data warehouse tables and views (names only)."""

    kind: Literal["data_warehouse_schema"] = "data_warehouse_schema"


class ReadDataWarehouseTableSchema(BaseModel):
    """Returns the full schema with columns for a specific data warehouse table or view."""

    kind: Literal["data_warehouse_table"] = "data_warehouse_table"
    table_name: str = Field(description="The name of the table to read the schema for.")


class ReadInsight(BaseModel):
    """Retrieves an existing saved insight by its short ID."""

    kind: Literal["insight"] = "insight"
    insight_id: str = Field(description="The short ID of the insight (found in URLs like /insights/abc123).")
    execute: bool = Field(
        default=False,
        description="If true, executes the insight query and returns results. If false, returns only the insight definition.",
    )


class ReadBillingInfo(BaseModel):
    """Retrieves billing information for the organization."""

    kind: Literal["billing_info"] = "billing_info"


class ReadArtifacts(BaseModel):
    """Reads conversation artifacts created by the agent."""

    kind: Literal["artifacts"] = "artifacts"


ReadDataQuery = ReadDataWarehouseSchema | ReadDataWarehouseTableSchema | ReadInsight | ReadBillingInfo | ReadArtifacts


class _InternalReadDataToolArgs(BaseModel):
    query: ReadDataQuery = Field(..., discriminator="kind")


class ReadDataTool(HogQLDatabaseMixin, MaxTool):
    name: Literal["read_data"] = "read_data"
    description: str = READ_DATA_PROMPT
    context_prompt_template: str = (
        "Reads user data created in PostHog (data warehouse schema, saved insights, billing information)"
    )

    @classmethod
    async def create_tool_class(
        cls,
        *,
        team: Team,
        user: User,
        node_path: tuple[NodePath, ...] | None = None,
        state: AssistantState | None = None,
        config: RunnableConfig | None = None,
        context_manager: AssistantContextManager | None = None,
        can_read_artifacts: bool = False,
    ) -> Self:
        """
        Factory that creates a ReadDataTool with a dynamic args schema.

        Override this factory to add additional args schemas or descriptions.
        """
        kinds: list[type[BaseModel]] = []
        prompt_vars: dict[str, str] = {}

        if not context_manager:
            context_manager = AssistantContextManager(team, user, config)

        has_billing_access = await context_manager.check_user_has_billing_access()

        # Subagents don't have access to artifacts
        if can_read_artifacts:
            prompt_vars["artifacts_prompt"] = READ_DATA_ARTIFACTS_PROMPT
            kinds.append(ReadArtifacts)
        if has_billing_access:
            prompt_vars["billing_prompt"] = READ_DATA_BILLING_PROMPT
            kinds.append(ReadBillingInfo)

        ReadDataKind = Union[ReadDataWarehouseSchema, ReadDataWarehouseTableSchema, ReadInsight, *kinds]  # type: ignore

        ReadDataToolArgs = create_model(
            "ReadDataToolArgs",
            __base__=BaseModel,
            query=(
                ReadDataKind,
                Field(discriminator="kind"),
            ),
        )

        description = format_prompt_string(READ_DATA_PROMPT, template_format="mustache", **prompt_vars).strip()

        return cls(
            team=team,
            user=user,
            state=state,
            node_path=node_path,
            config=config,
            args_schema=ReadDataToolArgs,
            description=description,
            context_manager=context_manager,
        )

    async def _arun_impl(self, query: dict) -> tuple[str, ToolMessagesArtifact | None]:
        validated_query = _InternalReadDataToolArgs(query=query).query
        match validated_query:
            case ReadBillingInfo():
                has_access = await self._context_manager.check_user_has_billing_access()
                if not has_access:
                    raise MaxToolFatalError(BILLING_INSUFFICIENT_ACCESS_PROMPT)
                billing_tool = ReadBillingTool(
                    team=self._team,
                    user=self._user,
                    state=self._state,
                    config=self._config,
                    context_manager=self._context_manager,
                )
                result = await billing_tool.execute()
                return result, None
            case ReadDataWarehouseSchema():
                return await self._read_data_warehouse_schema(), None
            case ReadDataWarehouseTableSchema() as data_warehouse_table:
                return await self._read_data_warehouse_table_schema(data_warehouse_table.table_name), None
            case ReadArtifacts():
                return await self._read_artifacts()
            case ReadInsight() as schema:
                return await self._read_insight(schema.insight_id, schema.execute)

    async def _read_insight(
        self, artifact_or_insight_id: str, execute: bool
    ) -> tuple[str, ToolMessagesArtifact | None]:
        # Fetch the artifact content along with its source
        result = await self._context_manager.artifacts.aget_insight_with_source(
            self._state.messages, artifact_or_insight_id
        )

        if result is None:
            raise MaxToolRetryableError(INSIGHT_NOT_FOUND_PROMPT.format(short_id=artifact_or_insight_id))

        content, source = result
        query_type = content.query.kind
        insight_name = content.name or f"Insight {artifact_or_insight_id}"

        # The agent wants to read the schema, just return it
        if not execute:
            query_schema = content.query.model_dump_json(exclude_none=True)
            text_result = format_prompt_string(
                INSIGHT_SCHEMA_TEMPLATE,
                insight_name=insight_name,
                insight_id=artifact_or_insight_id,
                description=content.description,
                query_type=query_type,
                query_schema=query_schema,
            )
            return text_result, None

        # Create a new artifact message, so the user can see the results in the UI
        artifact_message = ArtifactRefMessage(
            content_type=ArtifactContentType.VISUALIZATION,
            artifact_id=artifact_or_insight_id,
            source=source,
            id=str(uuid4()),
        )

        # Execute the query and return the results
        results = await execute_and_format_query(self._team, content.query)
        text_result = format_prompt_string(
            INSIGHT_RESULT_TEMPLATE,
            insight_name=insight_name,
            insight_id=artifact_or_insight_id,
            description=content.description,
            query_type=query_type,
            results=results,
        )
        tool_call_message = AssistantToolCallMessage(
            content=text_result,
            id=str(uuid4()),
            tool_call_id=self.tool_call_id,
        )

        return "", ToolMessagesArtifact(messages=[artifact_message, tool_call_message])

    async def _read_artifacts(self) -> tuple[str, None]:
        conversation_artifacts = await self._context_manager.artifacts.aget_conversation_artifact_messages()
        formatted_artifacts = []

        for message in conversation_artifacts:
            viz_content = unwrap_visualization_artifact_content(message)
            if viz_content:
                formatted_artifacts.append(
                    f"- id: {message.artifact_id}\n- name: {viz_content.name}\n- description: {viz_content.description}\n- query: {viz_content.query}"
                )
        if len(formatted_artifacts) == 0:
            return "No artifacts available", None
        return "\n\n".join(formatted_artifacts), None

    async def _read_data_warehouse_schema(self) -> str:
        database = await self._aget_database()
        hogql_context = self._get_default_hogql_context(database)
        return await self._build_tables_list(database, hogql_context)

    async def _read_data_warehouse_table_schema(self, table_name: str) -> str:
        database = await self._aget_database()
        hogql_context = self._get_default_hogql_context(database)
        return await self._build_table_schema(database, hogql_context, table_name)

    @database_sync_to_async
    def _build_tables_list(self, database: Database, hogql_context: HogQLContext) -> str:
        core_tables = {"events", "groups", "persons", "sessions"}
        serialized = database.serialize(hogql_context, include_only=core_tables)

        system_table_lines: list[str] = []
        for table_name, table in serialized.items():
            system_table_lines.append(f"## Table `{table_name}`")
            for field in table.fields.values():
                system_table_lines.append(f"- {field.name} ({field.type})")
            system_table_lines.append("")

        warehouse_tables = database.get_warehouse_table_names()
        views = database.get_view_names()

        listify = lambda items: "\n".join(f"- {item}" for item in sorted(items))

        return format_prompt_string(
            READ_DATA_WAREHOUSE_SCHEMA_PROMPT,
            template_format="mustache",
            posthog_tables="\n".join(system_table_lines),
            data_warehouse_tables=listify(warehouse_tables),
            data_warehouse_views=listify(views),
        )

    @database_sync_to_async
    def _build_table_schema(self, database: Database, hogql_context: HogQLContext, table_name: str) -> str:
        # Load tables on demand: warehouse first, then views, then posthog tables
        table_sources = [
            database.get_warehouse_table_names,
            database.get_view_names,
            database.get_posthog_table_names,
        ]

        table_found = False
        all_tables: list[str] = []
        for get_tables in table_sources:
            tables = get_tables()
            if table_name in tables:
                table_found = True
                break
            all_tables.extend(tables)

        if not table_found:
            available = ", ".join(sorted(all_tables)[:20])
            return f"Table `{table_name}` not found. Available tables include: {available}..."

        serialized = database.serialize(hogql_context, include_only={table_name})

        if table_name not in serialized:
            return f"Could not serialize schema for table `{table_name}`."

        table = serialized[table_name]
        lines = [f"Table `{table_name}` with fields:"]
        for field in table.fields.values():
            lines.append(f"- {field.name} ({field.type})")

        return "\n".join(lines)
