#!/bin/bash

set -e

export REPOSITORY_ROOT=$(realpath "$(dirname "$0")/..")
export LOCK_FILE="$REPOSITORY_ROOT/bin/start.lock"

# Acquire exclusive lock using flock (atomic, no race condition)
exec 9>"$LOCK_FILE"
if ! flock -n 9; then
    echo "âš ï¸  Another instance of bin/start is already running (lock file: $LOCK_FILE)"
    echo "   To skip this check, delete the lock file: rm $LOCK_FILE"
    exit 1
fi

# 1Password: auto-resolve op:// references in .env.local
if [ -f "$REPOSITORY_ROOT/.env.local" ] && grep -q "op://" "$REPOSITORY_ROOT/.env.local" 2>/dev/null; then
    if [ -z "$_POSTHOG_OP_RESOLVED" ]; then
        if command -v op &>/dev/null; then
            echo "ðŸ” Resolving secrets from .env.local via 1Password"
            export _POSTHOG_OP_RESOLVED=1
            exec op run --env-file="$REPOSITORY_ROOT/.env.local" -- "$0" "$@"
        else
            echo "âš ï¸  .env.local contains 1Password refs (op://) but 'op' CLI not found"
            echo "   Install: brew install 1password-cli"
        fi
    fi
fi

# Source env files respecting precedence: shell env > .env.local > .env.development
# Only set vars that aren't already in the environment
source_env_defaults() {
    while IFS='=' read -r name value; do
        [[ -z "$name" || "$name" == \#* ]] && continue
        [[ -z "${!name:-}" ]] && export "$name=$value"
    done < "$1"
}
# .env.local: already in env if processed by op run, otherwise source directly
if [[ -f "$REPOSITORY_ROOT/.env.local" ]] && [[ -z "$_POSTHOG_OP_RESOLVED" ]]; then
    source_env_defaults "$REPOSITORY_ROOT/.env.local"
fi
source_env_defaults "$REPOSITORY_ROOT/.env.development"

# Enforce 1Password for sensitive vars
# Check: if a secret var is set, it must have an op:// ref in .env.local
if [[ -f "$REPOSITORY_ROOT/.env.secrets" ]]; then
    exposed_secrets=()
    while IFS='=' read -r name _; do
        [[ -z "$name" || "$name" == \#* ]] && continue
        # Is this secret var set in the environment?
        if [[ -n "${!name:-}" ]]; then
            # Check if .env.local has an op:// reference for it
            if ! grep -qE "^${name}=op://" "$REPOSITORY_ROOT/.env.local" 2>/dev/null; then
                exposed_secrets+=("$name")
            fi
        fi
    done < "$REPOSITORY_ROOT/.env.secrets"

    if [[ ${#exposed_secrets[@]} -gt 0 ]]; then
        echo "ðŸš¨ Secrets detected without 1Password:"
        printf '   %s\n' "${exposed_secrets[@]}"
        echo ""
        echo "These vars are listed in .env.secrets and must come from 1Password."
        echo "Create .env.local with op:// references, e.g.:"
        echo "   OPENAI_API_KEY=op://Private/OpenAI/api-key"
        exit 1
    fi
fi

# Rust build optimizations (dynamic, can't be in .env.development)
export CARGO_BUILD_JOBS="${CARGO_BUILD_JOBS:-1}"

# Use sccache for Rust compilation caching (if available via flox or homebrew)
if [[ -z "${RUSTC_WRAPPER:-}" ]] && command -v sccache &>/dev/null; then
    export RUSTC_WRAPPER="sccache"
fi

# Use lld linker on macOS for faster Rust linking (if available via flox or homebrew)
if [[ "$(uname -s)" == "Darwin" ]] && [[ -z "${CARGO_TARGET_AARCH64_APPLE_DARWIN_RUSTFLAGS:-}" ]] && command -v lld &>/dev/null; then
    export CARGO_TARGET_AARCH64_APPLE_DARWIN_RUSTFLAGS="-C link-arg=-fuse-ld=lld"
fi

# Computed vars (need REPOSITORY_ROOT)
export DAGSTER_HOME=$REPOSITORY_ROOT/.dagster_home

# Tracing is disabled by default - requires 'tracing' intent for Jaeger/otel-collector
# Note: otel-collector uses significant CPU/memory resources
# Use --tracing flag to enable if you have the intent configured
if [[ "$*" == *"--tracing"* ]]; then
    export OTEL_SDK_DISABLED="false"
    echo "ðŸ‘‰ Tracing enabled, see http://localhost:16686 for Jaeger UI"
else
    export OTEL_SDK_DISABLED="true"
fi

if ! python3 - <<'PY' >/dev/null 2>&1
import duckdb  # noqa: F401
PY
then
    echo "DuckLake requires the duckdb Python package."
    echo "Run 'uv sync --active' (or activate Flox) before executing hogli start."
    exit 1
fi

# Geo files
./bin/download-mmdb

if ! command -v mprocs &>/dev/null; then
    if command -v brew &>/dev/null; then
        echo "ðŸ” Installing mprocs via Homebrew..."
        brew install mprocs
    else
        echo "ðŸ‘‰ To run bin/start, install mprocs: https://github.com/pvolok/mprocs#installation"
        exit 1
    fi
fi

# Advertise intent-based dev environment
echo ""
echo "ðŸ’¡ New: 'hogli dev:setup' lets you configure which services to start"
echo ""

# Use custom config, if provided (e.g. bin/start --custom bin/mprocs-custom.yaml)
# Ensure to provide config path after --custom flag
if [[ "$*" == *"--custom"* ]]; then
    # Extract the path after --custom
    config_path=""
    found_custom=false
    for i in "$@"; do
        if [[ $found_custom == true ]]; then
            config_path="$i"
            break
        fi
        if [[ "$i" == "--custom" ]]; then
            found_custom=true
        fi
    done
    if [[ -z "$config_path" ]]; then
        echo "Error: --custom requires a config path"
        exit 1
    fi
    exec mprocs --config "$config_path"
else
    GENERATED_CONFIG="$REPOSITORY_ROOT/.posthog/.generated/mprocs.yaml"

    # Generate/regenerate config using hogli (defaults to product_analytics if no config exists)
    if command -v hogli &>/dev/null; then
        hogli dev:generate 2>/dev/null || true
    fi

    if [[ -f "$GENERATED_CONFIG" ]]; then
        exec mprocs --config "$GENERATED_CONFIG"
    else
        # Fallback if hogli not available
        exec mprocs --config bin/mprocs.yaml
    fi
fi
