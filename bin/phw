#!/bin/bash
# PostHog Worktree wrapper function installer
# Source this file in your shell profile to use the phw function

# Get the directory of this script when being sourced
_phw_script_dir=""
if [ -n "${BASH_SOURCE[0]:-}" ]; then
    _phw_script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
elif [ -n "${ZSH_VERSION:-}" ]; then
    _phw_script_dir="$(cd "$(dirname "$0")" && pwd)"
fi

phw() {
    local script_path="${_phw_script_dir}/posthog-worktree"
    local command="$1"
    local branch="$2"
    
    # Handle switch command directly (doesn't need main script)
    if [[ "$command" == "switch" ]]; then
        if [[ -z "$branch" ]]; then
            echo "Usage: phw switch <branch-name>"
            return 1
        fi
        
        # Find existing worktree path using git worktree list
        local worktree_path=$(git worktree list | grep -E "\[${branch}\]$" | awk '{print $1}')
        
        if [[ -z "$worktree_path" ]]; then
            echo "Error: No worktree found for branch '$branch'"
            echo "Available worktrees:"
            git worktree list
            return 1
        fi
        
        if [[ ! -d "$worktree_path" ]]; then
            echo "Error: Worktree directory does not exist: $worktree_path"
            return 1
        fi
        
        echo "Switching to worktree: $branch"
        echo "Location: $worktree_path"
        
        # Add to shell history for convenience
        if command -v history >/dev/null 2>&1; then
            history -s "cd \"$worktree_path\""
        fi
        
        # Clean environment variables before entering worktree
        unset VIRTUAL_ENV PYTHONPATH CONDA_DEFAULT_ENV 2>/dev/null || true
        cd "$worktree_path"
        return 0
    fi
    
    # Run the actual script for other commands
    "$script_path" "$@"
    
    # If creating, checking out, or starting, cd to the worktree
    if [[ "$command" == "create" || "$command" == "checkout" || "$command" == "start" ]] && [[ -n "$branch" ]]; then
        local worktree_base="${POSTHOG_WORKTREE_BASE:-$HOME/.worktrees/posthog}"
        local worktree_path="$worktree_base/$branch"
        if [[ -d "$worktree_path" ]]; then
            echo "Switching to worktree directory..."
            # Clean environment variables before entering worktree to prevent Flox warnings
            unset VIRTUAL_ENV PYTHONPATH CONDA_DEFAULT_ENV 2>/dev/null || true
            cd "$worktree_path"
            
            # If direnv is not set up, activate Flox via .envrc
            if ! command -v direnv &>/dev/null; then
                echo "Activating Flox environment via .envrc..."
                source .envrc
            fi
            # If direnv is set up, it will auto-activate via .envrc
        fi
    elif [[ "$command" == "pr" ]] && [[ -n "$branch" ]]; then
        # For PR, the directory name is different (pr-NUMBER-author)
        local worktree_base="${POSTHOG_WORKTREE_BASE:-$HOME/.worktrees/posthog}"
        local pr_dir=$(ls -d "$worktree_base/pr-${branch}-"* 2>/dev/null | head -n1)
        if [[ -d "$pr_dir" ]]; then
            echo "Switching to PR worktree directory..."
            # Clean environment variables before entering worktree to prevent Flox warnings
            unset VIRTUAL_ENV PYTHONPATH CONDA_DEFAULT_ENV 2>/dev/null || true
            cd "$pr_dir"
            
            # If direnv is not set up, activate Flox via .envrc
            if ! command -v direnv &>/dev/null; then
                echo "Activating Flox environment via .envrc..."
                source .envrc
            fi
        fi
    fi
}

# Add completion support for bash and zsh
if [ -n "$BASH_VERSION" ]; then
    _phw_completions() {
        local cur="${COMP_WORDS[COMP_CWORD]}"
        local prev="${COMP_WORDS[COMP_CWORD-1]}"
        
        if [[ $COMP_CWORD -eq 1 ]]; then
            COMPREPLY=($(compgen -W "create checkout pr remove list switch" -- "$cur"))
        elif [[ $COMP_CWORD -eq 2 ]]; then
            case "$prev" in
                remove|switch)
                    # Complete with existing worktree branch names
                    local worktrees=$(git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p' | grep -v '^$')
                    COMPREPLY=($(compgen -W "$worktrees" -- "$cur"))
                    ;;
                checkout)
                    # Complete with branch names
                    local branches=$(git branch -a 2>/dev/null | grep -v HEAD | sed 's/^[* ]*//' | sed 's/remotes\/origin\///' | sort -u)
                    COMPREPLY=($(compgen -W "$branches" -- "$cur"))
                    ;;
                pr)
                    # No completion for PR numbers
                    ;;
                create)
                    # Suggest branch name format
                    COMPREPLY=($(compgen -W "haacked/" -- "$cur"))
                    ;;
            esac
        fi
    }
    complete -F _phw_completions phw
elif [ -n "$ZSH_VERSION" ]; then
    # Advanced zsh completion function
    _phw_complete() {
        local -a commands
        local context state line
        
        commands=(
            'create:Create a new worktree for a branch'
            'checkout:Checkout existing branch in a worktree'  
            'pr:Checkout a PR in a worktree'
            'remove:Remove a worktree'
            'list:List all worktrees'
            'switch:Switch to existing worktree'
        )
        
        case $CURRENT in
            2)
                _describe 'commands' commands
                ;;
            3)
                case $words[2] in
                    remove|switch)
                        # Complete with existing worktree branch names
                        local -a worktrees
                        worktrees=($(git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p' | grep -v '^$' 2>/dev/null))
                        if [[ ${#worktrees[@]} -gt 0 ]]; then
                            _describe 'worktrees' worktrees
                        fi
                        ;;
                    checkout)
                        # Complete with branch names
                        local -a branches
                        branches=($(git branch -a 2>/dev/null | grep -v HEAD | sed 's/^[* ]*//' | sed 's/remotes\/origin\///' | sort -u 2>/dev/null))
                        if [[ ${#branches[@]} -gt 0 ]]; then
                            _describe 'branches' branches
                        fi
                        ;;
                esac
                ;;
        esac
    }
    
    # Use compdef to register the completion function
    if command -v compdef >/dev/null 2>&1; then
        compdef _phw_complete phw
    else
        # Fallback to simple completion if compdef not available
        compctl -k '(create checkout pr remove list)' phw
    fi
fi

echo "PostHog worktree helper loaded. Use 'phw' command."