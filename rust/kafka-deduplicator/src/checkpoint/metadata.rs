use super::{CheckpointMode, CheckpointTarget};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use tracing::info;

/// Type of checkpoint
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum CheckpointType {
    /// Full checkpoint containing all current state
    Full,
    /// Partial checkpoint containing only changes since last checkpoint
    Partial,
}

impl From<CheckpointMode> for CheckpointType {
    fn from(mode: CheckpointMode) -> Self {
        match mode {
            CheckpointMode::Full => CheckpointType::Full,
            CheckpointMode::Incremental => CheckpointType::Partial,
        }
    }
}

/// Information about a checkpoint file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckpointFile {
    /// Path relative to checkpoint root
    pub path: String,
    /// Size of file in bytes
    pub size_bytes: u64,
    /// SHA256 hash of file contents
    pub checksum: Option<String>,
}

/// Metadata about a checkpoint
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckpointMetadata {
    /// Type of checkpoint
    pub checkpoint_type: CheckpointType,
    /// checkpoint attempt's coordinates: source topic, partition, and timestamp (UNIX micros)
    /// with convenience methods for constructing remote and local paths from this information
    pub target: CheckpointTarget,
    /// Consumer offset at time of checkpoint
    pub consumer_offset: i64,
    /// Producer offset at time of checkpoint
    pub producer_offset: i64,
    /// List of files in this checkpoint
    pub files: Vec<CheckpointFile>,
    /// Timestamp of previous checkpoint if this is a partial checkpoint
    pub previous_checkpoint: Option<i64>,
    /// Total size of all files in bytes
    pub total_size_bytes: u64,
    /// Number of keys in the checkpoint
    pub key_count: u64,
}

impl CheckpointMetadata {
    /// Create new checkpoint metadata
    pub fn new(
        checkpoint_type: CheckpointType,
        target: CheckpointTarget,
        consumer_offset: i64,
        producer_offset: i64,
        key_count: u64,
    ) -> Self {
        Self {
            checkpoint_type,
            target,
            consumer_offset,
            producer_offset,
            files: Vec::new(),
            previous_checkpoint: None,
            total_size_bytes: 0,
            key_count,
        }
    }

    // Deserialize a CheckpointMetadata object from a JSON payload of bytes
    pub fn from_payload(payload: &[u8]) -> Result<Self> {
        let metadata: Self = serde_json::from_slice(payload)
            .context("Failed to deserialize CheckpointMetadata from remote payload")?;
        Ok(metadata)
    }

    /// Given stringified local full paths to the SST files generated by the current snapshot attempt,
    /// add it to the CheckpointMetadata after stripping location-specific path prefix
    pub async fn add_files(&mut self, sst_files: &[String]) -> Result<()> {
        let local_attempt_path = self.target.local_attempt_path().context("In add_file")?;
        let local_attempt_path_str = local_attempt_path.to_string_lossy().to_string();

        for sst_file in sst_files {
            // ensure saved SST files are only prefixed by directories and filenames
            // that we can join onto local and remote paths resolved by CheckpointTarget
            // during future import or export operations. Example:
            // before: /var/lib/deduper/checkpoints/topic_sometopic/part_1/00000123451234567890/sst/000001.sst
            // after: sst/000001.sst
            let cleansed_file_path = sst_file
                .strip_prefix(&local_attempt_path_str)
                .unwrap_or(sst_file)
                .trim_start_matches('/')
                .to_string();

            // obtain file size for metadata tracking from checkpointed SST file location
            let local_checkpointed_sst_file_path = local_attempt_path.join(&cleansed_file_path);
            let file_size = tokio::fs::metadata(&local_checkpointed_sst_file_path)
                .await
                .context("Failed file size check on {sst_file} in add_file")?
                .len() as u64;

            // TODO: perform checksum on the sst_file contents and add to CheckpointFile

            self.total_size_bytes += file_size;
            self.files.push(CheckpointFile {
                path: cleansed_file_path,
                size_bytes: file_size,
                checksum: None,
            });
        }

        Ok(())
    }

    /// Save metadata to a JSON file in local checkpoint attempt directory
    /// structure (as tracked by the CheckpointTarget) prior to remote export
    pub async fn save_to_file(&self) -> Result<()> {
        let json = serde_json::to_string_pretty(self)
            .context("Failed to serialize checkpoint metadata")?;

        tokio::fs::create_dir_all(self.target.local_metadata_path())
            .await
            .context("Failed to create local metadata directory")?;

        let path = self
            .target
            .local_metadata_file()
            .context("In save_to_local_file")?;

        tokio::fs::write(&path, json).await?;
        info!("Saved checkpoint metadata to local path: {:?}", path);

        Ok(())
    }

    /// Hydrate a CheckpointMetadata object from a JSON file, using the
    /// given CheckpointTarget to determine the local path to the metadata file
    pub async fn load_from_file(target: &CheckpointTarget) -> Result<Self> {
        let local_path = target.local_metadata_file().context("In load_from_file")?;
        let json = tokio::fs::read_to_string(local_path).await?;
        let metadata: Self = serde_json::from_str(&json)?;
        Ok(metadata)
    }
}

#[cfg(test)]
mod tests {
    use std::io::Write;
    use std::path::Path;
    use std::time::SystemTime;

    use super::*;
    use crate::kafka::types::Partition;

    use tempfile::TempDir;

    fn fill_file_with_data(path: &Path, size: u64) {
        std::fs::create_dir_all(path.parent().unwrap()).unwrap();
        let mut file = std::fs::File::create(path).unwrap();
        let data = b"A".repeat(size as usize);
        file.write_all(&data).unwrap();
    }

    #[tokio::test]
    async fn test_checkpoint_metadata_creation() {
        let local_base_path = TempDir::new().unwrap();
        let partition = Partition::new("test-topic".to_string(), 0);
        let checkpoint_target =
            CheckpointTarget::new(partition, Some(SystemTime::now()), local_base_path.path());
        let metadata =
            CheckpointMetadata::new(CheckpointType::Full, checkpoint_target, 100, 50, 1000);

        assert_eq!(metadata.target.partition.topic(), "test-topic");
        assert_eq!(metadata.target.partition.partition_number(), 0);
        assert_eq!(metadata.checkpoint_type, CheckpointType::Full);
        assert_eq!(metadata.consumer_offset, 100);
        assert_eq!(metadata.producer_offset, 50);
        assert_eq!(metadata.key_count, 1000);
        assert_eq!(metadata.files.len(), 0);
        assert_eq!(metadata.total_size_bytes, 0);
    }

    #[tokio::test]
    async fn test_add_file_to_metadata() {
        let local_base_path = TempDir::new().unwrap();
        let partition = Partition::new("test-topic".to_string(), 0);
        let checkpoint_target =
            CheckpointTarget::new(partition, Some(SystemTime::now()), local_base_path.path());

        let mut metadata = CheckpointMetadata::new(
            CheckpointType::Full,
            checkpoint_target.clone(),
            100,
            50,
            1000,
        );

        let local_attempt_path = checkpoint_target.local_attempt_path().unwrap();
        let sst1_local_path = local_attempt_path.join("sst/000001.sst");
        fill_file_with_data(&sst1_local_path, 1024);
        let sst2_local_path = local_attempt_path.join("sst/000002.sst");
        fill_file_with_data(&sst2_local_path, 2048);

        metadata
            .add_files(&[
                sst1_local_path.to_string_lossy().to_string(),
                sst2_local_path.to_string_lossy().to_string(),
            ])
            .await
            .unwrap();

        let expected_sst1_path = "sst/000001.sst";
        let expected_sst2_path = "sst/000002.sst";

        assert_eq!(metadata.files.len(), 2);
        assert_eq!(metadata.total_size_bytes, 3072);
        assert_eq!(metadata.files[0].path, expected_sst1_path);
        assert_eq!(metadata.files[1].path, expected_sst2_path);
        assert_eq!(metadata.files[0].size_bytes, 1024);
        assert_eq!(metadata.files[1].size_bytes, 2048);
        assert!(metadata.files[0].checksum.is_none());
        assert!(metadata.files[1].checksum.is_none());
    }

    #[tokio::test]
    async fn test_save_and_load_metadata() {
        let local_base_path = TempDir::new().unwrap();
        let partition = Partition::new("test-topic".to_string(), 0);
        let target =
            CheckpointTarget::new(partition, Some(SystemTime::now()), local_base_path.path());

        let mut metadata =
            CheckpointMetadata::new(CheckpointType::Partial, target.clone(), 200, 150, 2000);
        metadata.previous_checkpoint = Some(1000);

        let local_attempt_path = target.local_attempt_path().unwrap();
        let sst1_local_path = local_attempt_path.join("sst/000001.sst");
        fill_file_with_data(&sst1_local_path, 1024);
        let sst2_local_path = local_attempt_path.join("sst/000002.sst");
        fill_file_with_data(&sst2_local_path, 2048);

        metadata
            .add_files(&[
                sst1_local_path.to_string_lossy().to_string(),
                sst2_local_path.to_string_lossy().to_string(),
            ])
            .await
            .unwrap();

        let expected_sst1_path = "sst/000001.sst";
        let expected_sst2_path = "sst/000002.sst";

        assert_eq!(metadata.files.len(), 2);
        assert_eq!(metadata.total_size_bytes, 3072);
        assert_eq!(metadata.files[0].path, expected_sst1_path);
        assert_eq!(metadata.files[1].path, expected_sst2_path);
        assert_eq!(metadata.files[0].size_bytes, 1024);
        assert_eq!(metadata.files[1].size_bytes, 2048);
        assert!(metadata.files[0].checksum.is_none());
        assert!(metadata.files[1].checksum.is_none());

        // Save metadata
        metadata.save_to_file().await.unwrap();

        // Load metadata
        let loaded_metadata = CheckpointMetadata::load_from_file(&metadata.target)
            .await
            .unwrap();

        assert_eq!(
            loaded_metadata.target.partition.topic(),
            metadata.target.partition.topic()
        );
        assert_eq!(
            loaded_metadata.target.partition.partition_number(),
            metadata.target.partition.partition_number()
        );
        assert_eq!(loaded_metadata.checkpoint_type, CheckpointType::Partial);
        assert_eq!(loaded_metadata.consumer_offset, metadata.consumer_offset);
        assert_eq!(loaded_metadata.producer_offset, metadata.producer_offset);
        assert_eq!(loaded_metadata.key_count, metadata.key_count);
        assert_eq!(loaded_metadata.files.len(), 2);
        assert_eq!(loaded_metadata.files[0].path, "sst/000001.sst");
        assert_eq!(loaded_metadata.files[1].path, "sst/000002.sst");
        assert_eq!(loaded_metadata.files[0].size_bytes, 1024);
        assert_eq!(loaded_metadata.files[1].size_bytes, 2048);
        assert!(loaded_metadata.files[0].checksum.is_none());
        assert!(loaded_metadata.files[1].checksum.is_none());
        assert_eq!(loaded_metadata.previous_checkpoint, Some(1000));
    }

    #[test]
    fn test_s3_key_prefix() {
        let local_base_path = TempDir::new().unwrap();
        let partition = Partition::new("test-topic".to_string(), 2);
        let attempt_timestamp = SystemTime::now();
        let target =
            CheckpointTarget::new(partition, Some(attempt_timestamp), local_base_path.path());
        let metadata = CheckpointMetadata::new(CheckpointType::Full, target.clone(), 100, 50, 1000);

        let expected_remote_path = target.remote_attempt_path().unwrap();
        let s3_key_prefix = metadata.target.remote_attempt_path().unwrap();
        assert_eq!(&s3_key_prefix, &expected_remote_path);
        // remote path includes: namespace_label/topic_elem/partition_elem/timestamp_elem
        assert_eq!(s3_key_prefix.split('/').count(), 4);
    }

    #[test]
    fn test_checkpoint_metadata_remote() {
        let local_base_path = TempDir::new().unwrap();
        let partition = Partition::new("test-topic".to_string(), 0);
        let attempt_timestamp = SystemTime::now();
        let checkpoint_target =
            CheckpointTarget::new(partition, Some(attempt_timestamp), local_base_path.path());

        let metadata = CheckpointMetadata::new(
            CheckpointType::Full,
            checkpoint_target.clone(),
            100,
            50,
            1000,
        );

        let expected_remote_metadata_path = "checkpoints/topic_test-topic/part_0/metadata";
        assert_eq!(
            &metadata.target.remote_metadata_path(),
            expected_remote_metadata_path
        );
        let expected_metadata_filename =
            CheckpointTarget::format_metadata_filename(attempt_timestamp.into());
        assert_eq!(
            &metadata.target.remote_metadata_file().unwrap(),
            &format!("{expected_remote_metadata_path}/{expected_metadata_filename}")
        );
    }
}
