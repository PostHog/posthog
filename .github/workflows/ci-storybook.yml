name: Storybook
on:
    pull_request:
    merge_group:
    push:
        branches:
            - master

concurrency:
    group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
    # Cancel in-progress runs on PRs when new commits are pushed
    # SHA verification ensures we don't commit stale snapshots if runs aren't cancelled in time
    cancel-in-progress: ${{ github.event_name == 'pull_request' }}

permissions:
    contents: write
    pull-requests: write

jobs:
    # Job to decide if we should run storybook ci
    # See https://github.com/dorny/paths-filter#conditional-execution for more details
    changes:
        runs-on: ubuntu-latest
        timeout-minutes: 5
        name: Determine need to run storybook checks
        if: github.event_name != 'merge_group'
        # Set job outputs to values from filter step
        outputs:
            frontend: ${{ steps.filter.outputs.frontend || 'true' }}
        steps:
            - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
              id: filter
              if: github.event_name != 'push' # Run all tests on master push
              with:
                  filters: |
                      frontend:
                        - 'frontend/**'
                        - 'products/!(mcp)/**/*.ts'
                        - 'products/!(mcp)/**/*.tsx'
                        - 'products/!(mcp)/**/frontend/**'
                        - 'common/**'
                        - 'ee/frontend/**'
                        - '.storybook/**'
                        - 'package.json'
                        - '.github/workflows/ci-storybook.yml'
                        - 'playwright.config.ts'

    build-storybook:
        name: Build Storybook
        runs-on: depot-ubuntu-24.04-8
        timeout-minutes: 15
        needs: changes
        if: needs.changes.outputs.frontend == 'true'
        steps:
            - uses: actions/checkout@v6
              with:
                  ref: ${{ github.event.pull_request.head.sha || github.sha }}
                  repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}

            - name: Install pnpm
              uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0

            - name: Set up Node.js
              uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6.1.0
              with:
                  node-version: 22.22.0
                  cache: pnpm

            - name: Install dependencies
              run: pnpm --filter=@posthog/storybook... install --frozen-lockfile

            - name: Cache webpack build
              uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
              with:
                  path: common/storybook/node_modules/.cache/
                  key: ${{ runner.os }}-webpack-storybook-${{ hashFiles('pnpm-lock.yaml') }}
                  restore-keys: ${{ runner.os }}-webpack-storybook-

            - name: Build Storybook
              env:
                  NODE_OPTIONS: --max-old-space-size=32768
              run: |
                  bin/turbo --filter=@posthog/storybook prepare
                  pnpm --filter=@posthog/storybook build --test

            - name: Upload Storybook build artifact
              uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
              with:
                  name: storybook-build
                  path: common/storybook/dist
                  retention-days: 1

    detect-snapshot-mode:
        name: Detect snapshot mode
        runs-on: ubuntu-latest
        needs: [changes]
        if: needs.changes.outputs.frontend == 'true'
        outputs:
            mode: ${{ steps.detect.outputs.mode }}
        steps:
            - name: Detect mode
              id: detect
              run: |
                  if [ "${{ github.event.pull_request.head.repo.full_name }}" != "${{ github.repository }}" ]; then
                    echo "mode=check" >> $GITHUB_OUTPUT
                    echo "Fork detected - running in CHECK mode (no commits allowed)"
                  else
                    AUTHOR="${{ github.actor }}"
                    echo "Workflow triggered by: $AUTHOR"
                    if [[ "$AUTHOR" == *"github-actions"* ]] || [[ "$AUTHOR" == *"[bot]"* ]] || [[ "$AUTHOR" == "posthog-bot" ]]; then
                      echo "mode=check" >> $GITHUB_OUTPUT
                      echo "::notice::ðŸ” Running in CHECK mode - snapshots must match exactly"
                    else
                      echo "mode=update" >> $GITHUB_OUTPUT
                      echo "::notice::ðŸ”„ Running in UPDATE mode - snapshots can be updated"
                    fi
                  fi

    visual-regression:
        name: Visual regression tests - ${{ matrix.browser }} (${{ matrix.shard }}/${{ matrix.shard_count }})
        runs-on: ubuntu-latest
        needs: [changes, build-storybook, detect-snapshot-mode]
        if: needs.changes.outputs.frontend == 'true'
        timeout-minutes: 20
        container:
            image: mcr.microsoft.com/playwright:v1.45.0
        strategy:
            fail-fast: false
            matrix:
                include:
                    - browser: chromium
                      shard_count: 16
                      shard: 1
                    - browser: chromium
                      shard_count: 16
                      shard: 2
                    - browser: chromium
                      shard_count: 16
                      shard: 3
                    - browser: chromium
                      shard_count: 16
                      shard: 4
                    - browser: chromium
                      shard_count: 16
                      shard: 5
                    - browser: chromium
                      shard_count: 16
                      shard: 6
                    - browser: chromium
                      shard_count: 16
                      shard: 7
                    - browser: chromium
                      shard_count: 16
                      shard: 8
                    - browser: chromium
                      shard_count: 16
                      shard: 9
                    - browser: chromium
                      shard_count: 16
                      shard: 10
                    - browser: chromium
                      shard_count: 16
                      shard: 11
                    - browser: chromium
                      shard_count: 16
                      shard: 12
                    - browser: chromium
                      shard_count: 16
                      shard: 13
                    - browser: chromium
                      shard_count: 16
                      shard: 14
                    - browser: chromium
                      shard_count: 16
                      shard: 15
                    - browser: chromium
                      shard_count: 16
                      shard: 16
                    # WebKit is much faster, so we run with only 3 shards
                    - browser: webkit
                      shard_count: 3
                      shard: 1
                    - browser: webkit
                      shard_count: 3
                      shard: 2
                    - browser: webkit
                      shard_count: 3
                      shard: 3
        env:
            NODE_OPTIONS: --max-old-space-size=16384
            OPT_OUT_CAPTURE: 1
        steps:
            - uses: actions/checkout@v6
              with:
                  ref: ${{ github.event.pull_request.head.sha || github.sha }}
                  repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}

            - name: Install pnpm
              uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0

            - name: Set up Node.js
              uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6.1.0
              with:
                  node-version: 22.22.0
                  cache: pnpm

            - name: Install package.json dependencies with pnpm
              run: pnpm --filter=@posthog/storybook... install --frozen-lockfile

            - name: Install CI utilities with pnpm
              run: pnpm install http-server wait-on -g

            - name: Download Storybook build artifact
              uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
              with:
                  name: storybook-build
                  path: common/storybook/dist

            - name: Serve Storybook in the background
              run: |
                  retries=5
                  max_timeout=30
                  pnpm exec http-server common/storybook/dist --port 6006 --silent &
                  server_pid=$!
                  echo "Started http-server with PID: $server_pid"

                  # Give the server a moment to start
                  sleep 2

                  while [ $retries -gt 0 ]; do
                      echo "Checking if Storybook is available (retries left: $retries, timeout: ${max_timeout}s)..."
                      if pnpm wait-on http://127.0.0.1:6006 --timeout $max_timeout; then
                          echo "âœ… Storybook is available at http://127.0.0.1:6006"
                          break
                      fi
                      retries=$((retries-1))
                      if [ $retries -gt 0 ]; then
                          echo "âš ï¸ Failed to connect to Storybook, retrying... ($retries retries left)"
                          # Check if server is still running
                          if ! kill -0 $server_pid 2>/dev/null; then
                              echo "âŒ http-server process is no longer running, restarting it..."
                              pnpm exec http-server common/storybook/dist --port 6006 --silent &
                              server_pid=$!
                              echo "Restarted http-server with PID: $server_pid"
                              sleep 2
                          fi
                      fi
                  done

                  if [ $retries -eq 0 ]; then
                      echo "âŒ Failed to serve Storybook after all retries"
                      # Try to get some diagnostic information
                      echo "Checking port 6006 status:"
                      netstat -tuln | grep 6006 || echo "Port 6006 is not in use"
                      echo "Checking http-server process:"
                      ps aux | grep http-server || echo "No http-server process found"
                      echo "Checking Storybook dist directory:"
                      ls -la common/storybook/dist || echo "Storybook dist directory not found"
                      exit 1
                  fi

            - name: Run @storybook/test-runner
              id: test-runner
              shell: bash
              env:
                  HOME: /root
                  STORYBOOK_SKIP_TAGS: 'test-skip,test-skip-${{ matrix.browser }}'
              run: |
                  set +e  # Allow snapshot update retry
                  # Attempt 1: Always verify (fast path when snapshots match)
                  echo "Attempt 1: Running @storybook/test-runner (verify)"
                  set -o pipefail
                  pnpm --filter=@posthog/storybook test:visual:ci:verify --browsers ${{ matrix.browser }} --shard ${{ matrix.shard }}/${{ matrix.shard_count }} 2>&1 | tee /tmp/test-output-${{ matrix.browser }}-${{ matrix.shard }}-attempt1.log
                  EXIT_CODE=$?
                  set +o pipefail

                  if [ $EXIT_CODE -ne 0 ]; then
                    # Attempt 1 failed for any reason - verify again to check if flaky
                    echo "Attempt 1 failed - verifying it's not flaky"
                    # Attempt 2: Verify again to confirm failure is consistent, not flaky
                    echo "Attempt 2: Running @storybook/test-runner (verify again to confirm)"
                    set -o pipefail
                    pnpm --filter=@posthog/storybook test:visual:ci:verify --browsers ${{ matrix.browser }} --shard ${{ matrix.shard }}/${{ matrix.shard_count }} 2>&1 | tee /tmp/test-output-${{ matrix.browser }}-${{ matrix.shard }}-attempt2.log
                    EXIT_CODE=$?
                    set +o pipefail

                    if [ $EXIT_CODE -ne 0 ]; then
                      # Still failing - check if we should update snapshots
                      if [ "${{ needs.detect-snapshot-mode.outputs.mode }}" == "update" ] && grep -Eqi "(snapshot.*(failed|was not written)|Expected image to)" /tmp/test-output-${{ matrix.browser }}-${{ matrix.shard }}-attempt2.log 2>/dev/null; then
                        echo "Snapshot failure confirmed on attempt 2 - updating snapshots"
                        # Attempt 3: Update snapshots
                        echo "Attempt 3: Running @storybook/test-runner (update)"
                        set -o pipefail
                        pnpm --filter=@posthog/storybook test:visual:ci:update --browsers ${{ matrix.browser }} --shard ${{ matrix.shard }}/${{ matrix.shard_count }} 2>&1 | tee /tmp/test-output-${{ matrix.browser }}-${{ matrix.shard }}-attempt3.log
                        EXIT_CODE=$?
                        set +o pipefail

                        if [ $EXIT_CODE -ne 0 ]; then
                          echo "Test runner failed after 3 attempts"
                          exit 1
                        fi
                      else
                        echo "Non-snapshot failure on attempt 2 - not retrying further"
                        exit 1
                      fi
                    else
                      echo "Attempt 2 passed - failure on attempt 1 was flaky"
                    fi
                  fi

            - name: Archive failure screenshots
              if: failure()
              uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
              with:
                  name: failure-screenshots-${{ matrix.browser }}-${{ matrix.shard }}
                  path: frontend/__snapshots__/__failures__/

            - name: Configure global git diff log
              run: git config --global --add safe.directory '*'

            # Create git patch for aggregation (handles A/M/D including binary files)
            # Only run in UPDATE mode - CHECK mode doesn't update snapshots
            # Run even if tests failed, as long as snapshots may have been updated
            - name: Create snapshot patch
              id: create-patch
              if: needs.detect-snapshot-mode.outputs.mode == 'update' && (success() || failure()) && github.event.pull_request.head.repo.full_name == github.repository
              run: |
                  # Verify we're in a git repository before running git commands
                  if ! git rev-parse --git-dir > /dev/null 2>&1; then
                    echo "Not in a git repository, skipping patch creation"
                    echo "has-changes=false" >> $GITHUB_OUTPUT
                    exit 0
                  fi

                  # Check if there are any changes (modified or untracked) in the snapshot directory
                  # Use git status --porcelain to detect both modifications and new untracked files
                  if [ -z "$(git status --porcelain frontend/__snapshots__/)" ]; then
                    echo "No snapshot changes"
                    echo "has-changes=false" >> $GITHUB_OUTPUT
                  else
                    echo "Snapshot changes detected:"
                    git status --short frontend/__snapshots__/

                    # Stage untracked files so git diff can include them in the patch
                    git add -N frontend/__snapshots__/
                    # Create binary-safe patch file
                    mkdir -p /tmp/patches
                    git diff --binary --full-index frontend/__snapshots__/ > /tmp/patches/shard-${{ matrix.browser }}-${{ matrix.shard }}.patch
                    echo "Created patch file"
                    echo "has-changes=true" >> $GITHUB_OUTPUT
                  fi

            - name: Upload snapshot patch
              if: steps.create-patch.outputs.has-changes == 'true' && (success() || failure())
              uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
              with:
                  name: snapshot-patch-${{ matrix.browser }}-${{ matrix.shard }}
                  path: /tmp/patches/shard-${{ matrix.browser }}-${{ matrix.shard }}.patch
                  retention-days: 1
                  if-no-files-found: ignore

    # Job to collate the status of the matrix jobs for requiring passing status
    # Must depend on handle-snapshots to prevent auto-merge before commits complete
    visual_regression_tests:
        needs: [visual-regression, handle-snapshots]
        name: Visual regression tests pass
        runs-on: ubuntu-latest
        if: always()
        steps:
            - name: Check matrix outcome
              run: |
                  # Check visual-regression matrix result
                  if [[ "${{ needs.visual-regression.result }}" != "success" && "${{ needs.visual-regression.result }}" != "skipped" ]]; then
                    echo "One or more jobs in the visual-regression test matrix failed."
                    exit 1
                  fi

                  # Check handle-snapshots result (OK if skipped, but fail if it failed)
                  if [[ "${{ needs.handle-snapshots.result }}" == "failure" ]]; then
                    echo "Snapshot commit job failed."
                    exit 1
                  fi

                  echo "All jobs passed or were skipped successfully."

    handle-snapshots:
        name: Handle snapshot changes
        runs-on: ubuntu-latest
        needs: [visual-regression, detect-snapshot-mode, changes]
        if: always() && needs.detect-snapshot-mode.outputs.mode == 'update' && needs.changes.outputs.frontend == 'true' && github.event.pull_request.head.repo.full_name == github.repository
        steps:
            # Use GitHub app token so Actions run after commiting updated snapshots
            - name: Get app token
              id: app-token
              uses: getsentry/action-github-app-token@d4b5da6c5e37703f8c3b3e43abb5705b46e159cc # v3.0.0
              with:
                  app_id: ${{ secrets.GH_APP_POSTHOG_TESTS_APP_ID }}
                  private_key: ${{ secrets.GH_APP_POSTHOG_TESTS_PRIVATE_KEY }}

            - uses: actions/checkout@v6
              with:
                  ref: ${{ github.event.pull_request.head.sha || github.sha }}
                  repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
                  token: ${{ steps.app-token.outputs.token || github.token }}
                  fetch-depth: 1

            - name: Download snapshot patches
              id: download-patches
              continue-on-error: true
              uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
              with:
                  pattern: snapshot-patch-*
                  path: /tmp/snapshot-patches/
                  merge-multiple: true

            - name: Check for snapshot changes
              id: check-snapshots
              run: |
                  # Check if patches were downloaded and have content
                  if [ "${{ steps.download-patches.outcome }}" == "failure" ] || [ ! -d /tmp/snapshot-patches/ ]; then
                    echo "has-changes=false" >> $GITHUB_OUTPUT
                    echo "No snapshot patches found"
                    exit 0
                  fi

                  # Check if any patch files have content (>0 bytes)
                  PATCHES=$(find /tmp/snapshot-patches -name "*.patch" -type f -size +0c)
                  if [ -z "$PATCHES" ]; then
                    echo "has-changes=false" >> $GITHUB_OUTPUT
                    echo "Patch files empty - no snapshot changes"
                  else
                    echo "has-changes=true" >> $GITHUB_OUTPUT
                    echo "Snapshot changes detected in patches"
                  fi

            # UPDATE mode: commit the changes
            - name: Commit snapshot changes
              if: steps.check-snapshots.outputs.has-changes == 'true' && needs.detect-snapshot-mode.outputs.mode == 'update'
              uses: ./.github/actions/commit-snapshots
              with:
                  workflow-type: storybook
                  patch-path: /tmp/snapshot-patches/
                  snapshot-path: frontend/__snapshots__/
                  commit-message: 'test(storybook): update UI snapshots'
                  pr-number: ${{ github.event.pull_request.number }}
                  repository: ${{ github.repository }}
                  commit-sha: ${{ github.event.pull_request.head.sha }}
                  branch-name: ${{ github.event.pull_request.head.ref }}
                  github-token: ${{ steps.app-token.outputs.token || github.token }}

    calculate-running-time:
        name: Calculate running time
        needs: [visual-regression, changes]
        runs-on: ubuntu-latest
        if: # Run on pull requests to PostHog/posthog + on PostHog/posthog outside of PRs - but never on forks
            needs.changes.outputs.frontend == 'true' && (
            (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == 'PostHog/posthog') ||
            (github.event_name != 'pull_request' && github.repository == 'PostHog/posthog'))
        steps:
            - name: Calculate running time
              run: |
                  gh auth login --with-token < <(echo ${{ secrets.GITHUB_TOKEN }})
                  run_id=${GITHUB_RUN_ID}
                  repo=${GITHUB_REPOSITORY}
                  run_info=$(gh api repos/${repo}/actions/runs/${run_id})
                  echo run_info: ${run_info}
                  # name is the name of the workflow file
                  # run_started_at is the start time of the workflow
                  # we want to get the number of seconds between the start time and now
                  name=$(echo ${run_info} | jq -r '.name')
                  run_url=$(echo ${run_info} | jq -r '.url')
                  run_started_at=$(echo ${run_info} | jq -r '.run_started_at')
                  run_attempt=$(echo ${run_info} | jq -r '.run_attempt')
                  start_seconds=$(date -d "${run_started_at}" +%s)
                  now_seconds=$(date +%s)
                  duration=$((now_seconds-start_seconds))
                  echo running_time_duration_seconds=${duration} >> $GITHUB_ENV
                  echo running_time_run_url=${run_url} >> $GITHUB_ENV
                  echo running_time_run_attempt=${run_attempt} >> $GITHUB_ENV
                  echo running_time_run_id=${run_id} >> $GITHUB_ENV
                  echo running_time_run_started_at=${run_started_at} >> $GITHUB_ENV
            - name: Capture running time to PostHog
              uses: PostHog/posthog-github-action@8c42e50f2c52e002eabb9bee3f69b152ee8fc1dd # v1.0.1
              with:
                  posthog-token: ${{secrets.POSTHOG_API_TOKEN}}
                  event: 'posthog-ci-running-time'
                  properties: '{"duration_seconds": ${{ env.running_time_duration_seconds }}, "run_url": "${{ env.running_time_run_url }}", "run_attempt": "${{ env.running_time_run_attempt }}", "run_id": "${{ env.running_time_run_id }}", "run_started_at": "${{ env.running_time_run_started_at }}"}'
