name: PR Cleanup

on:
    schedule:
        # Run daily at 3am UTC
        - cron: '0 3 * * *'
    workflow_call:
        inputs:
            pr_number:
                description: 'Specific PR number to cleanup (optional)'
                type: string
                required: false
    workflow_dispatch:
        inputs:
            pr_number:
                description: 'Specific PR number to cleanup (leave empty for all stale)'
                type: string
                required: false
            dry_run:
                description: 'Dry run (no actual cleanup)'
                type: boolean
                default: true
            max_inactive_days:
                description: 'Max days of PR inactivity before cleanup'
                type: number
                default: 7

permissions:
    deployments: write

jobs:
    cleanup-hobby-preview:
        name: Cleanup hobby preview droplets
        runs-on: ubuntu-24.04
        steps:
            - uses: actions/checkout@v6

            - name: Install uv
              uses: astral-sh/setup-uv@eac588ad8def6316056a12d4907a9d4d84ff7a3b

            - name: Cleanup specific PR droplet
              if: inputs.pr_number != ''
              env:
                  DIGITALOCEAN_TOKEN: ${{ secrets.DIGITAL_OCEAN_HOBBY_TOKEN }}
                  PR_NUMBER: ${{ inputs.pr_number }}
              run: uv run bin/hobby-ci.py destroy-pr

            - name: Cleanup stale droplets
              if: inputs.pr_number == ''
              env:
                  DIGITALOCEAN_TOKEN: ${{ secrets.DIGITAL_OCEAN_HOBBY_TOKEN }}
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  MAX_INACTIVE_DAYS: ${{ inputs.max_inactive_days || '7' }}
                  DRY_RUN: ${{ inputs.dry_run || 'false' }}
              run: uv run bin/hobby-ci.py cleanup-stale

            - name: Cleanup GitHub deployments and environments
              uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
              with:
                  script: |
                      const fs = require('fs');

                      // Collect PR numbers to clean up from either input or stale cleanup output
                      let prsToClean = [];
                      const inputPr = '${{ inputs.pr_number }}';

                      if (inputPr) {
                          prsToClean = [inputPr];
                      } else {
                          // Read from file written by cleanup-stale
                          try {
                              const content = fs.readFileSync('/tmp/cleaned_prs.txt', 'utf8');
                              prsToClean = content.split(',').filter(pr => pr.trim());
                          } catch (e) {
                              console.log('No cleaned PRs file found');
                          }
                      }

                      if (prsToClean.length === 0) {
                          console.log('No PRs to cleanup');
                          return;
                      }

                      console.log(`Cleaning up GitHub deployments for PRs: ${prsToClean.join(', ')}`);

                      for (const prNumber of prsToClean) {
                          const environment = `preview-pr-${prNumber}`;
                          console.log(`\nCleaning up ${environment}...`);

                          try {
                              const { data: deployments } = await github.rest.repos.listDeployments({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  environment: environment,
                                  per_page: 100
                              });

                              console.log(`  Found ${deployments.length} deployment(s)`);

                              for (const deployment of deployments) {
                                  try {
                                      await github.rest.repos.createDeploymentStatus({
                                          owner: context.repo.owner,
                                          repo: context.repo.repo,
                                          deployment_id: deployment.id,
                                          state: 'inactive',
                                          description: 'Preview cleanup'
                                      });
                                      await github.rest.repos.deleteDeployment({
                                          owner: context.repo.owner,
                                          repo: context.repo.repo,
                                          deployment_id: deployment.id
                                      });
                                      console.log(`  Deleted deployment ${deployment.id}`);
                                  } catch (error) {
                                      console.log(`  Could not delete deployment ${deployment.id}: ${error.message}`);
                                  }
                              }

                              await github.rest.repos.deleteAnEnvironment({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  environment_name: environment
                              });
                              console.log(`  Deleted environment ${environment}`);
                          } catch (error) {
                              console.log(`  Could not cleanup ${environment}: ${error.message}`);
                          }
                      }

    cleanup-cf-pages-playwright:
        name: Cleanup Cloudflare Pages playwright reports
        runs-on: ubuntu-24.04
        steps:
            - uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
              env:
                  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
                  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
                  INPUT_PR_NUMBER: ${{ inputs.pr_number || '' }}
                  INPUT_DRY_RUN: ${{ inputs.dry_run || 'false' }}
              with:
                  script: |
                      const CF_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
                      const CF_ACCOUNT = process.env.CLOUDFLARE_ACCOUNT_ID;
                      const PROJECT = 'playwright-report';
                      const prNumber = process.env.INPUT_PR_NUMBER;
                      const dryRun = process.env.INPUT_DRY_RUN === 'true';

                      async function cfApi(path, method = 'GET') {
                          const url = `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT}/pages/projects/${PROJECT}${path}`;
                          const res = await fetch(url, {
                              method,
                              headers: { Authorization: `Bearer ${CF_TOKEN}` },
                          });
                          if (!res.ok && method === 'GET') {
                              throw new Error(`CF API ${method} ${path}: ${res.status}`);
                          }
                          return method === 'GET' ? (await res.json()) : res;
                      }

                      // Fetch all deployments, paginated
                      const deployments = [];
                      for (let page = 1; ; page++) {
                          const { result } = await cfApi(`/deployments?page=${page}&per_page=25`);
                          if (!result.length) break;
                          deployments.push(...result);
                      }
                      core.info(`Found ${deployments.length} total deployment(s)`);

                      // Group by PR branch
                      const byPr = new Map();
                      for (const d of deployments) {
                          const branch = d.deployment_trigger?.metadata?.branch;
                          const match = branch?.match(/^pr-(\d+)$/);
                          if (!match) continue;
                          const pr = match[1];
                          if (!byPr.has(pr)) byPr.set(pr, []);
                          byPr.get(pr).push(d);
                      }
                      core.info(`Found ${byPr.size} PR branch(es) with deployments`);

                      // Determine which PRs to clean up
                      let prsToClean;
                      if (prNumber) {
                          prsToClean = [prNumber];
                          core.info(`Targeting PR #${prNumber}`);
                      } else {
                          // Use hybrid approach: bulk fetch for many PRs, individual checks for few
                          const BULK_FETCH_THRESHOLD = 5;
                          
                          if (byPr.size >= BULK_FETCH_THRESHOLD) {
                              // Bulk approach: fetch all open PRs (more efficient for many PRs)
                              const openPrs = new Set();
                              for (let page = 1; ; page++) {
                                  const { data } = await github.rest.pulls.list({
                                      ...context.repo,
                                      state: 'open',
                                      per_page: 100,
                                      page,
                                  });
                                  if (!data.length) break;
                                  for (const pr of data) {
                                      openPrs.add(String(pr.number));
                                  }
                              }
                              core.info(`Found ${openPrs.size} open PR(s)`);
                              
                              prsToClean = [];
                              for (const pr of byPr.keys()) {
                                  if (openPrs.has(pr)) {
                                      core.info(`PR #${pr}: open -> keeping`);
                                  } else {
                                      prsToClean.push(pr);
                                      core.info(`PR #${pr}: closed (${byPr.get(pr).length} deployment(s)) -> cleaning up`);
                                  }
                              }
                          } else {
                              // Individual checks: fetch state for each PR (more efficient for few PRs)
                              prsToClean = [];
                              for (const pr of byPr.keys()) {
                                  try {
                                      const { data } = await github.rest.pulls.get({
                                          ...context.repo,
                                          pull_number: parseInt(pr),
                                      });
                                      if (data.state === 'closed') {
                                          prsToClean.push(pr);
                                          core.info(`PR #${pr}: closed (${byPr.get(pr).length} deployment(s)) -> cleaning up`);
                                      } else {
                                          core.info(`PR #${pr}: open -> keeping`);
                                      }
                                  } catch (e) {
                                      core.warning(`PR #${pr}: could not fetch state: ${e.message}`);
                                  }
                              }
                          }
                      }

                      if (!prsToClean.length) {
                          core.info('Nothing to clean up.');
                          return;
                      }

                      // Delete deployments
                      let deleted = 0;
                      for (const pr of prsToClean) {
                          const deps = byPr.get(pr) || [];
                          for (const d of deps) {
                              if (dryRun) {
                                  core.info(`[DRY RUN] Would delete ${d.id} (pr-${pr})`);
                              } else {
                                  const res = await cfApi(`/deployments/${d.id}?force=true`, 'DELETE');
                                  core.info(`Deleted ${d.id} (pr-${pr}): ${res.status}`);
                              }
                              deleted++;
                          }
                      }

                      core.info(`Done. Processed ${deleted} deployment(s) across ${prsToClean.length} PR(s).`);
